<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一只独来独往的水鸟</title>
  
  <subtitle>iOS</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-06T07:22:21.883Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>郑智文</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>布局结束监听工具</title>
    <link href="http://yoursite.com/2018/01/29/%E5%B8%83%E5%B1%80%E7%BB%93%E6%9D%9F%E7%9B%91%E6%B5%8B%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2018/01/29/布局结束监测工具/</id>
    <published>2018-01-28T16:00:00.000Z</published>
    <updated>2018-08-06T07:22:21.883Z</updated>
    
    <content type="html"><![CDATA[<p>有些时候，需要知道什么时候View会布局完成。比如需要在View布局完成之后，希望页面自动跳转到某一</p><p>个模块，如果不知道View什么时候布局完成，那跳转到某个位置的高度就无法计算了。</p><a id="more"></a><p>页面渲染布局必然是在准备好数据之后，所以通常一个页面先要通过网络请求将数据获取，然后再通过UI组</p><p>件进行渲染。所以要对View的布局进行监听肯定是在网络请求回来之后了，对于网络什么时候会结束只可能</p><p>是业务层自己才能知道，所以主要精力是分析网络请求回来之后的事情。</p><p>基本思路是通过CADdisplayLink来记录每一帧当前View作为根节点时视图层级的情况，同时和上一帧进行比较。</p><p>如果在一个较短的时间内发现两者不一致，就说明布局还未结束。如果这个时间之内两者一致，则说明布局完成</p><p>了。正常情况下，如果界面没有发生卡顿，一秒应该在40帧以上。如果设置的这个时间间隔是0.2s，那么在这个</p><p>时间间隔中，会绘制屏幕8次，也就是说如果连续8次屏幕渲染没有发生视图层级的变化就认为是布局结束了。</p><p>具体如何比较前后两帧是否一致呢，我是通过字符串记录当前帧视图层级中每一个View的对象信息(内存地址，坐</p><p>标和宽高)，比较两个字符串是否相等，如果相等就说明布局没有发生变化如果不等就说明发生了变化。</p><p>要点：</p><p>1 为了更少的侵入业务层，通过category + associatedObject来实现。</p><p>2 0.2s的时间间隔需要一个定时任务，通过GCD Source来实现，不使用NSTimer因为前者要更精确，不依赖</p><p>Runloop，不受其他任务的影响。</p><p>3 如何说明它的正确性：主要是通过和ViewController的声明周期方法viewDidLayoutSubViews调用时间先</p><p>后的对比，如果还未布局完成那么之后系统框架还会再调用viewDidLayoutSubViews，所以只需要看回调是</p><p>不是发生在viewDidLayoutSubViews之后，最后通过demo验证了这种方案的可行性。</p><p>代码：</p><p>UIView + LayoutCompleteChecker.h</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^callback)();</span><br><span class="line">- (void)startCheckingWithCompletionBlock:(callback)callback;</span><br></pre></td></tr></table></figure><p>UIView + LayoutCompleteChecker.m</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)viewTreeString</span><br><span class="line">&#123;</span><br><span class="line">    return objc_getAssociatedObject(self, @selector(viewTreeString));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setViewTreeString:(NSString *)treeString</span><br><span class="line">&#123;</span><br><span class="line">    objc_setAssociatedObject(self, @selector(viewTreeString), treeString, OBJC_ASSOCIATION_COPY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSNumber *)hasLayoutCompleted</span><br><span class="line">&#123;</span><br><span class="line">    NSNumber *result = objc_getAssociatedObject(self, @selector(hasLayoutCompleted));</span><br><span class="line">    if (!result) &#123;</span><br><span class="line">        return @(NO);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setLayoutCompleted:(NSNumber *)result</span><br><span class="line">&#123;</span><br><span class="line">    objc_setAssociatedObject(self, @selector(hasLayoutCompleted), result, OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (CADisplayLink *)displayLink</span><br><span class="line">&#123;</span><br><span class="line">    CADisplayLink *link = objc_getAssociatedObject(self, @selector(displayLink));</span><br><span class="line">    if (!link) &#123;</span><br><span class="line">        link = [CADisplayLink displayLinkWithTarget:self selector:@selector(p_checkerTick)];</span><br><span class="line">        objc_setAssociatedObject(self, @selector(displayLink), link, OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">    &#125;</span><br><span class="line">    return link;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)p_checkerTick</span><br><span class="line">&#123;</span><br><span class="line">    NSString *treeString = self.viewTreeString;</span><br><span class="line">    NSString *currentTreeString = self.currentLayoutString;</span><br><span class="line">    if (![treeString isEqualToString:currentTreeString]) &#123;</span><br><span class="line">        [self setViewTreeString:currentTreeString];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [self setLayoutCompleted:@(YES)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)currentLayoutString</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableString *layoutString = [NSMutableString stringWithFormat:@&quot;%@&quot;, self];</span><br><span class="line">    if (self.subviews.count) &#123;</span><br><span class="line">        for (int i = 0; i &lt; self.subviews.count; i++) &#123;</span><br><span class="line">            UIView *subView = self.subviews[i];</span><br><span class="line">            NSString *subViewString = [subView currentLayoutString];</span><br><span class="line">            [layoutString appendString:subViewString];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return [layoutString copy];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)startCheckingWithCompletionBlock:(callback)callback</span><br><span class="line">&#123;</span><br><span class="line">    [self.displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];</span><br><span class="line">    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());</span><br><span class="line">    </span><br><span class="line">    dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, kCheckInterval * NSEC_PER_SEC, kTolerance * NSEC_PER_SEC);</span><br><span class="line">    id __weak weakSelf = self;</span><br><span class="line">    dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">        NSNumber *result = self.hasLayoutCompleted;</span><br><span class="line">        if ([result boolValue]) &#123;</span><br><span class="line">            id __strong strongSelf = weakSelf;</span><br><span class="line">            dispatch_source_cancel(timer);</span><br><span class="line">            [[strongSelf displayLink] invalidate];</span><br><span class="line">            callback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_resume(timer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后对需要检测的View调用startCheckingWithCompletionBlock方法即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[self.view startCheckingWithCompletionBlock:^&#123;</span><br><span class="line">    NSLog(@&quot;布局完了&quot;);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>GitHub:<a href="https://github.com/huanshijiushiniu/layoutCompleteChecker" target="_blank" rel="noopener">https://github.com/huanshijiushiniu/layoutCompleteChecker</a></p><p>现在已经提交到CocoaPods，可以通过在podfile中添加引用来使用了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;layoutCompleteChecker&apos;, &apos;1.0.0&apos;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有些时候，需要知道什么时候View会布局完成。比如需要在View布局完成之后，希望页面自动跳转到某一&lt;/p&gt;
&lt;p&gt;个模块，如果不知道View什么时候布局完成，那跳转到某个位置的高度就无法计算了。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Node小结</title>
    <link href="http://yoursite.com/2018/01/11/Node%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2018/01/11/Node小结/</id>
    <published>2018-01-11T09:18:00.000Z</published>
    <updated>2018-08-06T04:03:34.828Z</updated>
    
    <content type="html"><![CDATA[<p>​    最近工作中用到了Node，实现了一个数据抓取处理的自动化工具。平时的使用中，主要还是依</p><p>赖各种库。对Node本身的一些原理性的东西也不是很清楚，只是会参考文档使用API，所以需要学习总结一下~</p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ul><li>Node平台的结构</li><li>js调用C++</li><li>异步IO</li><li>事件循环</li><li>异步流程处理</li><li>模块的加载和查找</li><li>相关的工具</li></ul><a id="more"></a><h4 id="Node平台的结构"><a href="#Node平台的结构" class="headerlink" title="Node平台的结构"></a>Node平台的结构</h4><p>​    Node使用js来进行开发，既可以用来写一些命令行的脚本工具，也可以用来开发服务端接口。显然js已经</p><p>脱离了浏览器的运行环境，并且平时的开发都是异步为主js又是单线程，是如何实现呢。需要先了解一下Node的</p><p>结构：</p><p>​    <img src="http://7xqgnx.com1.z0.glb.clouddn.com/Node%E5%B9%B3%E5%8F%B0%E7%BB%93%E6%9E%84.png" alt=""></p><p>​    在Node开始运行的时候，会进行C++库的加载。在js代码运行的时候，通过V8解析执行，再由于Node </p><p>bindings绑定到C++的调用上，这一切发生在V8的运行阶段。V8保证了js的运行环境，所以js可以在任何有v8的</p><p>环境中运行。libuv是一个主要来负责Node中异步处理和事件驱动以及跨平台的调用，也就是说在js中对于系统</p><p>api的调用都会通过libuv来实现，js只负责了调用和回调的处理。js和C++部分的调用有需要通过jsBinding来</p><p>处理的。</p><p>​    Node中的异步主要是通过libuv来实现，当任务完成之后，libuv通过回调来通知js层。</p><h4 id="js调用C"><a href="#js调用C" class="headerlink" title="js调用C++"></a>js调用C++</h4><p>js调用C++主要依赖于V8的运行时，现在考虑以下js代码如何最终调用libuv中的文件读写函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">fs.readFileSync(<span class="string">'path'</span>);</span><br></pre></td></tr></table></figure><p>对于libuv部分的C++库，在Node加载的时候会被加载到V8中等待Js的调用。</p><p>对于JS部分的代码，会通过V8进行编译解释，再通过jsbinding调用到C++的接口。既然JS能够调用到C++的接口，</p><p>那么C++中必然有相应能够表示JS对象和方法的对象，在Node中通过XXWrap来进行封装的。比如针对现在的例子</p><p>fs对应的就是FSReqWrap对象，它位于node_file.cc文件中。</p><p>在Node开始执行js代码之前，首先会对自己进行初始化，加载自身的C++库。对于C++库中的对象，以当前代码</p><p>为例子它不会直接创建FSReqWrap对象，而是将该对象的初始化函数通过node_module_register函数保存到一个</p><p>全局的表中，那么什么时候会真正初始化对象呢。</p><p>在fs.js源文件中有：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> binding = process.binding(<span class="string">'fs'</span>);</span><br></pre></td></tr></table></figure><p>也就是在这行代码被调用的时候，FSReqWrap对象开始初始化，以便可以js调用</p><p>在下面代码执行的时候，上面的process.binding(‘fs’)也就会被调用了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = rquire(<span class="string">'fs'</span>);</span><br></pre></td></tr></table></figure><p>也就是说什么时候你使用了fs这个库，什么时候C++中对应的FSReqWrap对象进行加载和初始化。这也是为了加载</p><p>时间以及运行效率考虑吧，类似懒加载的策略。</p><p>现在来看一下FSReqWrap初始化的时候做了哪些事呢：</p><p>在node_file.cc中：</p><p>因为初始化函数比较长，所以分成2块：</p><p><img src="http://7xqgnx.com1.z0.glb.clouddn.com/C++%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%961.png" alt=""></p><p>这一部分其实是往上下文对象中注册当前对象的函数信息，例如js中调用’read’的时候，对应到C++对象中对应</p><p>的函数是哪一个</p><p><img src="http://7xqgnx.com1.z0.glb.clouddn.com/C++%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%962.png" alt=""></p><p>这一部分主要是往上下文对象context中注册类型信息，也就是说在js中使用对象’fs’对应到C++中是哪一个对象</p><p>通过这种方式，将js中某个对象的某个方法调用和C++中的实现对应关系存到上线文对象context中了。</p><p>剩下的部分只需要V8解释执行js的时候，从上下文对象中获取这些信息就能将js的调用转化到C++的调用上了</p><p>实质上在V8解释js的时候主要运用了两个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">script::Compile</span><br><span class="line">script::run</span><br></pre></td></tr></table></figure><p>这两个函数调用的时候，V8会将上下文对象context传入。</p><p>现在通过一张图总结一下整个过程：图中context有标号1和2，代表着它们的执行顺序。</p><p><img src="http://7xqgnx.com1.z0.glb.clouddn.com/js%E8%B0%83%E7%94%A8C++.PNG" alt=""></p><p>右边的部分会在Node初始化的时候进行加载，这个过程主要是initFs初始化函数指针，FSReqWrap类型信息以及</p><p>FSReqWrap类型包含的函数注册到全局表中。在之后js代码调用中再根据需要去完成FSReqWrap的初始化，并</p><p>通过上下文对象查找到需要调用的FSReqWrap和相关函数。</p><h4 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h4><p>还是通过文件读写的例子来进行说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line">fs.readFile(&apos;path1&apos;, &apos;utf-8&apos;, callback1);</span><br><span class="line">fs.readFile(&apos;path2&apos;, &apos;utf-8&apos;, callback2);</span><br><span class="line">fs.readFile(&apos;path3&apos;, &apos;utf-8&apos;, callback3);</span><br></pre></td></tr></table></figure><p>现在通过fs对象读取文本文件，都是异步的方式，传入回调函数。在JS层是调用readFile之后直接返回接着执行</p><p>后面的代码，当文件读取完成在执行相应的callback。文件的读写功能在Node中通过libuv来实现，在libuv中文件</p><p>读写内部是通过不同的线程来完成，内部维护这一个线程池。</p><p>如下图所示：</p><p><img src="http://7xqgnx.com1.z0.glb.clouddn.com/%E5%BC%82%E6%AD%A5IO.png" alt=""></p><p>左侧绿色部分的流程是js所在线程的执行过程，每一次调用readFile之后接着往下执行下一个readFile。对于每一</p><p>次readFile的调用最终通过NodeBindings转换到libuv库中相关函数的调用，每一次文件读取派发到一个线程来完</p><p>成。等待文件读取完成，再通知js层callback回调。通过分析js层的调用顺序应该是fun1-&gt;fun2-&gt;fun3 后面3个</p><p>callback的先后顺序则是依赖libuv中文件读取完成的先后顺序，通过libuv来实现了js层的异步IO。</p><h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><p>在异步IO小结中，说明了Node中的异步IO是如何设计的。针对具体libuv如何通知js回调的过程，就需要了解一下</p><p>Node中事件循环中的设计：</p><p><img src="http://7xqgnx.com1.z0.glb.clouddn.com/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97.png" alt="事件循环队列"></p><p>libuv将各种系统层面的操作都封装成了一个事件对象，js和libuv之间的交互都是以事件进行驱动的。图中左侧是</p><p>libuv中设计的用于存储各种事件的队列，右侧则是uv_run函数运行的基本流程，类似一个不断迭代的循环，每次</p><p>迭代的过程中去检查各类对列中有没有需要处理的已经完成的事件，来驱动后面的流程。</p><p>通过文件读写的例子来说明一下详细过程：</p><p><img src="http://7xqgnx.com1.z0.glb.clouddn.com/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E8%BF%87%E7%A8%8B.png" alt=""></p><p>上图中浅蓝色的部分是整个流程中与文件读写有关系的部分，当js层调用了文件读取的函数后，通过jsbinding转化</p><p>成对libuv层的调用。libuv会先将文件读写的请求封装成一个事件对象(存储了回调函数)，并将该事件对象注册到</p><p>uv_fs_events队列中，然后将文件读写的任务派发给工作线程池中的一个闲置线程。等待该线程文件读写的任务完</p><p>成之后，通过修改uv_fs_events中事件对象的状态来进行通知。随后在uv_run的迭代中，检查uv_fs_events中</p><p>事件对象的状态发生变化，然后通过回调的方式通知js层文件读写已经完成。</p><h4 id="模块的加载和查找"><a href="#模块的加载和查找" class="headerlink" title="模块的加载和查找"></a>模块的加载和查找</h4><h5 id="模块分类"><a href="#模块分类" class="headerlink" title="模块分类"></a>模块分类</h5><p>在说明Node中模块的加载和查找之前，先看一下Node中模块的分类：</p><p><img src="http://7xqgnx.com1.z0.glb.clouddn.com/Node%E6%A8%A1%E5%9D%97%E7%9A%84%E5%88%86%E7%B1%BB.png" alt=""></p><p>Node中模块可以分为两大类：</p><p>第一类是原生模块，Node自带的功能组件，比如’http’ ‘fs’等。第二类是自定义模块，我们可以通过自己封装一些</p><p>功能到js,C++,json文件中，C++主要是用来针对一些系统或者是需要性能的部分来进行扩展，js主要是自己定义的</p><p>业务模块,json文件可以用来放置一些数据或者配置信息。而package文件夹，最熟悉的就是通过npm install 安装</p><p>的第三方模块了，这些都可以通过require的方式进行加载。</p><p>通常需要引用一个模块的时候使用require()方法，作为一个模块要导出你想公开的接口使用exports/</p><p>module.exports。</p><h5 id="模块文件加载"><a href="#模块文件加载" class="headerlink" title="模块文件加载"></a>模块文件加载</h5><p>module加载有一套自身的流程，在此之前先看一下对于一个全新Module，Node如何加载:</p><p><img src="http://7xqgnx.com1.z0.glb.clouddn.com/module%E5%8A%A0%E8%BD%BD.png" alt=""></p><p>在Node中，每个模块都是通过一个Module对象处理的，所以当你使用require(‘module’)引用一个新模块的时</p><p>候，Node会创建一个Module对象。Module对象在初始化的过程中会初始化当前module的exports属性(也就是</p><p>你在js文件中使用的Module.exports了)，生成新的Module中使用的require函数。然后调用load方法来加载文</p><p>件，它首先会进行文件类型的判断，根据文件类型进行加载。对于C++模块，会调用process.dlopen方法加载。</p><p>对于json文件则读取出来，再通过JSON.parse转化成json对象，并赋值给module.exports。对于js文件，会调用</p><p>_compile方法，更复杂一些下面会单独介绍。</p><p>总结一下，在生成module对象的时候会初始化exports属性和require函数，然后load方法主要是加载具体的模块</p><p>文件，最终的目的是给module.exports赋值，到最后require函数返回的是新生成的module.exports属性。</p><p>现在来看一下对于js文件，Node如何通过Module对象加载：</p><p><img src="http://7xqgnx.com1.z0.glb.clouddn.com/_compile%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0.png" alt=""></p><p>在Module的load方法中，对于js文件会调用_compile方法，在 _compile中会先调用wrap方法。wrap方法主要</p><p>是对于当前要加载js文件通过function做了一层包装，function的参数传入了当前module中的exports，require</p><p>以及module自身。然后将该function传递给v8的runInThisContext函数，runInThisContext函数主要做的事情就</p><p>是去执行这个传入的function，其实就相当于在执行你自己写好的js文件中的所有代码，这个时候最终会执行你自</p><p>己写的module.exports=xxxx。也就是说你写的js代码会在require的时候被执行，js代码中本身使用到的require</p><p>和module.exports都是通过当时运行环境的上下文参数传过来的。</p><p>所以和json文件加载不同的地方时，module.exports属性的赋值一个是在Node的load函数中，js文件的是在你自</p><p>己的代码中。</p><p>最后看一下对于package文件夹(以underscore这个库为例)，如何加载：</p><p><img src="http://7xqgnx.com1.z0.glb.clouddn.com/package%E5%8A%A0%E8%BD%BD.png" alt=""></p><p>Node会找到package.json文件，读取里面的main字段。按照main字段配置的值，去按相应的方式(js/json/c++)</p><p>加载对应的文件。如果没有找到package.json文件，那么就直接找对应的index.js/index.json/index.node文件，</p><p>再按照文件的方式加载。</p><h5 id="exports和module-exports"><a href="#exports和module-exports" class="headerlink" title="exports和module.exports"></a>exports和module.exports</h5><p>看了一下Node v0.1版本的相关源码，在module类型中对于exports的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">global.exports = this.exports</span><br></pre></td></tr></table></figure><p>所以exports相当于一个module.exports的引用，如果是你去改版exports，对于module.exports还是之前的值</p><p>并没有影响到module.exports。</p><h5 id="模块文件的查找"><a href="#模块文件的查找" class="headerlink" title="模块文件的查找"></a>模块文件的查找</h5><p>以下是当调用require(‘module’)的时候，模块文件的查找流程：</p><p><img src="http://7xqgnx.com1.z0.glb.clouddn.com/%E6%A8%A1%E5%9D%97%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E6%B5%81%E7%A8%8B.png" alt=""></p><p>整个流程中有查找文件模块的过程，这个后面具体细说，除此之外的流程并不复杂。可以看出在查找模块文件的时</p><p>候，文件缓存的优先级是最高的，其次是原生模块，最后才去文件模块中查找。猜测是跟时间复杂度有关系，从</p><p>文件缓存中应该是最快的。其次是原生模块，因为原生模块所在的路径位置是相对固定的。最后才是文件模块，它</p><p>的位置并不固定，查找起来就相对麻烦花费的时间更多一些。</p><p>下面再单独针对文件模块的查找讲一下它的过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(&apos;./test&apos;)</span><br></pre></td></tr></table></figure><p>module对象中有一个path方法，它返回的是在进行文件查找的时候，遍历的文件路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/home/jim/repos/node/node_modules</span><br><span class="line">/home/jim/repos/node_modules</span><br><span class="line">/home/jim/node_modules</span><br><span class="line">/home/node_modules</span><br><span class="line">/node_modules</span><br></pre></td></tr></table></figure><p>首先会在执行脚本所在路径以js/json/node或者文件件夹(package)的方式夹加载test，如果没有找到就去module</p><p>的path返回的路径数组逐一查找。如果最终没有找到就抛出异常：</p><p><img src="http://7xqgnx.com1.z0.glb.clouddn.com/%E6%96%87%E4%BB%B6%E6%A8%A1%E5%9D%97%E6%9F%A5%E6%89%BE.png" alt=""></p><h4 id="相关工具推荐"><a href="#相关工具推荐" class="headerlink" title="相关工具推荐"></a>相关工具推荐</h4><p>NVM    Node的安装/卸载以及版本管理工具</p><p>NPM    模块的安装/卸载管理工具</p><p>NRM    模块源的管理工具</p><p>最后是IDE：我使用的是sublime + Node插件 + sublime-text2-buildview </p><p>优点：编码和测试运行很方便，很轻量级，另外log信息是以一个独立窗口的形式呈现(而不是在最下面，这样log</p><p>比较多的时候就不方便查看了，主要是sublime-text2-buildview的功劳)，通过安装Node插件，在调试的时候也不</p><p>用在编辑器和控制台来回切换了，提高了效率。</p><h5 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h5><p><a href="https://www.cnblogs.com/lijiayi/p/js_node_module.html" target="_blank" rel="noopener">https://www.cnblogs.com/lijiayi/p/js_node_module.html</a></p><p><a href="http://www.infoq.com/cn/articles/nodejs-module-mechanism/#" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/nodejs-module-mechanism/#</a></p><p><a href="http://taobaofed.org/blog/2015/10/29/deep-into-node-1/" target="_blank" rel="noopener">http://taobaofed.org/blog/2015/10/29/deep-into-node-1/</a></p><p><a href="https://i5ting.github.io/wechat-dev-with-nodejs/index.html" target="_blank" rel="noopener">https://i5ting.github.io/wechat-dev-with-nodejs/index.html</a></p><p><a href="https://luzeshu.com/tech" target="_blank" rel="noopener">https://luzeshu.com/tech</a></p><p><a href="http://zihua.li/2012/03/use-module-exports-or-exports-in-node/" target="_blank" rel="noopener">http://zihua.li/2012/03/use-module-exports-or-exports-in-node/</a></p><p><a href="https://github.com/nodejs/node" target="_blank" rel="noopener">https://github.com/nodejs/node</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    最近工作中用到了Node，实现了一个数据抓取处理的自动化工具。平时的使用中，主要还是依&lt;/p&gt;
&lt;p&gt;赖各种库。对Node本身的一些原理性的东西也不是很清楚，只是会参考文档使用API，所以需要学习总结一下~&lt;/p&gt;
&lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Node平台的结构&lt;/li&gt;
&lt;li&gt;js调用C++&lt;/li&gt;
&lt;li&gt;异步IO&lt;/li&gt;
&lt;li&gt;事件循环&lt;/li&gt;
&lt;li&gt;异步流程处理&lt;/li&gt;
&lt;li&gt;模块的加载和查找&lt;/li&gt;
&lt;li&gt;相关的工具&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
    
      <category term="Node" scheme="http://yoursite.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>iOS性能监控</title>
    <link href="http://yoursite.com/2017/11/02/iOS%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/"/>
    <id>http://yoursite.com/2017/11/02/iOS性能监控/</id>
    <published>2017-11-01T16:00:00.000Z</published>
    <updated>2018-08-06T04:03:34.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="卡顿"><a href="#卡顿" class="headerlink" title="卡顿"></a>卡顿</h1><p>通过观察者注册到RunLoop可以在以下几个阶段收到通知</p><p>kCFRunLoopEntry</p><p>kCFRunLoopBeforeTimers</p><p>kCFRunLoopBeforeSources</p><p>kCFRunLoopBeforeWaiting</p><p>kCFRunLoopAfterWaiting</p><p>kCFRunLoopExit</p><p>kCFRunLoopAllActivities</p><p>__CFRunLoopRun具体源码分析可见<a href="http://huanshijiushiniu.github.io/2016/01/26/CFRunLoop/" target="_blank" rel="noopener">这篇博客</a>，根据源码提炼出Runloop循环的主要流程如下图：</p><p><img src="http://7xqgnx.com1.z0.glb.clouddn.com/runLoop%E5%BE%AA%E7%8E%AF%E6%B5%81%E7%A8%8B.png" alt="runLoop循环流程"></p><a id="more"></a><h2 id="RunLoop处理的事件源归类"><a href="#RunLoop处理的事件源归类" class="headerlink" title="RunLoop处理的事件源归类"></a>RunLoop处理的事件源归类</h2><p>RunLoop处理的事件源总体其实可以分为两大类，第一类的source0，第二类类是基于MachPort的消息。</p><p>平时UIView的事件处理以及代码中定义的block调用都属于source0，而线程之间的消息通讯，通过GCD派</p><p>发到主线程的任务以及NSTimer都是基于MachPort消息实现的。所以在流程图中，我将第二类进行了</p><p>突出，表示它们是一大类型。在官方文档中，它分为timer，source，Oberserver，source又分</p><p>为source0和source1，单独将timer拿出来。</p><h2 id="RunLoop的哪些状态值得被关注"><a href="#RunLoop的哪些状态值得被关注" class="headerlink" title="RunLoop的哪些状态值得被关注"></a>RunLoop的哪些状态值得被关注</h2><p>source0的任务执行前 RunLoop处于的状态是KCFRunLoopBeforeSources</p><p>基于machPort的任务执行前 RunLoop处于的状态是kCFRunLoopBeforeSources或者</p><p>kCFRunLoopAfterWaiting所以只需要监听Runloop的状态在CFRunLoopBeforeSources和</p><p>CFRunLoopAfterWaiting这两个状态是否产生了制定时间的执行时间就可以判断是否发生卡顿了。</p><p>而CFRunLoopBeforeWaiting之后，Runloop就进入睡眠了，没有处理其他事件源的逻辑。</p><p>如果监控该状态，在主线程睡眠的时候，就会判断为卡顿了，产生误报。</p><h2 id="监控主线程Runloop的状态变化"><a href="#监控主线程Runloop的状态变化" class="headerlink" title="监控主线程Runloop的状态变化"></a>监控主线程Runloop的状态变化</h2><p>开启一个子线程，让子线程去检测主线程Runloop的状态变化。在每次Runloop状态发生变化的时候，通过</p><p>dispatch_semaphore_signal发送一个信号，使得信号量的值加1.让子线程一直关注semaphore的变化，</p><p>如果主线程在Runloop某一个状态停留太久，那么semaphore会让子线程阻塞，直到超时，即发生了卡顿。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//全局或者成员变量</span><br><span class="line">CFRunLoopActivity currentActivity;</span><br><span class="line"></span><br><span class="line">//信号量</span><br><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</span><br><span class="line"></span><br><span class="line">//检测主线程Runloop状态</span><br><span class="line">CFRunLoopObserverRef observerRef = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault,</span><br><span class="line">                                                                      kCFRunLoopAllActivities,</span><br><span class="line">                                                                      YES, 0,</span><br><span class="line">                                                                      ^(CFRunLoopObserverRef observer, </span><br><span class="line">                                                                        CFRunLoopActivity activity) &#123;</span><br><span class="line">        if (self != nil &amp;&amp; semaphore != NULL) &#123;</span><br><span class="line">            currentActivity = activity;</span><br><span class="line">            dispatch_semaphore_signal(semaphore);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    CFRunLoopAddObserver(CFRunLoopGetMain(), observerRef, kCFRunLoopCommonModes);</span><br><span class="line">    CFRelease(observerRef);</span><br><span class="line"></span><br><span class="line">//通过信号量计算某一状态下是否执行超过制定时间，这里是1s</span><br><span class="line">while (!self.cancelled) &#123;</span><br><span class="line">        long status = dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, </span><br><span class="line">                                                                       1000 * NSEC_PER_MSEC));</span><br><span class="line">        if (status != 0) &#123;</span><br><span class="line">            if (self.cancelled || semaphore == NULL) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (currentActivity == kCFRunLoopBeforeSources || </span><br><span class="line">                currentActivity == kCFRunLoopAfterWaiting ) &#123;</span><br><span class="line">                if (self.cancelled) return;</span><br><span class="line">                //发生了卡顿</span><br><span class="line">                NSLog(@&quot;卡顿了&quot;);</span><br><span class="line">                if (self.cancelled) return;</span><br><span class="line">                dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最后用一张图来展示整个流程：</p><p><img src="http://7xqgnx.com1.z0.glb.clouddn.com/kadun.png" alt="卡顿监测"></p><h1 id="FPS"><a href="#FPS" class="headerlink" title="FPS"></a>FPS</h1><p>CADisplayLink是与屏幕刷新保持同步的定时器，通过它可以计算出实时的屏幕帧率。</p><p>在理想情况下，每秒60帧，CADdisplayLink回调的时间间隔就是1/60 ≈ 0.0167秒。</p><p>在runloop每次迭代的过程中，如果有耗时的任务，会增加CADdisplayLink回调时长，相对来说，计算出来</p><p>的帧率就会较小。屏幕绘制的时候，发生跳帧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CADisplayLink *link = [CADisplayLink displayLinkWithTarget:self selector:@selector(p_tick:)];</span><br><span class="line">[link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];</span><br><span class="line"></span><br><span class="line">- (void)p_tick:(CADisplayLink *)link</span><br><span class="line">&#123;</span><br><span class="line">    self.count++;</span><br><span class="line">    if (!self.lastTime) &#123;</span><br><span class="line">        self.lastTime = CACurrentMediaTime();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSTimeInterval currentTime = CACurrentMediaTime();</span><br><span class="line">        NSTimeInterval duration = currentTime - self.lastTime;</span><br><span class="line">        if (duration &gt; 1) &#123;</span><br><span class="line">            NSString *fps = [NSString stringWithFormat:@&quot;%.2f&quot;, (self.count / duration)];</span><br><span class="line">            self.FPSLabel.text = [NSString stringWithFormat:@&quot;帧率 ： %@&quot;, fps];</span><br><span class="line">            self.count = self.lastTime = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;卡顿&quot;&gt;&lt;a href=&quot;#卡顿&quot; class=&quot;headerlink&quot; title=&quot;卡顿&quot;&gt;&lt;/a&gt;卡顿&lt;/h1&gt;&lt;p&gt;通过观察者注册到RunLoop可以在以下几个阶段收到通知&lt;/p&gt;
&lt;p&gt;kCFRunLoopEntry&lt;/p&gt;
&lt;p&gt;kCFRunLoopBeforeTimers&lt;/p&gt;
&lt;p&gt;kCFRunLoopBeforeSources&lt;/p&gt;
&lt;p&gt;kCFRunLoopBeforeWaiting&lt;/p&gt;
&lt;p&gt;kCFRunLoopAfterWaiting&lt;/p&gt;
&lt;p&gt;kCFRunLoopExit&lt;/p&gt;
&lt;p&gt;kCFRunLoopAllActivities&lt;/p&gt;
&lt;p&gt;__CFRunLoopRun具体源码分析可见&lt;a href=&quot;http://huanshijiushiniu.github.io/2016/01/26/CFRunLoop/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇博客&lt;/a&gt;，根据源码提炼出Runloop循环的主要流程如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xqgnx.com1.z0.glb.clouddn.com/runLoop%E5%BE%AA%E7%8E%AF%E6%B5%81%E7%A8%8B.png&quot; alt=&quot;runLoop循环流程&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Method Swizzle的危机</title>
    <link href="http://yoursite.com/2017/09/25/Method%20Swizzle%E7%9A%84%E5%8D%B1%E6%9C%BA/"/>
    <id>http://yoursite.com/2017/09/25/Method Swizzle的危机/</id>
    <published>2017-09-24T16:00:00.000Z</published>
    <updated>2018-08-06T04:03:34.827Z</updated>
    
    <content type="html"><![CDATA[<p>在同时使用RAC和Aspects的时候，遇到了一个Crash，栈溢出了。</p><p>看了一下，是之前在项目中使用了RAC的rac_singalForSelector</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@weakify(self);</span><br><span class="line">[[viewController rac_signalForSelector:@selector(viewDidAppear:)] subscribeNext</span><br><span class="line">:^(id x) &#123;</span><br><span class="line">      @strongify(self);</span><br><span class="line">      self.shouldIgnorePushingViewControllers = NO;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>后来他又使用了Aspects库中的aspect_hookSelector</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[UIViewController aspect_hookSelector:@selector(viewDidAppear:) withOptions</span><br><span class="line">:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; info, BOOL animated) &#123;</span><br><span class="line">    NSLog(@&quot;AOP: %@ - %d&quot;, [info.instance class], animated);</span><br><span class="line">&#125; error:NULL];</span><br></pre></td></tr></table></figure><p>后来就仔细看了一下两者的实现，从接口上来说，RAC的rac_singalForSelector的实例对象方法Aspects的aspect_hookSelector类对象方法。</p><p>第一感觉是前者针对是实例对象，后者针对的是类对象。主要涉及的其实还是对象模型里的一些知识，操作了类对象和实例对象中的数据如果对对象模型不太熟悉，可以看一下我之前写的一篇Blog:<a href="http://huanshijiushiniu.github.io/2017/07/13/Method%20Swizzle%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">对象模型</a></p><p>现在来分析下原因，从源码入手，先来大致看RAC相关的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">static RACSignal *NSObjectRACSignalForSelector(NSObject *self, SEL selector, </span><br><span class="line">                                               Protocol *protocol) &#123;</span><br><span class="line">  //aliasSelector是为了区分原Selector，RAC加了自己的前缀</span><br><span class="line">SEL aliasSelector = RACAliasForSelector(selector);</span><br><span class="line"></span><br><span class="line">@synchronized (self) &#123;</span><br><span class="line">         //这里是根据aliasSelector获得相应的热信号，这个热信号主要是用于通知业务层的回调</span><br><span class="line">         //也就是subscribeNext后面那一段block</span><br><span class="line">RACSubject *subject = objc_getAssociatedObject(self</span><br><span class="line">                                                       , aliasSelector);</span><br><span class="line">if (subject != nil) return subject;</span><br><span class="line"></span><br><span class="line">         //这个地方是基于当前self类创建了一个新类型，有很多hook的逻辑都放在这个类型中</span><br><span class="line">         //具体逻辑在RACSwizzleClass函数中再分析</span><br><span class="line">Class class = RACSwizzleClass(self);</span><br><span class="line">NSCAssert(class != nil, @&quot;Could not swizzle class of %@&quot;, self);</span><br><span class="line"></span><br><span class="line">         //创建一个用于通知的热信号</span><br><span class="line">subject = [[RACSubject subject] setNameWithFormat:@&quot;%@ </span><br><span class="line">                   -rac_signalForSelector: %s&quot;, </span><br><span class="line">                   self.rac_description, </span><br><span class="line">                   sel_getName(selector)];</span><br><span class="line"></span><br><span class="line">         //通过关联对象的方式存储热信号</span><br><span class="line">objc_setAssociatedObject(self, </span><br><span class="line">                                 aliasSelector, </span><br><span class="line">                                 subject, </span><br><span class="line">                                 OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">[self.rac_deallocDisposable addDisposable: </span><br><span class="line">                             [RACDisposable  disposableWithBlock:^&#123;</span><br><span class="line">                      [subject sendCompleted];</span><br><span class="line">&#125;]];</span><br><span class="line"></span><br><span class="line">         //targetMethod是&quot;viewDidApear&quot;这个Selector的方法对象</span><br><span class="line">Method targetMethod = class_getInstanceMethod(class, selector);</span><br><span class="line">if (targetMethod == NULL) &#123;</span><br><span class="line">          //按照现有逻辑，这里应该是走不到的，先不去看它</span><br><span class="line">const char *typeEncoding;</span><br><span class="line">if (protocol == NULL) &#123;</span><br><span class="line">typeEncoding = RACSignatureForUndefinedSelector(selector);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// Look for the selector as an optional instance method.</span><br><span class="line">struct objc_method_description methodDescription =</span><br><span class="line">                  protocol_getMethodDescription(protocol, selector, NO, YES);</span><br><span class="line"></span><br><span class="line">if (methodDescription.name == NULL) &#123;</span><br><span class="line">// Then fall back to looking for a required </span><br><span class="line">                  //instance method.</span><br><span class="line">methodDescription = </span><br><span class="line">                      protocol_getMethodDescription(protocol</span><br><span class="line">                                                    , selector</span><br><span class="line">                                                    , YES</span><br><span class="line">                                                    , YES);</span><br><span class="line">NSCAssert(methodDescription.name != NULL</span><br><span class="line">                              , @&quot;Selector %@ does not exist in &lt;%s&gt;&quot;</span><br><span class="line">                              ,NSStringFromSelector(selector)</span><br><span class="line">                              , protocol_getName(protocol));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typeEncoding = methodDescription.types;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RACCheckTypeEncoding(typeEncoding);</span><br><span class="line"></span><br><span class="line">// Define the selector to call -forwardInvocation:.</span><br><span class="line">if (!class_addMethod(class, </span><br><span class="line">                                 selector,</span><br><span class="line">                                 _objc_msgForward, </span><br><span class="line">                                 typeEncoding)) &#123;</span><br><span class="line">NSDictionary *userInfo = @&#123;</span><br><span class="line">NSLocalizedDescriptionKey: </span><br><span class="line">                                         [NSString stringWithFormat:</span><br><span class="line">                                                NSLocalizedString(</span><br><span class="line">                                                  @&quot;A race condition occurred </span><br><span class="line">                                                  implementing %@ on class %@&quot;</span><br><span class="line">                                                  , nil)</span><br><span class="line">                                                ,NSStringFromSelector(selector)</span><br><span class="line">                                                , class],</span><br><span class="line">NSLocalizedRecoverySuggestionErrorKey: </span><br><span class="line">                   NSLocalizedString(@&quot;Invoke -rac_signalForSelector: </span><br><span class="line">                                     again to override the implementation.&quot;, nil)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">return [RACSignal error:[NSError errorWithDomain:</span><br><span class="line">                                         RACSelectorSignalErrorDomain</span><br><span class="line">                                code:RACSelectorSignalErrorMethodSwizzlingRace</span><br><span class="line">                                         userInfo:userInfo]];</span><br><span class="line">&#125;</span><br><span class="line">          //_objc_msgForward是消息进行转发的开始，这里主要是判断原始的</span><br><span class="line">          //方法对象有没有被hook成_objc_msgForward，因为下面要开始进行方法实现的替换了</span><br><span class="line">&#125; else if (method_getImplementation(targetMethod) != </span><br><span class="line">                   _objc_msgForward) &#123;</span><br><span class="line">// Make a method alias for the existing </span><br><span class="line">             //method implementation.</span><br><span class="line">const char *typeEncoding =</span><br><span class="line">              method_getTypeEncoding(targetMethod);</span><br><span class="line">RACCheckTypeEncoding(typeEncoding);</span><br><span class="line">             //class_addMethod只是在当前类型对象(不会去基类中查找)中</span><br><span class="line">             //去找有没有aliasSelector的方法，如果有就直接返回原来的方法实现</span><br><span class="line">            //如果没有就添加一个</span><br><span class="line">BOOL addedAlias __attribute__((unused)) = </span><br><span class="line">              class_addMethod(class, aliasSelector, </span><br><span class="line">                              method_getImplementation(targetMethod), </span><br><span class="line">                              typeEncoding);</span><br><span class="line">NSCAssert(addedAlias, @&quot;Original implementation </span><br><span class="line">                      for %@ is already copied to %@ on %@&quot;, </span><br><span class="line">                      NSStringFromSelector(selector), </span><br><span class="line">                      NSStringFromSelector(aliasSelector), class);</span><br><span class="line">// Redefine the selector to call -forwardInvocation:.</span><br><span class="line">             // 这里相当于对原始方法进行方法实现的替换，</span><br><span class="line">             //只要调用原始方法，直接会开始方法转发的过程</span><br><span class="line">class_replaceMethod(class</span><br><span class="line">                                , selector</span><br><span class="line">                                , _objc_msgForward,</span><br><span class="line">                                method_getTypeEncoding(targetMethod));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return subject;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过原始英文注释加上后来的中文注释应该能比较好的理解大致的过程了</p><p>分为2部分</p><p>1是创建用于通知业务层回调的热信号</p><p>2是Hook了当前类，创建了新的子类型，并将这个子类型的原始selector进行了方法实现的替换</p><p>既将原始selector实现替换成_objc_msgForward，增加了一个新的selector prefix_selector，</p><p>并将其实现为原始selector。另外个人觉得命名上最好是不要叫class了，可以改为subClass或者</p><p>swizzleClass，容易跟原始class搞混</p><p>接着就是RACSwizzleCalss函数了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">static Class RACSwizzleClass(NSObject *self) &#123;</span><br><span class="line">  //self.class和object_getClass返回的都是当前实例的类对象，好像没什么区别???</span><br><span class="line">Class statedClass = self.class;</span><br><span class="line">Class baseClass = object_getClass(self);</span><br><span class="line"></span><br><span class="line">// The &quot;known dynamic subclass&quot; is the subclass generated by RAC.</span><br><span class="line">// It&apos;s stored as an associated object on every instance that&apos;s already</span><br><span class="line">// been swizzled, so that even if something else swizzles the class of</span><br><span class="line">// this instance, we can still access the RAC generated subclass.</span><br><span class="line">    //这里官方说明了子类的用途，如果有其他地方swizzle了当前类对象，那也不太影响RAC自己的逻辑</span><br><span class="line">    //因为它所有的信息都保存在自己创建的子类中。</span><br><span class="line">Class knownDynamicSubclass = </span><br><span class="line">      objc_getAssociatedObject(self, RACSubclassAssociationKey);</span><br><span class="line">if (knownDynamicSubclass != Nil) return knownDynamicSubclass;</span><br><span class="line"></span><br><span class="line">NSString *className = NSStringFromClass(baseClass);</span><br><span class="line"></span><br><span class="line">if (statedClass != baseClass) &#123;</span><br><span class="line">         //这部分逻辑没走到，先不看</span><br><span class="line">@synchronized (swizzledClasses()) &#123;</span><br><span class="line">if (![swizzledClasses() containsObject:className]) &#123;</span><br><span class="line">RACSwizzleForwardInvocation(baseClass);</span><br><span class="line">RACSwizzleRespondsToSelector(baseClass);</span><br><span class="line">RACSwizzleGetClass(baseClass, statedClass);</span><br><span class="line">RACSwizzleGetClass(object_getClass(baseClass), </span><br><span class="line">                                   statedClass);</span><br><span class="line">RACSwizzleMethodSignatureForSelector(baseClass);</span><br><span class="line">[swizzledClasses() addObject:className];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return baseClass;</span><br><span class="line">&#125;</span><br><span class="line">     //加上RAC自己的前缀，给新的子类命名</span><br><span class="line">const char *subclassName = [className stringByAppendingString:</span><br><span class="line">                                RACSubclassSuffix].UTF8String;</span><br><span class="line">Class subclass = objc_getClass(subclassName);</span><br><span class="line"></span><br><span class="line">if (subclass == nil) &#123;</span><br><span class="line">        //createClass里面调用的是objc_allocateClassPair函数用于创建新的类型对象，</span><br><span class="line">        //它和下面的objc_registerClassPair函数是配对使用的</span><br><span class="line">subclass = [RACObjCRuntime createClass:subclassName </span><br><span class="line">                    inheritingFromClass:baseClass];</span><br><span class="line">if (subclass == nil) return nil;</span><br><span class="line">         //这里是对新的子类的forwardInvocation方法hook</span><br><span class="line">RACSwizzleForwardInvocation(subclass);</span><br><span class="line">         //hookRespondsToSelector方法</span><br><span class="line">RACSwizzleRespondsToSelector(subclass);</span><br><span class="line">         //hook了Class方法</span><br><span class="line">RACSwizzleGetClass(subclass, statedClass);</span><br><span class="line">         //这里object_getClass得到的还是statedClass，既原始的类。</span><br><span class="line">RACSwizzleGetClass(object_getClass(subclass), statedClass);</span><br><span class="line">         //hook了方法签名</span><br><span class="line">RACSwizzleMethodSignatureForSelector(subclass);</span><br><span class="line">//结束子类的创建</span><br><span class="line">objc_registerClassPair(subclass);</span><br><span class="line">&#125;</span><br><span class="line">//这里是将当前实例对象的类型信息改写成新的子类</span><br><span class="line">object_setClass(self, subclass);</span><br><span class="line">    //保存子类信息</span><br><span class="line">objc_setAssociatedObject(self, RACSubclassAssociationKey, subclass, </span><br><span class="line">                             OBJC_ASSOCIATION_ASSIGN);</span><br><span class="line">return subclass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RACSwizzleCalss函数里主要干的事情就是创建子类型：</p><p>1.给新的子类型命名</p><p>2.hook几个重要的消息转发方法，1是为了得到方法调用的入口 2是将子类伪装成原始的类型</p><p>3.改变了实例对象的isa指针为新的子类，当前实例对象的类型信息为新的子类信息</p><p>这里有必要看一下RACSwizzleGetClass函数的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void RACSwizzleGetClass(Class class, Class statedClass) &#123;</span><br><span class="line">SEL selector = @selector(class);</span><br><span class="line">Method method = class_getInstanceMethod(class, selector);</span><br><span class="line">IMP newIMP = imp_implementationWithBlock(^(id self) &#123;</span><br><span class="line">   //当调用子类的class方法的时候，返回的还是原始类型对象</span><br><span class="line">return statedClass;</span><br><span class="line">&#125;);</span><br><span class="line">class_replaceMethod(class</span><br><span class="line">, selector</span><br><span class="line">, newIMP</span><br><span class="line">, method_getTypeEncoding(method));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，使用者感觉不到有什么异样，不知道hook的存在了</p><p>最后重点看一下RACSwizzleForwardInvocation函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">static void RACSwizzleForwardInvocation(Class class) &#123;</span><br><span class="line">SEL forwardInvocationSEL = @selector(forwardInvocation:);</span><br><span class="line">Method forwardInvocationMethod = </span><br><span class="line">      class_getInstanceMethod(class</span><br><span class="line">                              , forwardInvocationSEL);</span><br><span class="line"></span><br><span class="line">// Preserve any existing implementation of -forwardInvocation:.</span><br><span class="line">void (*originalForwardInvocation)(id, SEL, NSInvocation *) = NULL;</span><br><span class="line">if (forwardInvocationMethod != NULL) &#123;</span><br><span class="line">originalForwardInvocation =</span><br><span class="line">(__typeof__(originalForwardInvocation))method_getImplementation(</span><br><span class="line">          forwardInvocationMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Set up a new version of -forwardInvocation:.</span><br><span class="line">//</span><br><span class="line">// If the selector has been passed to -rac_signalForSelector:, invoke</span><br><span class="line">// the aliased method, and forward the arguments to any attached signals.</span><br><span class="line">//</span><br><span class="line">// If the selector has not been passed to -rac_signalForSelector:,</span><br><span class="line">// invoke any existing implementation of -forwardInvocation:. If there</span><br><span class="line">// was no existing implementation, throw an unrecognized selector</span><br><span class="line">// exception.</span><br><span class="line">id newForwardInvocation = ^(id self, NSInvocation *invocation) &#123;</span><br><span class="line">BOOL matched = RACForwardInvocation(self, invocation);</span><br><span class="line">if (matched) return;</span><br><span class="line"></span><br><span class="line">if (originalForwardInvocation == NULL) &#123;</span><br><span class="line">[self doesNotRecognizeSelector:invocation.selector];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">             //如果走到这里，基本上也要抛出异常了，一搬hook的都是必有的方法，已经绕过了</span><br><span class="line">             //原来的方法查找的过程到了消息转发这一步</span><br><span class="line">originalForwardInvocation(self, forwardInvocationSEL, </span><br><span class="line">                                      invocation);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class_replaceMethod(class, forwardInvocationSEL,</span><br><span class="line">                        imp_implementationWithBlock(newForwardInvocation)</span><br><span class="line">                        , &quot;v@:@&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用newForwardInvocation替换了原来的forwardInvocation实现，里面又调用了RACForwardInvocation函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static BOOL RACForwardInvocation(id self, NSInvocation *invocation) &#123;</span><br><span class="line">    //这里的invocation还是原始的方法调用信息，手动改成了带前缀的selector</span><br><span class="line">SEL aliasSelector = RACAliasForSelector(invocation.selector);</span><br><span class="line">    //获取一下之前存储的热信号</span><br><span class="line">RACSubject *subject = objc_getAssociatedObject(self, aliasSelector);</span><br><span class="line">    //这里的class得到的是RAC创建的子类，因为之前已经改写了实例对象的ISA指针</span><br><span class="line">Class class = object_getClass(invocation.target);</span><br><span class="line">BOOL respondsToAlias = [class instancesRespondToSelector:aliasSelector];</span><br><span class="line">if (respondsToAlias) &#123;</span><br><span class="line">        //去改变selector为hook的新的selector，不然要死循环了</span><br><span class="line">invocation.selector = aliasSelector;</span><br><span class="line">         //这一步就是真正原始的方法调用了，还记得之前已经把aliasSelector的实现改为</span><br><span class="line">         //原始Selector的实现了吧</span><br><span class="line">[invocation invoke];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (subject == nil) return respondsToAlias;</span><br><span class="line">    //通知业务层，要监听的selector已经被调用了，这个发生在原始方法调用之后</span><br><span class="line">[subject sendNext:invocation.rac_argumentsTuple];</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面几个函数都是为这一步打基础的，到了真正方法调用的时候，原始方法的调用以及通知业务层回调都在这里完成。</p><p>通过以上分析，现在通过一张图总结一下：</p><p><img src="http://7xqgnx.com1.z0.glb.clouddn.com/RAC%20Swizzle%20Class.png" alt="RAC Swizzle Class"></p><p>现在看一下Aspectsaspect_hookSelector的实现,主要是aspect_prepareClassAndHookSelector函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">static void aspect_prepareClassAndHookSelector(NSObject *self, SEL selector</span><br><span class="line">                                               , NSError **error) &#123;</span><br><span class="line">    NSCParameterAssert(selector);</span><br><span class="line">   //这里等看aspect_hookClass具体分析其过程，暂时来看是生成了新子类</span><br><span class="line">    Class klass = aspect_hookClass(self, error);</span><br><span class="line">   //获得原始方法对象</span><br><span class="line">    Method targetMethod = class_getInstanceMethod(klass, selector);</span><br><span class="line">    IMP targetMethodIMP = method_getImplementation(targetMethod);</span><br><span class="line">    if (!aspect_isMsgForwardIMP(targetMethodIMP)) &#123;</span><br><span class="line">        // Make a method alias for the existing method implementation, </span><br><span class="line">        //it not already copied.</span><br><span class="line">        const char *typeEncoding = method_getTypeEncoding(targetMethod);</span><br><span class="line">        SEL aliasSelector = aspect_aliasForSelector(selector);</span><br><span class="line">        if (![klass instancesRespondToSelector:aliasSelector]) &#123;</span><br><span class="line">          //添加alias方法，实现为原方法实现</span><br><span class="line">            __unused BOOL addedAlias = </span><br><span class="line">              class_addMethod(klass            </span><br><span class="line">                              , aliasSelector                </span><br><span class="line">                              ,method_getImplementation(targetMethod)         </span><br><span class="line">                              ,typeEncoding);</span><br><span class="line">            NSCAssert(addedAlias, @&quot;Original implementation for %@ is already </span><br><span class="line">                      copied to %@ on %@&quot;, NSStringFromSelector(selector),</span><br><span class="line">                      NSStringFromSelector(aliasSelector), klass);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // We use forwardInvocation to hook in.</span><br><span class="line">        //这里跟RAC一样的做法，把原方法实现换成了_objc_msgForward</span><br><span class="line">        //调原方法会直接开始消息转发的过程</span><br><span class="line">        class_replaceMethod(klass</span><br><span class="line">                            , selector</span><br><span class="line">                            , aspect_getMsgForwardIMP(self, selector)</span><br><span class="line">                            ,typeEncoding);</span><br><span class="line">        AspectLog(@&quot;Aspects: Installed hook for -[%@ %@].&quot;, klass,</span><br><span class="line">                  NSStringFromSelector(selector));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致上来看，在方法实现的层面的处理和RAC很类似.实际调试过程中，aspect_hookClass最终只是调用了aspect_swizzleClassInPlace，然后aspect_swizzleClassInPlace其实调用了aspect_swizzleForwardInvocation现在来看一下aspect_swizzleForwardInvocation函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static void aspect_swizzleForwardInvocation(Class klass) &#123;</span><br><span class="line">    NSCParameterAssert(klass);</span><br><span class="line">    // If there is no method, replace will act like class_addMethod.</span><br><span class="line">    //将forwardInvocation方法实现替换成了__ASPECTS_ARE_BEING_CALLED__</span><br><span class="line">    IMP originalImplementation = class_replaceMethod(klass</span><br><span class="line">                                          ,@selector(forwardInvocation:)</span><br><span class="line">                                          ,(IMP)__ASPECTS_ARE_BEING_CALLED__</span><br><span class="line">                                           ,&quot;v@:@&quot;);</span><br><span class="line">    if (originalImplementation) &#123;</span><br><span class="line">     //alias的forwardInvocation换成了原始实现</span><br><span class="line">        class_addMethod(klass, </span><br><span class="line">                        NSSelectorFromString(AspectsForwardInvocationSelectorName),</span><br><span class="line">                        originalImplementation, &quot;v@:@&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    AspectLog(@&quot;Aspects: %@ is now aspect aware.&quot;, NSStringFromClass(klass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在消息转发的最后关头，调用ASPECTS_ARE_BEING_CALLED</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">static void __ASPECTS_ARE_BEING_CALLED__(__unsafe_unretained NSObject *self, </span><br><span class="line">                                         SEL selector, </span><br><span class="line">                                         NSInvocation *invocation) &#123;</span><br><span class="line">    NSCParameterAssert(self);</span><br><span class="line">    NSCParameterAssert(invocation);</span><br><span class="line">    SEL originalSelector = invocation.selector;</span><br><span class="line">    //得到相应的aliasSelector</span><br><span class="line">SEL aliasSelector = aspect_aliasForSelector(invocation.selector);</span><br><span class="line">    //替换selector，因为invocation中的selector还是原始的selector</span><br><span class="line">    //不然递归死循环跟RAC一样</span><br><span class="line">    invocation.selector = aliasSelector;</span><br><span class="line">    //通过aliasSelector得到hook的用户回调</span><br><span class="line">    AspectsContainer *objectContainer = objc_getAssociatedObject(self, </span><br><span class="line">                                                                 aliasSelector);</span><br><span class="line">    AspectsContainer *classContainer = aspect_getContainerForClass(</span><br><span class="line">      object_getClass(self), </span><br><span class="line">      aliasSelector);</span><br><span class="line">    AspectInfo *info = [[AspectInfo alloc] initWithInstance:self </span><br><span class="line">                        invocation:invocation];</span><br><span class="line">    NSArray *aspectsToRemove = nil;</span><br><span class="line"></span><br><span class="line">    // Before hooks.</span><br><span class="line">   //触发那些在原始逻辑调用之前的回调</span><br><span class="line">    aspect_invoke(classContainer.beforeAspects, info);</span><br><span class="line">    aspect_invoke(objectContainer.beforeAspects, info);</span><br><span class="line"></span><br><span class="line">    // Instead hooks.</span><br><span class="line">    BOOL respondsToAlias = YES;</span><br><span class="line">    if (objectContainer.insteadAspects.count || </span><br><span class="line">        classContainer.insteadAspects.count) &#123;</span><br><span class="line">          //直接是回调替换原始实现了</span><br><span class="line">        aspect_invoke(classContainer.insteadAspects, info);</span><br><span class="line">        aspect_invoke(objectContainer.insteadAspects, info);</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        Class klass = object_getClass(invocation.target);</span><br><span class="line">        do &#123;</span><br><span class="line">            if ((respondsToAlias = [klass instancesRespondToSelector:</span><br><span class="line">                                    aliasSelector])) &#123;</span><br><span class="line">                //这里是触发原始方法的实现</span><br><span class="line">                [invocation invoke];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;while (!respondsToAlias &amp;&amp; (klass = class_getSuperclass(klass)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // After hooks.</span><br><span class="line">    //触发那些在原始方法调用之后的用户回调</span><br><span class="line">    aspect_invoke(classContainer.afterAspects, info);</span><br><span class="line">    aspect_invoke(objectContainer.afterAspects, info);</span><br><span class="line"></span><br><span class="line">    // If no hooks are installed, call original implementation (usually </span><br><span class="line">    //to throw an exception)</span><br><span class="line">    if (!respondsToAlias) &#123;</span><br><span class="line">        invocation.selector = originalSelector;</span><br><span class="line">        SEL originalForwardInvocationSEL =</span><br><span class="line">          NSSelectorFromString(AspectsForwardInvocationSelectorName);</span><br><span class="line">        if ([self respondsToSelector:originalForwardInvocationSEL]) &#123;</span><br><span class="line">            ((void( *)(id, SEL, NSInvocation *))objc_msgSend)(self, </span><br><span class="line">                                           originalForwardInvocationSEL,</span><br><span class="line">                                                              invocation);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            [self doesNotRecognizeSelector:invocation.selector];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Remove any hooks that are queued for deregistration.</span><br><span class="line">    [aspectsToRemove makeObjectsPerformSelector:@selector(remove)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看样子，在这种情况下A并没有想RAC一样创建新的子类型，它是直接更改了原始类型的方法信息。</p><p>用图来表示一下它当前的实现：</p><p><img src="http://7xqgnx.com1.z0.glb.clouddn.com/Aheater_Hook.png" alt="Aspects Hook"></p><p>和RAC比要简单一些，那么当同时使用两个库Hook的时候会出现什么情况呢？按照文章开头的场景，RAC相当于Hook了某个继承自UIViewController的子类,并基于该子类创建了新的子类型Aspects相当于直接Hook了UIViewController，对UIViewController本身的方法实现进行了更改替换现在假设继承自UIViewController业务子类型叫做BusinessVieweController</p><p>还是用一张简略图来表示两个库Hook之后的场景吧：</p><p><img src="http://7xqgnx.com1.z0.glb.clouddn.com/RAC%20%E5%92%8C%20AHeater%20%E4%B8%80%E8%B5%B7Hook.png" alt="RAC和Aspects一起Hook"></p><p>在类的继承结构下，Hook之后的结果，Aspects在UIViewController这一层，RAC在subClass这一层当有外界调用A方法时，subClass会最终首先调用原始A方法的实现。如果说在BusisnessViewController类型中定义了A方法的实现，并且在A方法中调用了super的A方法，类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidAppear:(BOOL)animated</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidAppear:animated];</span><br><span class="line">    //业务代码</span><br><span class="line">    //.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那这个时候会继续调用到UIViewController这一层，这个时候就会开始走UIViewController这一层的Hook流程了，还是一样最终会调用到forwardInvocation这个方法，但是这个时候subClass已经实现了这个方法，所以调用流程会回到子类subClass的Hook流程中，见上图中右上角的红色虚线部分。后面的逻辑就是无限循环，在两个类对象中往返直到栈溢出。</p><p>通过上面的分析，如果说在BusinessViewController中没有调用super的方法，那么不会引起死循环的，因为不会触发UIViewController类对象的Hook流程。并且当触发了死循环之后，会发现RAC订阅的业务层的回调和BusinessViewController的A方法中除了Super那一句，剩下的业务代码也没有被执行。另外，RAC这种Hook相对来说会更安全一些(并不是说Aspects就没有Hook Class 的情况，只是当前是这样)：它完全子类化了业务类，并且将Hook全都保留在了新建的子类型中，对其他类型包括原始业务类型没有干扰并且这种Hook只针对了某个具体的实例对象，其他势力对象如果没有通过调用rac_singalForSelector并不会受到任何影响。</p><p>如果是直接Hook原始类型，那么影响的面将是非常广的，包括所有的实例对象和所有的子类对象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在同时使用RAC和Aspects的时候，遇到了一个Crash，栈溢出了。&lt;/p&gt;
&lt;p&gt;看了一下，是之前在项目中使用了RAC的rac_singalForSelector&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Git Hook</title>
    <link href="http://yoursite.com/2017/07/25/GitHook/"/>
    <id>http://yoursite.com/2017/07/25/GitHook/</id>
    <published>2017-07-24T16:00:00.000Z</published>
    <updated>2018-08-06T04:03:34.825Z</updated>
    
    <content type="html"><![CDATA[<p>git hook 通过在代码commit和push之前执行一个脚本，来实现一些检查性工作😎。</p><p>在.git/hooks目录下的脚本文件，默认情况下该目录下有以下文件</p><p>applypatch-msg.sample </p><p>commit-msg:sample</p><p>pre-applypatch.sample</p><p>pre-commit.sample</p><p>pre-push.sample</p><p>pre-rebase.sample</p><p>prepare-commit-msg.sample</p><hr><p>update.sample</p><p>pre-receive.sample</p><p>post-update:sample</p><p>分割线前面几种是客户端钩子，后面几种是服务端钩子</p><p>pre-receive可以用来在服务端设置一些代码检查的功能，通过它可以拒绝一些不满足条件的push，无情的推行代</p><p>码检查。</p><p>post-receive它发生在push代码之后，可以通过CI来触发一些测试代码。</p><p>若要相应的钩子生效，编辑脚本文件的内容，去掉.sample后缀即可。脚本若返回非0值，则相应的git操作不再</p><p>往后执行。</p><p>通过pre-push来举个🌰</p><p>现在我想在每次push文件之时，检查项目中有没有重复图片，来减少不必要的包体积。假设检查重复图片的</p><p>脚本叫做duplicate_image_detector.py</p><p>现在通过客户端钩子来实现，因为./.git/hooks下的文件是无法通过git来进行管理，所以只能在客户端自己将</p><p>hook脚本拷贝在./.git/hoos目录下了，hook脚本本身可以通过git来管理。</p><p>hook脚本如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"><span class="meta">#</span> 图片检测</span><br><span class="line">if [ ! -f "./Checkers/duplicate_image_detector.py" ]; then</span><br><span class="line">  echo "未集成图片检测脚本"</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>如果有多个任务需要处理，下一个任务需要在上一个任务成功之后再执行，则需要通过：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>? -eq 0</span><br></pre></td></tr></table></figure><p>条件来判断上个任务是否以0结束，以0结束表示执行成功，反之返回非0就代表任务结束，不再继续执行了，</p><p>整体类似：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>前置任务</span><br><span class="line"><span class="meta">#</span>./abc/xyz/xx.rb</span><br><span class="line"></span><br><span class="line">if [ $? -eq 0 ]; then</span><br><span class="line">echo "***********xx.rb检测脚本通过****************"</span><br><span class="line">else</span><br><span class="line">echo "***********xx.rb检测脚本未通过****************"</span><br><span class="line">exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 图片检测</span><br><span class="line">if [ ! -f "./Checkers/duplicate_image_detector.py" ]; then</span><br><span class="line">  echo "未集成图片检测脚本"</span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>如果为了进一步方便，再写一个脚本来检查当前环境是否准备好了hook脚本，并进行本地部署：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">if ![-f ./shell/pre-push]; then</span><br><span class="line">echo "没有找到hook的脚本文件"</span><br><span class="line">exit(1)</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [-f ./.git/hooks/pre-push.sample]; then</span><br><span class="line">rm ./.git/hooks/pre-push.sample</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">cp  ./shell/pre-push ./.git/hooks/pre-push</span><br><span class="line"></span><br><span class="line">echo "hook设置成功"</span><br></pre></td></tr></table></figure><p>每次有新人就让他手动调用一下这个脚本，最好的方式是希望能够将.git/hooks/下的脚本纳入git管理。暂时没有找到解决方案😫，或者部署在服务端，但是需要管理员权限。</p><p>针对于上述问题，最后在同事提示下找到一个替换的方案。在Xcode的Build Phases中添加一个”Run Script”功能，在Xcode每次编译的时候都会执行这个脚本。</p><p>首先setupHook.sh需要修改一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">if [ -f ./shell/pre-push ]; then</span><br><span class="line">echo "hook文件存在"</span><br><span class="line">else</span><br><span class="line">echo "hook文件不存在"</span><br><span class="line">exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ -f ./.git/hooks/pre-push.sample ]; then</span><br><span class="line">rm ./.git/hooks/pre-push.sample</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ -f ./.git/hooks/pre-push ]; then</span><br><span class="line">echo "hook已经设置过"</span><br><span class="line">else</span><br><span class="line">echo "hook未设置，开始设置"</span><br><span class="line">cp  ./shell/pre-push ./.git/hooks/pre-push</span><br><span class="line">echo "hook设置成功"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>然后再将setupHook.sh脚本添加进去如下所示：</p><p><img src="http://7xqgnx.com1.z0.glb.clouddn.com/Run%20Script.png" alt="Run Script"></p><p>还需要修改一下脚本执行权限，在cmd中执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x setupHook.sh</span><br></pre></td></tr></table></figure><p>再Build一下，最后会看到如下输出：</p><p><img src="http://7xqgnx.com1.z0.glb.clouddn.com/log.png" alt="log"></p><p>就说明设置生效了。</p><p>这样一来，就不用太担心某个同学因为忘记设置hook脚本而提交代码没有触发脚本的问题了，因为提交代码之前不太可能不会Build代码，但是还是需要在README中显示的提醒一下，最后一步只是以防万一。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-Git-%E9%92%A9%E5%AD%90" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-Git-%E9%92%A9%E5%AD%90</a></li><li><a href="http://www.cnblogs.com/MyEyes/archive/2012/01/12/2320529.html" target="_blank" rel="noopener">http://www.cnblogs.com/MyEyes/archive/2012/01/12/2320529.html</a></li><li><a href="http://www.runoob.com/linux/linux-shell-variable.html" target="_blank" rel="noopener">http://www.runoob.com/linux/linux-shell-variable.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;git hook 通过在代码commit和push之前执行一个脚本，来实现一些检查性工作😎。&lt;/p&gt;
&lt;p&gt;在.git/hooks目录下的脚本文件，默认情况下该目录下有以下文件&lt;/p&gt;
&lt;p&gt;applypatch-msg.sample &lt;/p&gt;
&lt;p&gt;commit-msg
      
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Method Swizzle中的对象模型</title>
    <link href="http://yoursite.com/2017/06/19/Method%20Swizzle%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2017/06/19/Method Swizzle中的对象模型/</id>
    <published>2017-06-18T16:00:00.000Z</published>
    <updated>2018-08-06T04:03:34.827Z</updated>
    
    <content type="html"><![CDATA[<p>通常通过method swizzle可以交换两个方法的实现(不限于同一个类型)，先看一段代码：</p><p>People类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)talk</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, self.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student类继承People</p><p>Student</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load</span><br><span class="line">&#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line"> </span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line"> </span><br><span class="line">        SEL originalSelector = NSSelectorFromString(@&quot;talk&quot;);</span><br><span class="line"> </span><br><span class="line">        SEL swizzleSelector = NSSelectorFromString(@&quot;swizzle_talk&quot;);</span><br><span class="line"> </span><br><span class="line">        Method originalMethod = class_getInstanceMethod(self.class, originalSelector);</span><br><span class="line">        Method swizzleMethod = class_getInstanceMethod(self.class,</span><br><span class="line">         swizzleSelector);</span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzleMethod);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)swizzle_talk</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;swizzle_talk: %@&quot;, self.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Method在objc-private.h中有如下定义:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct old_method *Method;</span><br></pre></td></tr></table></figure><p>old_method是结构体，它定义在objc-runtime-old.h中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct old_method &#123;</span><br><span class="line">    SEL method_name;</span><br><span class="line">    char *method_types;</span><br><span class="line">    IMP method_imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Method中包含了3个部分，第一部分是函数名，通常可以通过@selector()获取，第二部分是函数声明, 第三部分是函数实现，理解成函数指针。</p><p>class_getInstanceMethod有两个参数，第一个参数是class，第二个参数是selector。这个函数是以class开头的，第一个参数也是传的class对象，所以可以理解为从所传递的类对象中查找指定的数据，类对象可以通过实例对象的class方法活的，类对象全局只有一个。</p><p>Class对象的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure><p>也就是说Class对象其实是objc_class结构体，平时使用的self.class得到的是一个objc_class的结构体指针。</p><p>objc_class定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line"> </span><br><span class="line">    Class superclass;</span><br><span class="line"> </span><br><span class="line">    const char *name;</span><br><span class="line"> </span><br><span class="line">    uint32_t version;</span><br><span class="line"> </span><br><span class="line">    uint32_t info;</span><br><span class="line"> </span><br><span class="line">    uint32_t instance_size;</span><br><span class="line"> </span><br><span class="line">    struct old_ivar_list *ivars;</span><br><span class="line"> </span><br><span class="line">    struct old_method_list **methodLists;</span><br><span class="line"> </span><br><span class="line">    Cache cache;</span><br><span class="line"> </span><br><span class="line">    struct old_protocol_list *protocols;</span><br><span class="line"> </span><br><span class="line">    // CLS_EXT only</span><br><span class="line"> </span><br><span class="line">    const uint8_t *ivar_layout;</span><br><span class="line"> </span><br><span class="line">    struct old_class_ext *ext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只列出了字段，函数并没有列出。可以看到一个类对象里面包含了以下比较重要的信息：</p><p>1.它的基类对象字段superclass</p><p>2.它的实例对象有哪些字段 ivars</p><p>3.它的实例对象有哪些方法，存储在方法列表中 **methodLists, 这里为什么是指针的指针，就是它可能包含多个方法列表。</p><p>4.它属于什么类型的类对象：info，比如CLS_CLASS还是CLS_META，相当于类对象自己的元数据信息。通过它可以判断出一个类对象是否是元类对象。</p><p>以下是class_getInstanceMethod的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">Method class_getInstanceMethod(Class cls, SEL sel)</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    if (!cls  ||  !sel) return nil;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    // This deliberately avoids +initialize because it historically did so.</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    // This implementation is a bit weird because it&apos;s the only place that</span><br><span class="line"> </span><br><span class="line">    // wants a Method instead of an IMP.</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    Method meth;</span><br><span class="line"> </span><br><span class="line">    meth = _cache_getMethod(cls, sel, _objc_msgForward_impcache);</span><br><span class="line"> </span><br><span class="line">    if (meth == (Method)1) &#123;</span><br><span class="line"> </span><br><span class="line">        // Cache contains forward:: . Stop searching.</span><br><span class="line"> </span><br><span class="line">        return nil;</span><br><span class="line"> </span><br><span class="line">    &#125; else if (meth) &#123;</span><br><span class="line"> </span><br><span class="line">        return meth;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">         </span><br><span class="line"> </span><br><span class="line">    // Search method lists, try method resolver, etc.</span><br><span class="line"> </span><br><span class="line">    lookUpImpOrNil(cls, sel, nil,</span><br><span class="line"> </span><br><span class="line">                   NO/*initialize*/, NO/*cache*/, YES/*resolver*/);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    meth = _cache_getMethod(cls, sel, _objc_msgForward_impcache);</span><br><span class="line"> </span><br><span class="line">    if (meth == (Method)1) &#123;</span><br><span class="line"> </span><br><span class="line">        // Cache contains forward:: . Stop searching.</span><br><span class="line"> </span><br><span class="line">        return nil;</span><br><span class="line"> </span><br><span class="line">    &#125; else if (meth) &#123;</span><br><span class="line"> </span><br><span class="line">        return meth;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    return _class_getMethod(cls, sel);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一部分主要是先从方法缓存里取方法，主要看下_class_getMethod</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static Method _class_getMethod(Class cls, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    mutex_locker_t lock(methodListLock);</span><br><span class="line"> </span><br><span class="line">    return (Method)_getMethod(cls, sel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在_class_getMethod中调用了_getMethod函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static inline old_method * _getMethod(Class cls, SEL sel) &#123;</span><br><span class="line"> </span><br><span class="line">    for (; cls; cls = cls-&gt;superclass) &#123;</span><br><span class="line"> </span><br><span class="line">        old_method *m;</span><br><span class="line"> </span><br><span class="line">        m = _findMethodInClass(cls, sel);</span><br><span class="line"> </span><br><span class="line">        if (m) return m;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return nil;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_getMethod是主要的实现了，这里通过_findMethodInClass函数来查找类对象的方法，并且便利了父类对象。也就是说，基类中的方法也会被遍历到。</p><p>继续再看下_findMethodInClass函数的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">static inline old_method * _findMethodInClass(Class cls, SEL sel) &#123;</span><br><span class="line"> </span><br><span class="line">    // Flattened version of nextMethodList(). The optimizer doesn&apos;t</span><br><span class="line"> </span><br><span class="line">    // do a good job with hoisting the conditionals out of the loop.</span><br><span class="line"> </span><br><span class="line">    // Conceptually, this looks like:</span><br><span class="line"> </span><br><span class="line">    // while ((mlist = nextMethodList(cls, &amp;iterator))) &#123;</span><br><span class="line"> </span><br><span class="line">    //     old_method *m = _findMethodInList(mlist, sel);</span><br><span class="line"> </span><br><span class="line">    //     if (m) return m;</span><br><span class="line"> </span><br><span class="line">    // &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    if (!cls-&gt;methodLists) &#123;</span><br><span class="line"> </span><br><span class="line">        // No method lists.</span><br><span class="line"> </span><br><span class="line">        return nil;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    else if (cls-&gt;info &amp; CLS_NO_METHOD_ARRAY) &#123;</span><br><span class="line"> </span><br><span class="line">        // One method list.</span><br><span class="line"> </span><br><span class="line">        old_method_list **mlistp;</span><br><span class="line"> </span><br><span class="line">        mlistp = (old_method_list **)&amp;cls-&gt;methodLists;</span><br><span class="line"> </span><br><span class="line">        *mlistp = fixupSelectorsInMethodList(cls, *mlistp);</span><br><span class="line"> </span><br><span class="line">        return _findMethodInList(*mlistp, sel);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    else &#123;</span><br><span class="line"> </span><br><span class="line">        // Multiple method lists.</span><br><span class="line"> </span><br><span class="line">        old_method_list **mlistp;</span><br><span class="line"> </span><br><span class="line">        for (mlistp = cls-&gt;methodLists;</span><br><span class="line"> </span><br><span class="line">             *mlistp != nil  &amp;&amp;  *mlistp != END_OF_METHODS_LIST;</span><br><span class="line"> </span><br><span class="line">             mlistp++)</span><br><span class="line"> </span><br><span class="line">        &#123;</span><br><span class="line"> </span><br><span class="line">            old_method *m;</span><br><span class="line"> </span><br><span class="line">            *mlistp = fixupSelectorsInMethodList(cls, *mlistp);</span><br><span class="line"> </span><br><span class="line">            m = _findMethodInList(*mlistp, sel);</span><br><span class="line"> </span><br><span class="line">            if (m) return m;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        return nil;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">static inline old_method *_findMethodInList(old_method_list * mlist, SEL sel) &#123;</span><br><span class="line"> </span><br><span class="line">    int i;</span><br><span class="line"> </span><br><span class="line">    if (!mlist) return nil;</span><br><span class="line"> </span><br><span class="line">    for (i = 0; i &lt; mlist-&gt;method_count; i++) &#123;</span><br><span class="line"> </span><br><span class="line">        old_method *m = &amp;mlist-&gt;method_list[i];</span><br><span class="line"> </span><br><span class="line">        if (m-&gt;method_name == sel) &#123;</span><br><span class="line"> </span><br><span class="line">            return m;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return nil;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要是通过遍历类对象的方法列表字段，来查找某个方法。</p><p>在_findMethodInList函数中，它其实是比较了方法列表中方法的Selector和要找的Selector是不是同一个来查找这个方法。所以通过selector就可以定位到一个method，也就是可以得到它的IMP和Type了。</p><p>所以可以很好理解一下2个方法：</p><p>method_getTypeEncoding</p><p>method_getImplementation</p><p>通过以上分析，可以知道class_getInstanceMethod是获得某个类对象中的方法对象，这个过程中会遍历到父类中。也就是当前类没有实现的方法，父类来抵，也符合面向对象的设计。</p><p>总的说来，class_getxxxxxxx是通过查找类对象内部数据来得到一些消息，类似的还有</p><p>class_getClassMethod，它是获取类方法的函数：</p><p>看看它的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Method class_getClassMethod(Class cls, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls  ||  !sel) return nil;</span><br><span class="line">    return class_getInstanceMethod(cls-&gt;getMeta(), sel);</span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line">Class getMeta() &#123;</span><br><span class="line"> </span><br><span class="line">   if (isMetaClass()) return (Class)this;</span><br><span class="line"> </span><br><span class="line">   else return this-&gt;ISA();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">bool isMetaClass() &#123;</span><br><span class="line">   return info &amp; CLS_META;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">#define CLS_CLASS 0X1</span><br><span class="line">#define CLS_META 0x2</span><br></pre></td></tr></table></figure><p>可以知道如果当前类就是元类对象，就返回它自己反之返回this→ISA();</p><p>objc_class继承自objc_object,函数ISA是objc_object中定义的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">truct objc_object &#123;</span><br><span class="line"> </span><br><span class="line">private:</span><br><span class="line"> </span><br><span class="line">    isa_t isa; </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">uion isa_t &#123;</span><br><span class="line">  </span><br><span class="line">  Class clas;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于取出objc_class对象的cls信息，也就是元类对象了。</p><p>然后通过cls_getInstanceMethod来去到Method信息，跟之前取类对象中的Method一样，只是多了一步取元类对象的步骤。</p><p>在理解了class_getInstanceMethod函数之后，再来看一下class_addMethod函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    IMP old;</span><br><span class="line"> </span><br><span class="line">    if (!cls) return NO;</span><br><span class="line"> </span><br><span class="line">    old = _class_addMethod(cls, name, imp, types, NO);</span><br><span class="line"> </span><br><span class="line">    return !old;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">static IMP _class_addMethod(Class cls, SEL name, IMP imp,</span><br><span class="line"> </span><br><span class="line">                            const char *types, bool replace)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    old_method *m;</span><br><span class="line"> </span><br><span class="line">    IMP result = nil;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    if (!types) types = &quot;&quot;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    mutex_locker_t lock(methodListLock);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    if ((m = _findMethodInClass(cls, name))) &#123;</span><br><span class="line"> </span><br><span class="line">        // already exists</span><br><span class="line"> </span><br><span class="line">        // fixme atomic</span><br><span class="line"> </span><br><span class="line">        result = method_getImplementation((Method)m);</span><br><span class="line"> </span><br><span class="line">        if (replace) &#123;</span><br><span class="line"> </span><br><span class="line">            method_setImplementation((Method)m, imp);</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125; else &#123;</span><br><span class="line"> </span><br><span class="line">        // fixme could be faster</span><br><span class="line"> </span><br><span class="line">        old_method_list *mlist =</span><br><span class="line"> </span><br><span class="line">            (old_method_list *)calloc(sizeof(old_method_list), 1);</span><br><span class="line"> </span><br><span class="line">        mlist-&gt;obsolete = fixed_up_method_list;</span><br><span class="line"> </span><br><span class="line">        mlist-&gt;method_count = 1;</span><br><span class="line"> </span><br><span class="line">        mlist-&gt;method_list[0].method_name = name;</span><br><span class="line"> </span><br><span class="line">        mlist-&gt;method_list[0].method_types = strdup(types);</span><br><span class="line"> </span><br><span class="line">        mlist-&gt;method_list[0].method_imp = imp;</span><br><span class="line"> </span><br><span class="line">         </span><br><span class="line"> </span><br><span class="line">        _objc_insertMethods(cls, mlist, nil);</span><br><span class="line"> </span><br><span class="line">        if (!(cls-&gt;info &amp; CLS_CONSTRUCTING)) &#123;</span><br><span class="line"> </span><br><span class="line">            flush_caches(cls, NO);</span><br><span class="line"> </span><br><span class="line">        &#125; else &#123;</span><br><span class="line"> </span><br><span class="line">            // in-construction class has no subclasses</span><br><span class="line"> </span><br><span class="line">            flush_cache(cls);</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        result = nil;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return result;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于当前类对象中存在这个方法的时候(包括父类的)，什么都不会处理返回NO。如果不存在那么会添加一个,并且返回YES。</p><p>接着是class_replaceMethod</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls) return nil;</span><br><span class="line">    return _class_addMethod(cls, name, imp, types, YES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法和class_addMethod的区别是，如果发现已经存在sel对应的Method，前者会直接通过新的imp覆盖原来的method，后者则不会做任何处理。</p><p>最后method_exchangeImplementations交换两个method的实现。</p><p>现在分析一下文章开头那段代码，当当前类本身没有实现original_selector方法的时候，但是它的基类实现了。那么最后交换的就是基类中的original_selector方法，这将会影响基类和其他继承子类的行为。现在通过一个简单的demo来验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">@interface People : NSObject</span><br><span class="line"> </span><br><span class="line">- (void)talk;</span><br><span class="line"> </span><br><span class="line">@end</span><br><span class="line">@implementation People</span><br><span class="line"> </span><br><span class="line">- (void)talk</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    NSLog(@&quot;%@&quot;, self.class);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">@interface Student : People</span><br><span class="line">  </span><br><span class="line">@end</span><br><span class="line">  </span><br><span class="line">@implemention Student</span><br><span class="line">  </span><br><span class="line">@end</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">@interface Teacher : People</span><br><span class="line"> </span><br><span class="line">@end</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">@implemention Teacher</span><br><span class="line"> </span><br><span class="line">@end</span><br><span class="line">@interface Student (Tracking)</span><br><span class="line"> </span><br><span class="line">@end</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">@implemention Student</span><br><span class="line"> </span><br><span class="line">+ (void)load</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line"> </span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line"> </span><br><span class="line">        SEL originalSelector = NSSelectorFromString(@&quot;talk&quot;);</span><br><span class="line"> </span><br><span class="line">        SEL swizzleSelector = NSSelectorFromString(@&quot;swizzle_talk&quot;);</span><br><span class="line"> </span><br><span class="line">        Method originalMethod = class_getInstanceMethod(self.class, </span><br><span class="line">            originalSelector);</span><br><span class="line"> </span><br><span class="line">        Method swizzleMethod = class_getInstanceMethod(self.class, </span><br><span class="line">            swizzleSelector);</span><br><span class="line">         </span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzleMethod);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">- (void)swizzle_talk</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    NSLog(@&quot;zwizzle_talk: %@&quot;, self.class);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@end</span><br><span class="line">  </span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line"> </span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    Teacher *t = [[Teacher alloc] init];</span><br><span class="line"> </span><br><span class="line">    [t talk];</span><br><span class="line"> </span><br><span class="line">    Student *stu = [[Student alloc] init];</span><br><span class="line"> </span><br><span class="line">    [stu talk];</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>输出是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">20:15:35.432 abc[87901:2148310] zwizzle_talk: Teacher</span><br><span class="line"> </span><br><span class="line">20:15:35.433 abc[87901:2148310] zwizzle_talk: Student</span><br></pre></td></tr></table></figure><p>说明 Teacher类也收到了student swizzle的影响。</p><p>Student(Tracking)换一种写法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load</span><br><span class="line">&#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line"> </span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line"> </span><br><span class="line">        SEL originalSelector = NSSelectorFromString(@&quot;talk&quot;);</span><br><span class="line"> </span><br><span class="line">        SEL swizzleSelector = NSSelectorFromString(@&quot;swizzle_talk&quot;);</span><br><span class="line"> </span><br><span class="line">        Method originalMethod = class_getInstanceMethod(self.class, </span><br><span class="line">            originalSelector);</span><br><span class="line"> </span><br><span class="line">        Method swizzleMethod = class_getInstanceMethod(self.class, </span><br><span class="line">            swizzleSelector);</span><br><span class="line"> </span><br><span class="line">        BOOL addMethod = class_addMethod(self.class, originalSelector, </span><br><span class="line">            method_getImplementation(swizzleMethod), method_getTypeEncoding(</span><br><span class="line">                swizzleMethod));</span><br><span class="line"> </span><br><span class="line">        if (addMethod) &#123;</span><br><span class="line">            class_replaceMethod(self.class, swizzleSelector, </span><br><span class="line">                method_getImplementation(originalMethod), </span><br><span class="line">                method_getTypeEncoding(originalMethod));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzleMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">20:19:50.683 abc[87966:2152486] Teacher</span><br><span class="line"> </span><br><span class="line">20:19:50.684 abc[87966:2152486] zwizzle_talk: Student</span><br></pre></td></tr></table></figure><p>可以看到，Teacher类并没有收到影响，虽然是基类中实现了talk方法，但是通过class_addMethod给当前类Student动态增加了talk的实现，然后进行交换。没有影响到原来People类中的talk方法。</p><p>可以看出，第二种方法实现起来更好，影响范围更小一些。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通常通过method swizzle可以交换两个方法的实现(不限于同一个类型)，先看一段代码：&lt;/p&gt;
&lt;p&gt;People类&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp
      
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS定位库-INTULocationRequest</title>
    <link href="http://yoursite.com/2017/05/19/iOS%E5%AE%9A%E4%BD%8D%E5%BA%93-INTULocationRequest/"/>
    <id>http://yoursite.com/2017/05/19/iOS定位库-INTULocationRequest/</id>
    <published>2017-05-18T16:00:00.000Z</published>
    <updated>2018-08-06T04:03:34.826Z</updated>
    
    <content type="html"><![CDATA[<p>对象关系</p><p><img src="http://7xqgnx.com1.z0.glb.clouddn.com/%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB.png" alt="对象关系.png"></p><p>对象各自的功能</p><p><img src="http://7xqgnx.com1.z0.glb.clouddn.com/%E5%8A%9F%E8%83%BD%E5%92%8C%E6%A8%A1%E5%9D%97%E5%88%92%E5%88%86.png" alt="模块和功能.png"></p><p>业务流程</p><p><img src="http://7xqgnx.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E6%B5%81.png" alt="业务流程"></p><p>源码分析：</p><p>INTULocationRequestDefines.h</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">//这个文件主要定义库使用的常量，宏和枚举类型</span><br><span class="line">  </span><br><span class="line">//static 定义作用域， 在引入头文件后可用</span><br><span class="line">//命名规则： k + 库的前缀 + 名称  解决duplicate symbols</span><br><span class="line">//定位精确度纬度：距离</span><br><span class="line">static const CLLocationAccuracy kINTUHorizontalAccuracyThresholdCity =</span><br><span class="line">5000.0;  // in meters</span><br><span class="line"> </span><br><span class="line">static const CLLocationAccuracy kINTUHorizontalAccuracyThresholdNeighborhood = </span><br><span class="line">1000.0;  // in meters</span><br><span class="line"> </span><br><span class="line">static const CLLocationAccuracy kINTUHorizontalAccuracyThresholdBlock =</span><br><span class="line">         100.0;  // in meters</span><br><span class="line"> </span><br><span class="line">static const CLLocationAccuracy kINTUHorizontalAccuracyThresholdHouse =</span><br><span class="line">          15.0;  // in meters</span><br><span class="line"> </span><br><span class="line">static const CLLocationAccuracy kINTUHorizontalAccuracyThresholdRoom =</span><br><span class="line">            5.0;  // in meters</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//定位精确度纬度：定位频率</span><br><span class="line">static const NSTimeInterval kINTUUpdateTimeStaleThresholdCity = </span><br><span class="line">600.0;  // in seconds</span><br><span class="line"> </span><br><span class="line">static const NSTimeInterval kINTUUpdateTimeStaleThresholdNeighborhood = </span><br><span class="line">300.0;  // in seconds</span><br><span class="line"> </span><br><span class="line">static const NSTimeInterval kINTUUpdateTimeStaleThresholdBlock = </span><br><span class="line">60.0;  // in seconds</span><br><span class="line"> </span><br><span class="line">static const NSTimeInterval kINTUUpdateTimeStaleThresholdHouse = </span><br><span class="line">15.0;  // in seconds</span><br><span class="line"> </span><br><span class="line">static const NSTimeInterval kINTUUpdateTimeStaleThresholdRoom = </span><br><span class="line">5.0;  // in seconds</span><br><span class="line">  </span><br><span class="line">//枚举命名规则： 库前缀 + 枚举名称</span><br><span class="line">//app定位服务状态</span><br><span class="line">typedef NS_ENUM(NSInteger, INTULocationServicesState) &#123;</span><br><span class="line">  </span><br><span class="line">//枚举项命名规则：库前缀 + 枚举名称 + 项名称</span><br><span class="line">    INTULocationServicesStateAvailable,</span><br><span class="line"> </span><br><span class="line">    INTULocationServicesStateNotDetermined,</span><br><span class="line"> </span><br><span class="line">    INTULocationServicesStateDenied,</span><br><span class="line">//受限的，不太清楚什么意思</span><br><span class="line">    INTULocationServicesStateRestricted,</span><br><span class="line"> </span><br><span class="line">    INTULocationServicesStateDisabled</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line">//每一次定位请求的唯一Id ，可以通过它操作某次定位请求，比如停止请求操作</span><br><span class="line">//主要是可以使用INTULocationRequestID来描述它的意义，可读性比NSInteger高很多，</span><br><span class="line">//比如方法返回就可以写成INTULocationRequestID而不是NSInteger</span><br><span class="line">typedef NSInteger INTULocationRequestID;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//定位精确度枚举类型</span><br><span class="line">typedef NS_ENUM(NSInteger, INTULocationAccuracy) &#123;</span><br><span class="line"> </span><br><span class="line">    INTULocationAccuracyNone = 0,</span><br><span class="line"> </span><br><span class="line">    INTULocationAccuracyCity,</span><br><span class="line"> </span><br><span class="line">    INTULocationAccuracyNeighborhood,</span><br><span class="line"> </span><br><span class="line">    INTULocationAccuracyBlock,</span><br><span class="line"> </span><br><span class="line">    INTULocationAccuracyHouse,</span><br><span class="line"> </span><br><span class="line">    INTULocationAccuracyRoom,</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//每次定位请求完成之后，回调参数，用于描述定位请求的状态，是成功还是失败或者超时等</span><br><span class="line">typedef NS_ENUM(NSInteger, INTULocationStatus) &#123;</span><br><span class="line"> </span><br><span class="line">    INTULocationStatusSuccess = 0,</span><br><span class="line"> </span><br><span class="line">    INTULocationStatusTimedOut,</span><br><span class="line"> </span><br><span class="line">    INTULocationStatusServicesNotDetermined,</span><br><span class="line"> </span><br><span class="line">    INTULocationStatusServicesDenied,</span><br><span class="line"> </span><br><span class="line">    INTULocationStatusServicesRestricted,</span><br><span class="line"> </span><br><span class="line">    INTULocationStatusServicesDisabled,</span><br><span class="line"> </span><br><span class="line">    INTULocationStatusError</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//定位结果回调</span><br><span class="line">typedef void(^INTULocationRequestBlock)(CLLocation *currentLocation, </span><br><span class="line">    INTULocationAccuracy achievedAccuracy, INTULocationStatus status);</span><br></pre></td></tr></table></figure><p>INTULocationManager.m</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br></pre></td><td class="code"><pre><span class="line">@interface INTULocationManager () &lt;CLLocationManagerDelegate, INTULocationRequestDelegate&gt;</span><br><span class="line"> </span><br><span class="line">@property (nonatomic, strong) CLLocationManager *locationManager;</span><br><span class="line">@property (nonatomic, strong) CLLocation *currentLocation;</span><br><span class="line">@property (nonatomic, assign) BOOL isMonitoringSignificantLocationChanges;</span><br><span class="line">@property (nonatomic, assign) BOOL isUpdatingLocation;</span><br><span class="line">@property (nonatomic, assign) BOOL updateFailed;</span><br><span class="line">@property (nonatomic, strong) __INTU_GENERICS(NSArray, INTULocationRequest *) *</span><br><span class="line">locationRequests;</span><br><span class="line"> </span><br><span class="line">@end</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">@implementation INTULocationManager</span><br><span class="line"> </span><br><span class="line">static id _sharedInstance;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">+ (INTULocationServicesState)locationServicesState</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    if ([CLLocationManager locationServicesEnabled] == NO) &#123;</span><br><span class="line"> </span><br><span class="line">        return INTULocationServicesStateDisabled;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    else if ([CLLocationManager authorizationStatus] == </span><br><span class="line">        kCLAuthorizationStatusNotDetermined) &#123;</span><br><span class="line"> </span><br><span class="line">        return INTULocationServicesStateNotDetermined;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    else if ([CLLocationManager authorizationStatus] == </span><br><span class="line">        kCLAuthorizationStatusDenied) &#123;</span><br><span class="line"> </span><br><span class="line">        return INTULocationServicesStateDenied;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    else if ([CLLocationManager authorizationStatus] == </span><br><span class="line">        kCLAuthorizationStatusRestricted) &#123;</span><br><span class="line"> </span><br><span class="line">        return INTULocationServicesStateRestricted;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return INTULocationServicesStateAvailable;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">+ (instancetype)sharedInstance</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    static dispatch_once_t _onceToken;</span><br><span class="line"> </span><br><span class="line">    dispatch_once(&amp;_onceToken, ^&#123;</span><br><span class="line"> </span><br><span class="line">        _sharedInstance = [[self alloc] init];</span><br><span class="line"> </span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    return _sharedInstance;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">    NSAssert(_sharedInstance == nil, @&quot;Only one instance of </span><br><span class="line">    INTULocationManager should be created. Use +[INTULocationManager </span><br><span class="line">    sharedInstance] instead.&quot;);</span><br><span class="line"> </span><br><span class="line">    self = [super init];</span><br><span class="line"> </span><br><span class="line">    if (self) &#123;</span><br><span class="line"> </span><br><span class="line">        _locationManager = [[CLLocationManager alloc] init];</span><br><span class="line"> </span><br><span class="line">        _locationManager.delegate = self;</span><br><span class="line">         </span><br><span class="line"> </span><br><span class="line">#ifdef __IPHONE_8_4</span><br><span class="line"> </span><br><span class="line">#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt; __IPHONE_8_4</span><br><span class="line"> </span><br><span class="line">        /* iOS 9 requires setting allowsBackgroundLocationUpdates to YES in </span><br><span class="line">        order to receive background location updates.</span><br><span class="line"> </span><br><span class="line">         We only set it to YES if the location background mode is enabled for </span><br><span class="line">         this app, as the documentation suggests it is a</span><br><span class="line"> </span><br><span class="line">         fatal programmer error otherwise. */</span><br><span class="line"> </span><br><span class="line">        NSArray *backgroundModes = [[NSBundle mainBundle] </span><br><span class="line">        objectForInfoDictionaryKey:@&quot;UIBackgroundModes&quot;];</span><br><span class="line"> </span><br><span class="line">        if ([backgroundModes containsObject:@&quot;location&quot;]) &#123;</span><br><span class="line"> </span><br><span class="line">            if ([_locationManager respondsToSelector:@selector(</span><br><span class="line">                setAllowsBackgroundLocationUpdates:)]) &#123;</span><br><span class="line"> </span><br><span class="line">                [_locationManager setAllowsBackgroundLocationUpdates:YES];</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">#endif /* __IPHONE_OS_VERSION_MAX_ALLOWED &gt; __IPHONE_8_4 */</span><br><span class="line"> </span><br><span class="line">#endif /* __IPHONE_8_4 */</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        _locationRequests = @[];</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">- (INTULocationRequestID)requestLocationWithDesiredAccuracy:(</span><br><span class="line">    INTULocationAccuracy)desiredAccuracy</span><br><span class="line"> </span><br><span class="line">                                                    timeout:(NSTimeInterval)</span><br><span class="line">                                                    timeout</span><br><span class="line"> </span><br><span class="line">                                                      block:(</span><br><span class="line">                                                        INTULocationRequestBloc</span><br><span class="line">                                                        k)block</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    return [self requestLocationWithDesiredAccuracy:desiredAccuracy</span><br><span class="line"> </span><br><span class="line">                                            timeout:timeout</span><br><span class="line"> </span><br><span class="line">                               delayUntilAuthorized:NO</span><br><span class="line"> </span><br><span class="line">                                              block:block];</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (INTULocationRequestID)requestLocationWithDesiredAccuracy:(</span><br><span class="line">    INTULocationAccuracy)desiredAccuracy</span><br><span class="line"> </span><br><span class="line">                                                    timeout:(NSTimeInterval)</span><br><span class="line">                                                    timeout</span><br><span class="line"> </span><br><span class="line">                                       delayUntilAuthorized:(BOOL)</span><br><span class="line">                                       delayUntilAuthorized</span><br><span class="line"> </span><br><span class="line">                                                      block:(INTULocationRequestBlock)</span><br><span class="line">                                                      block</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    if (desiredAccuracy == INTULocationAccuracyNone) &#123;</span><br><span class="line"> </span><br><span class="line">        NSAssert(desiredAccuracy != INTULocationAccuracyNone, @&quot;</span><br><span class="line">        INTULocationAccuracyNone is not a valid desired accuracy.&quot;);</span><br><span class="line"> </span><br><span class="line">        desiredAccuracy = INTULocationAccuracyCity; // default to the lowest valid desired accuracy</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    INTULocationRequest *locationRequest = [[INTULocationRequest alloc] </span><br><span class="line">    initWithType:INTULocationRequestTypeSingle];</span><br><span class="line"> </span><br><span class="line">    locationRequest.delegate = self;</span><br><span class="line"> </span><br><span class="line">    locationRequest.desiredAccuracy = desiredAccuracy;</span><br><span class="line"> </span><br><span class="line">    locationRequest.timeout = timeout;</span><br><span class="line"> </span><br><span class="line">    locationRequest.block = block;</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    BOOL deferTimeout = delayUntilAuthorized &amp;&amp; ([CLLocationManager </span><br><span class="line">        authorizationStatus] == kCLAuthorizationStatusNotDetermined);</span><br><span class="line"> </span><br><span class="line">    if (!deferTimeout) &#123;</span><br><span class="line"> </span><br><span class="line">        [locationRequest startTimeoutTimerIfNeeded];</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    [self addLocationRequest:locationRequest];</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    return locationRequest.requestID;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (INTULocationRequestID)subscribeToLocationUpdatesWithBlock:(</span><br><span class="line">    INTULocationRequestBlock)block</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    return [self subscribeToLocationUpdatesWithDesiredAccuracy:</span><br><span class="line">    INTULocationAccuracyRoom</span><br><span class="line"> </span><br><span class="line">                                                         block:block];</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (INTULocationRequestID)subscribeToLocationUpdatesWithDesiredAccuracy:(</span><br><span class="line">    INTULocationAccuracy)desiredAccuracy</span><br><span class="line"> </span><br><span class="line">                                                                 block:(INTULoc</span><br><span class="line">                                                                    ationReques</span><br><span class="line">                                                                    tBlock)</span><br><span class="line">                                                                    block</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    INTULocationRequest *locationRequest = [[INTULocationRequest alloc] </span><br><span class="line">    initWithType:INTULocationRequestTypeSubscription];</span><br><span class="line"> </span><br><span class="line">    locationRequest.desiredAccuracy = desiredAccuracy;</span><br><span class="line"> </span><br><span class="line">    locationRequest.block = block;</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    [self addLocationRequest:locationRequest];</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    return locationRequest.requestID;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (INTULocationRequestID)subscribeToSignificantLocationChangesWithBlock:(</span><br><span class="line">    INTULocationRequestBlock)block</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    INTULocationRequest *locationRequest = [[INTULocationRequest alloc] </span><br><span class="line">    initWithType:INTULocationRequestTypeSignificantChanges];</span><br><span class="line"> </span><br><span class="line">    locationRequest.block = block;</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    [self addLocationRequest:locationRequest];</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    return locationRequest.requestID;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)forceCompleteLocationRequest:(INTULocationRequestID)requestID</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    for (INTULocationRequest *locationRequest in self.locationRequests) &#123;</span><br><span class="line"> </span><br><span class="line">        if (locationRequest.requestID == requestID) &#123;</span><br><span class="line"> </span><br><span class="line">            if (locationRequest.isRecurring) &#123;</span><br><span class="line"> </span><br><span class="line">                [self cancelLocationRequest:requestID];</span><br><span class="line"> </span><br><span class="line">            &#125; else &#123;</span><br><span class="line"> </span><br><span class="line">                [locationRequest forceTimeout];</span><br><span class="line"> </span><br><span class="line">                [self completeLocationRequest:locationRequest];</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            break;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">- (void)cancelLocationRequest:(INTULocationRequestID)requestID</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line">    for (INTULocationRequest *locationRequest in self.locationRequests) &#123;</span><br><span class="line"> </span><br><span class="line">        if (locationRequest.requestID == requestID) &#123;</span><br><span class="line"> </span><br><span class="line">            [locationRequest cancel];</span><br><span class="line"> </span><br><span class="line">            INTULMLog(@&quot;Location Request canceled with ID: %ld&quot;, (long)</span><br><span class="line">            locationRequest.requestID);</span><br><span class="line"> </span><br><span class="line">            [self removeLocationRequest:locationRequest];</span><br><span class="line"> </span><br><span class="line">            break;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)addLocationRequest:(INTULocationRequest *)locationRequest</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    INTULocationServicesState locationServicesState = [INTULocationManager</span><br><span class="line">     locationServicesState];</span><br><span class="line"> </span><br><span class="line">    if (locationServicesState == INTULocationServicesStateDisabled ||</span><br><span class="line"> </span><br><span class="line">        locationServicesState == INTULocationServicesStateDenied ||</span><br><span class="line"> </span><br><span class="line">        locationServicesState == INTULocationServicesStateRestricted) &#123;</span><br><span class="line"> </span><br><span class="line">        // No need to add this location request, because location services are </span><br><span class="line">        //turned off device-wide, or the user has denied this app permissions </span><br><span class="line">        //to use them</span><br><span class="line"> </span><br><span class="line">        [self completeLocationRequest:locationRequest];</span><br><span class="line"> </span><br><span class="line">        return;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    switch (locationRequest.type) &#123;</span><br><span class="line"> </span><br><span class="line">        case INTULocationRequestTypeSingle:</span><br><span class="line"> </span><br><span class="line">        case INTULocationRequestTypeSubscription:</span><br><span class="line"> </span><br><span class="line">        &#123;</span><br><span class="line"> </span><br><span class="line">            INTULocationAccuracy maximumDesiredAccuracy = </span><br><span class="line">            INTULocationAccuracyNone;</span><br><span class="line"> </span><br><span class="line">            for (INTULocationRequest *locationRequest in [self </span><br><span class="line">                activeLocationRequestsExcludingType:</span><br><span class="line">                INTULocationRequestTypeSignificantChanges]) &#123;</span><br><span class="line"> </span><br><span class="line">                if (locationRequest.desiredAccuracy &gt; maximumDesiredAccuracy) &#123;</span><br><span class="line"> </span><br><span class="line">                    maximumDesiredAccuracy = locationRequest.desiredAccuracy;</span><br><span class="line"> </span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            maximumDesiredAccuracy = MAX(locationRequest.desiredAccuracy, </span><br><span class="line">                maximumDesiredAccuracy);</span><br><span class="line"> </span><br><span class="line">            [self updateWithMaximumDesiredAccuracy:maximumDesiredAccuracy];</span><br><span class="line">            </span><br><span class="line">            [self startUpdatingLocationIfNeeded];</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">            break;</span><br><span class="line"> </span><br><span class="line">        case INTULocationRequestTypeSignificantChanges:</span><br><span class="line"> </span><br><span class="line">            [self startMonitoringSignificantLocationChangesIfNeeded];</span><br><span class="line"> </span><br><span class="line">            break;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    __INTU_GENERICS(NSMutableArray, INTULocationRequest *) *</span><br><span class="line">    newLocationRequests = [NSMutableArray arrayWithArray:self.locationRequests]</span><br><span class="line">    ;</span><br><span class="line"> </span><br><span class="line">    [newLocationRequests addObject:locationRequest];</span><br><span class="line"> </span><br><span class="line">    self.locationRequests = newLocationRequests;</span><br><span class="line"> </span><br><span class="line">    INTULMLog(@&quot;Location Request added with ID: %ld&quot;, (long)locationRequest.</span><br><span class="line">    requestID);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)removeLocationRequest:(INTULocationRequest *)locationRequest</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    __INTU_GENERICS(NSMutableArray, INTULocationRequest *) *</span><br><span class="line">    newLocationRequests = [NSMutableArray arrayWithArray:self.locationRequests]</span><br><span class="line">    ;</span><br><span class="line"> </span><br><span class="line">    [newLocationRequests removeObject:locationRequest];</span><br><span class="line"> </span><br><span class="line">    self.locationRequests = newLocationRequests;</span><br><span class="line"> </span><br><span class="line">    switch (locationRequest.type) &#123;</span><br><span class="line"> </span><br><span class="line">        case INTULocationRequestTypeSingle:</span><br><span class="line"> </span><br><span class="line">        case INTULocationRequestTypeSubscription:</span><br><span class="line"> </span><br><span class="line">        &#123;</span><br><span class="line"> </span><br><span class="line">            INTULocationAccuracy maximumDesiredAccuracy = INTULocationAccuracyNone;</span><br><span class="line"> </span><br><span class="line">            for (INTULocationRequest *locationRequest in [self </span><br><span class="line">                activeLocationRequestsExcludingType:</span><br><span class="line">                INTULocationRequestTypeSignificantChanges]) &#123;</span><br><span class="line"> </span><br><span class="line">                if (locationRequest.desiredAccuracy &gt; maximumDesiredAccuracy) &#123;</span><br><span class="line"> </span><br><span class="line">                    maximumDesiredAccuracy = locationRequest.desiredAccuracy;</span><br><span class="line"> </span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            [self updateWithMaximumDesiredAccuracy:maximumDesiredAccuracy];</span><br><span class="line"> </span><br><span class="line">            [self stopUpdatingLocationIfPossible];</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">            break;</span><br><span class="line"> </span><br><span class="line">        case INTULocationRequestTypeSignificantChanges:</span><br><span class="line"> </span><br><span class="line">            [self stopMonitoringSignificantLocationChangesIfPossible];</span><br><span class="line"> </span><br><span class="line">            break;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">- (CLLocation *)currentLocation</span><br><span class="line">&#123;   </span><br><span class="line">    if (_currentLocation) &#123;</span><br><span class="line"> </span><br><span class="line">        if (_currentLocation.coordinate.latitude == 0.0 &amp;&amp; _currentLocation.</span><br><span class="line">            coordinate.longitude == 0.0) &#123;</span><br><span class="line">            _currentLocation = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return _currentLocation;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)requestAuthorizationIfNeeded</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt; __IPHONE_7_1</span><br><span class="line"> </span><br><span class="line">    // As of iOS 8, apps must explicitly request location services </span><br><span class="line">    //permissions. INTULocationManager supports both levels, &quot;Always&quot; and </span><br><span class="line">    //&quot;When In Use&quot;.</span><br><span class="line"> </span><br><span class="line">    // INTULocationManager determines which level of permissions to request </span><br><span class="line">    //based on which description key is present in your app&apos;s Info.plist</span><br><span class="line"> </span><br><span class="line">    // If you provide values for both description keys, the more permissive </span><br><span class="line">    //&quot;Always&quot; level is requested.</span><br><span class="line"> </span><br><span class="line">    if (floor(NSFoundationVersionNumber) &gt; NSFoundationVersionNumber_iOS_7_1 &amp;&amp;</span><br><span class="line">     [CLLocationManager authorizationStatus] == </span><br><span class="line">     kCLAuthorizationStatusNotDetermined) &#123;</span><br><span class="line"> </span><br><span class="line">        BOOL hasAlwaysKey = [[NSBundle mainBundle] objectForInfoDictionaryKey:</span><br><span class="line">        @&quot;NSLocationAlwaysUsageDescription&quot;] != nil;</span><br><span class="line"> </span><br><span class="line">        BOOL hasWhenInUseKey = [[NSBundle mainBundle] </span><br><span class="line">        objectForInfoDictionaryKey:@&quot;NSLocationWhenInUseUsageDescription&quot;] != </span><br><span class="line">        nil;</span><br><span class="line"> </span><br><span class="line">        if (hasAlwaysKey) &#123;</span><br><span class="line"> </span><br><span class="line">            [self.locationManager requestAlwaysAuthorization];</span><br><span class="line"> </span><br><span class="line">        &#125; else if (hasWhenInUseKey) &#123;</span><br><span class="line"> </span><br><span class="line">            [self.locationManager requestWhenInUseAuthorization];</span><br><span class="line"> </span><br><span class="line">        &#125; else &#123;</span><br><span class="line"> </span><br><span class="line">            // At least one of the keys NSLocationAlwaysUsageDescription or </span><br><span class="line">            //NSLocationWhenInUseUsageDescription MUST be present in the </span><br><span class="line">            //Info.plist file to use location services on iOS 8+.</span><br><span class="line"> </span><br><span class="line">            NSAssert(hasAlwaysKey || hasWhenInUseKey, @&quot;To use location </span><br><span class="line">            services in iOS 8+, your Info.plist must provide a value for </span><br><span class="line">            either NSLocationWhenInUseUsageDescription or </span><br><span class="line">            NSLocationAlwaysUsageDescription.&quot;);</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">#endif /* __IPHONE_OS_VERSION_MAX_ALLOWED &gt; __IPHONE_7_1 */</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)updateWithMaximumDesiredAccuracy:(INTULocationAccuracy)</span><br><span class="line">maximumDesiredAccuracy</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    switch (maximumDesiredAccuracy) &#123;</span><br><span class="line"> </span><br><span class="line">        case INTULocationAccuracyNone:</span><br><span class="line"> </span><br><span class="line">            break;</span><br><span class="line"> </span><br><span class="line">        case INTULocationAccuracyCity:</span><br><span class="line"> </span><br><span class="line">            if (self.locationManager.desiredAccuracy != </span><br><span class="line">                kCLLocationAccuracyThreeKilometers) &#123;</span><br><span class="line"> </span><br><span class="line">                self.locationManager.desiredAccuracy = </span><br><span class="line">                kCLLocationAccuracyThreeKilometers;</span><br><span class="line"> </span><br><span class="line">                INTULMLog(@&quot;Changing location services accuracy level to: low (</span><br><span class="line">                    minimum).&quot;);</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            break;</span><br><span class="line"> </span><br><span class="line">        case INTULocationAccuracyNeighborhood:</span><br><span class="line"> </span><br><span class="line">            if (self.locationManager.desiredAccuracy != </span><br><span class="line">                kCLLocationAccuracyKilometer) &#123;</span><br><span class="line"> </span><br><span class="line">                self.locationManager.desiredAccuracy = </span><br><span class="line">                kCLLocationAccuracyKilometer;</span><br><span class="line"> </span><br><span class="line">                INTULMLog(@&quot;Changing location services accuracy level to: </span><br><span class="line">                medium low.&quot;);</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            break;</span><br><span class="line"> </span><br><span class="line">        case INTULocationAccuracyBlock:</span><br><span class="line"> </span><br><span class="line">            if (self.locationManager.desiredAccuracy != </span><br><span class="line">                kCLLocationAccuracyHundredMeters) &#123;</span><br><span class="line"> </span><br><span class="line">                self.locationManager.desiredAccuracy = </span><br><span class="line">                kCLLocationAccuracyHundredMeters;</span><br><span class="line"> </span><br><span class="line">                INTULMLog(@&quot;Changing location services accuracy level to: </span><br><span class="line">                medium.&quot;);</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            break;</span><br><span class="line"> </span><br><span class="line">        case INTULocationAccuracyHouse:</span><br><span class="line"> </span><br><span class="line">            if (self.locationManager.desiredAccuracy != </span><br><span class="line">                kCLLocationAccuracyNearestTenMeters) &#123;</span><br><span class="line"> </span><br><span class="line">                self.locationManager.desiredAccuracy = </span><br><span class="line">                kCLLocationAccuracyNearestTenMeters;</span><br><span class="line"> </span><br><span class="line">                INTULMLog(@&quot;Changing location services accuracy level to: </span><br><span class="line">                medium high.&quot;);</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            break;</span><br><span class="line"> </span><br><span class="line">        case INTULocationAccuracyRoom:</span><br><span class="line"> </span><br><span class="line">            if (self.locationManager.desiredAccuracy != kCLLocationAccuracyBest) &#123;</span><br><span class="line"> </span><br><span class="line">                self.locationManager.desiredAccuracy = kCLLocationAccuracyBest;</span><br><span class="line"> </span><br><span class="line">                INTULMLog(@&quot;Changing location services accuracy level to: high </span><br><span class="line">                (maximum).&quot;);</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            break;</span><br><span class="line"> </span><br><span class="line">        default:</span><br><span class="line"> </span><br><span class="line">            NSAssert(nil, @&quot;Invalid maximum desired accuracy!&quot;);</span><br><span class="line"> </span><br><span class="line">            break;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">- (void)startMonitoringSignificantLocationChangesIfNeeded</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    [self requestAuthorizationIfNeeded];</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    NSArray *locationRequests = [self activeLocationRequestsWithType:</span><br><span class="line">    INTULocationRequestTypeSignificantChanges];</span><br><span class="line"> </span><br><span class="line">    if (locationRequests.count == 0) &#123;</span><br><span class="line"> </span><br><span class="line">        [self.locationManager startMonitoringSignificantLocationChanges];</span><br><span class="line"> </span><br><span class="line">        if (self.isMonitoringSignificantLocationChanges == NO) &#123;</span><br><span class="line"> </span><br><span class="line">            INTULMLog(@&quot;Significant location change monitoring has started.&quot;)</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        self.isMonitoringSignificantLocationChanges = YES;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)startUpdatingLocationIfNeeded</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    [self requestAuthorizationIfNeeded];</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    NSArray *locationRequests = [self activeLocationRequestsExcludingType:</span><br><span class="line">    INTULocationRequestTypeSignificantChanges];</span><br><span class="line"> </span><br><span class="line">    if (locationRequests.count == 0) &#123;</span><br><span class="line"> </span><br><span class="line">        [self.locationManager startUpdatingLocation];</span><br><span class="line"> </span><br><span class="line">        if (self.isUpdatingLocation == NO) &#123;</span><br><span class="line"> </span><br><span class="line">            INTULMLog(@&quot;Location services updates have started.&quot;);</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        self.isUpdatingLocation = YES;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">- (void)stopMonitoringSignificantLocationChangesIfPossible</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    NSArray *locationRequests = [self activeLocationRequestsWithType:</span><br><span class="line">    INTULocationRequestTypeSignificantChanges];</span><br><span class="line"> </span><br><span class="line">    if (locationRequests.count == 0) &#123;</span><br><span class="line"> </span><br><span class="line">        [self.locationManager stopMonitoringSignificantLocationChanges];</span><br><span class="line"> </span><br><span class="line">        if (self.isMonitoringSignificantLocationChanges) &#123;</span><br><span class="line"> </span><br><span class="line">            INTULMLog(@&quot;Significant location change monitoring has stopped.&quot;);</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        self.isMonitoringSignificantLocationChanges = NO;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">- (void)stopUpdatingLocationIfPossible</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    NSArray *locationRequests = [self activeLocationRequestsExcludingType:</span><br><span class="line">    INTULocationRequestTypeSignificantChanges];</span><br><span class="line"> </span><br><span class="line">    if (locationRequests.count == 0) &#123;</span><br><span class="line"> </span><br><span class="line">        [self.locationManager stopUpdatingLocation];</span><br><span class="line"> </span><br><span class="line">        if (self.isUpdatingLocation) &#123;</span><br><span class="line"> </span><br><span class="line">            INTULMLog(@&quot;Location services updates have stopped.&quot;);</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        self.isUpdatingLocation = NO;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">- (void)processLocationRequests</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    CLLocation *mostRecentLocation = self.currentLocation;</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    for (INTULocationRequest *locationRequest in self.locationRequests) &#123;</span><br><span class="line"> </span><br><span class="line">        if (locationRequest.hasTimedOut) &#123;</span><br><span class="line"> </span><br><span class="line">            // Non-recurring request has timed out, complete it</span><br><span class="line"> </span><br><span class="line">            [self completeLocationRequest:locationRequest];</span><br><span class="line"> </span><br><span class="line">            continue;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">         </span><br><span class="line"> </span><br><span class="line">        if (mostRecentLocation != nil) &#123;</span><br><span class="line"> </span><br><span class="line">            if (locationRequest.isRecurring) &#123;</span><br><span class="line"> </span><br><span class="line">                // This is a subscription request, which lives indefinitely (</span><br><span class="line">                    //unless manually canceled) and receives every location </span><br><span class="line">                    //update we get</span><br><span class="line"> </span><br><span class="line">                [self processRecurringRequest:locationRequest];</span><br><span class="line"> </span><br><span class="line">                continue;</span><br><span class="line"> </span><br><span class="line">            &#125; else &#123;</span><br><span class="line"> </span><br><span class="line">                // This is a regular one-time location request</span><br><span class="line"> </span><br><span class="line">                NSTimeInterval currentLocationTimeSinceUpdate = fabs([</span><br><span class="line">                    mostRecentLocation.timestamp timeIntervalSinceNow]);</span><br><span class="line"> </span><br><span class="line">                CLLocationAccuracy currentLocationHorizontalAccuracy = </span><br><span class="line">                mostRecentLocation.horizontalAccuracy;</span><br><span class="line"> </span><br><span class="line">                NSTimeInterval staleThreshold = [locationRequest </span><br><span class="line">                updateTimeStaleThreshold];</span><br><span class="line"> </span><br><span class="line">                CLLocationAccuracy horizontalAccuracyThreshold = [</span><br><span class="line">                locationRequest horizontalAccuracyThreshold];</span><br><span class="line"> </span><br><span class="line">                if (currentLocationTimeSinceUpdate &lt;= staleThreshold &amp;&amp;</span><br><span class="line"> </span><br><span class="line">                    currentLocationHorizontalAccuracy &lt;= </span><br><span class="line">                    horizontalAccuracyThreshold) &#123;</span><br><span class="line"> </span><br><span class="line">                    // The request&apos;s desired accuracy has been reached, </span><br><span class="line">                    //complete it</span><br><span class="line"> </span><br><span class="line">                    [self completeLocationRequest:locationRequest];</span><br><span class="line"> </span><br><span class="line">                    continue;</span><br><span class="line"> </span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">- (void)completeAllLocationRequests</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    __INTU_GENERICS(NSArray, INTULocationRequest *) *locationRequests = [self.</span><br><span class="line">    locationRequests copy];</span><br><span class="line"> </span><br><span class="line">    for (INTULocationRequest *locationRequest in locationRequests) &#123;</span><br><span class="line"> </span><br><span class="line">        [self completeLocationRequest:locationRequest];</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    INTULMLog(@&quot;Finished completing all location requests.&quot;);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)completeLocationRequest:(INTULocationRequest *)locationRequest</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    if (locationRequest == nil) &#123;</span><br><span class="line"> </span><br><span class="line">        return;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    [locationRequest complete];</span><br><span class="line"> </span><br><span class="line">    [self removeLocationRequest:locationRequest];</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    INTULocationStatus status = [self statusForLocationRequest:locationRequest]</span><br><span class="line">    ;</span><br><span class="line"> </span><br><span class="line">    CLLocation *currentLocation = self.currentLocation;</span><br><span class="line"> </span><br><span class="line">    INTULocationAccuracy achievedAccuracy = [self achievedAccuracyForLocation:</span><br><span class="line">    currentLocation];</span><br><span class="line"> </span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line"> </span><br><span class="line">        if (locationRequest.block) &#123;</span><br><span class="line"> </span><br><span class="line">            locationRequest.block(currentLocation, achievedAccuracy, status);</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    INTULMLog(@&quot;Location Request completed with ID: %ld, currentLocation: %@, </span><br><span class="line">    achievedAccuracy: %lu, status: %lu&quot;, (long)locationRequest.requestID, </span><br><span class="line">    currentLocation, (unsigned long) achievedAccuracy, (unsigned long)status);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)processRecurringRequest:(INTULocationRequest *)locationRequest</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    NSAssert(locationRequest.isRecurring, @&quot;This method should only be called </span><br><span class="line">    for recurring location requests.&quot;);</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    INTULocationStatus status = [self statusForLocationRequest:locationRequest];</span><br><span class="line"> </span><br><span class="line">    CLLocation *currentLocation = self.currentLocation;</span><br><span class="line"> </span><br><span class="line">    INTULocationAccuracy achievedAccuracy = [self achievedAccuracyForLocation:</span><br><span class="line">    currentLocation];</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    if (locationRequest.block) &#123;</span><br><span class="line"> </span><br><span class="line">        locationRequest.block(currentLocation, achievedAccuracy, status);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">- (NSArray *)activeLocationRequestsWithType:(INTULocationRequestType)</span><br><span class="line">locationRequestType</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    return [self.locationRequests filteredArrayUsingPredicate:[NSPredicate </span><br><span class="line">    predicateWithBlock:^BOOL(INTULocationRequest *evaluatedObject, NSDictionary</span><br><span class="line">     *bindings) &#123;</span><br><span class="line"> </span><br><span class="line">        return evaluatedObject.type == locationRequestType;</span><br><span class="line"> </span><br><span class="line">    &#125;]];</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">- (NSArray *)activeLocationRequestsExcludingType:(INTULocationRequestType)</span><br><span class="line">locationRequestType</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    return [self.locationRequests filteredArrayUsingPredicate:[NSPredicate </span><br><span class="line">    predicateWithBlock:^BOOL(INTULocationRequest *evaluatedObject, NSDictionary</span><br><span class="line">     *bindings) &#123;</span><br><span class="line"> </span><br><span class="line">        return evaluatedObject.type != locationRequestType;</span><br><span class="line"> </span><br><span class="line">    &#125;]];</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">- (INTULocationStatus)statusForLocationRequest:(INTULocationRequest *)</span><br><span class="line">locationRequest</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    INTULocationServicesState locationServicesState = [INTULocationManager </span><br><span class="line">    locationServicesState];</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    if (locationServicesState == INTULocationServicesStateDisabled) &#123;</span><br><span class="line"> </span><br><span class="line">        return INTULocationStatusServicesDisabled;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    else if (locationServicesState == INTULocationServicesStateNotDetermined) &#123;</span><br><span class="line"> </span><br><span class="line">        return INTULocationStatusServicesNotDetermined;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    else if (locationServicesState == INTULocationServicesStateDenied) &#123;</span><br><span class="line"> </span><br><span class="line">        return INTULocationStatusServicesDenied;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    else if (locationServicesState == INTULocationServicesStateRestricted) &#123;</span><br><span class="line"> </span><br><span class="line">        return INTULocationStatusServicesRestricted;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    else if (self.updateFailed) &#123;</span><br><span class="line"> </span><br><span class="line">        return INTULocationStatusError;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    else if (locationRequest.hasTimedOut) &#123;</span><br><span class="line"> </span><br><span class="line">        return INTULocationStatusTimedOut;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    return INTULocationStatusSuccess;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">- (INTULocationAccuracy)achievedAccuracyForLocation:(CLLocation *)location</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    if (!location) &#123;</span><br><span class="line"> </span><br><span class="line">        return INTULocationAccuracyNone;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    NSTimeInterval timeSinceUpdate = fabs([location.timestamp </span><br><span class="line">        timeIntervalSinceNow]);</span><br><span class="line"> </span><br><span class="line">    CLLocationAccuracy horizontalAccuracy = location.horizontalAccuracy;</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    if (horizontalAccuracy &lt;= kINTUHorizontalAccuracyThresholdRoom &amp;&amp;</span><br><span class="line"> </span><br><span class="line">        timeSinceUpdate &lt;= kINTUUpdateTimeStaleThresholdRoom) &#123;</span><br><span class="line"> </span><br><span class="line">        return INTULocationAccuracyRoom;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    else if (horizontalAccuracy &lt;= kINTUHorizontalAccuracyThresholdHouse &amp;&amp;</span><br><span class="line"> </span><br><span class="line">             timeSinceUpdate &lt;= kINTUUpdateTimeStaleThresholdHouse) &#123;</span><br><span class="line"> </span><br><span class="line">        return INTULocationAccuracyHouse;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    else if (horizontalAccuracy &lt;= kINTUHorizontalAccuracyThresholdBlock &amp;&amp;</span><br><span class="line"> </span><br><span class="line">             timeSinceUpdate &lt;= kINTUUpdateTimeStaleThresholdBlock) &#123;</span><br><span class="line"> </span><br><span class="line">        return INTULocationAccuracyBlock;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    else if (horizontalAccuracy &lt;= kINTUHorizontalAccuracyThresholdNeighborhood</span><br><span class="line">     &amp;&amp;</span><br><span class="line"> </span><br><span class="line">             timeSinceUpdate &lt;= kINTUUpdateTimeStaleThresholdNeighborhood) &#123;</span><br><span class="line"> </span><br><span class="line">        return INTULocationAccuracyNeighborhood;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    else if (horizontalAccuracy &lt;= kINTUHorizontalAccuracyThresholdCity &amp;&amp;</span><br><span class="line"> </span><br><span class="line">             timeSinceUpdate &lt;= kINTUUpdateTimeStaleThresholdCity) &#123;</span><br><span class="line"> </span><br><span class="line">        return INTULocationAccuracyCity;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    else &#123;</span><br><span class="line"> </span><br><span class="line">        return INTULocationAccuracyNone;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#pragma mark INTULocationRequestDelegate method</span><br><span class="line"> </span><br><span class="line">- (void)locationRequestDidTimeout:(INTULocationRequest *)locationRequest</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    for (INTULocationRequest *activeLocationRequest in self.locationRequests) &#123;</span><br><span class="line"> </span><br><span class="line">        if (activeLocationRequest.requestID == locationRequest.requestID) &#123;</span><br><span class="line"> </span><br><span class="line">            [self completeLocationRequest:locationRequest];</span><br><span class="line"> </span><br><span class="line">            break;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#pragma mark CLLocationManagerDelegate methods</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">- (void)locationManager:(CLLocationManager *)manager didUpdateLocations:(</span><br><span class="line">    NSArray *)locations</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line">    self.updateFailed = NO;</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    CLLocation *mostRecentLocation = [locations lastObject];</span><br><span class="line"> </span><br><span class="line">    self.currentLocation = mostRecentLocation;</span><br><span class="line"> </span><br><span class="line">    [self processLocationRequests];</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">- (void)locationManager:(CLLocationManager *)manager didFailWithError:(NSError </span><br><span class="line">    *)error</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    INTULMLog(@&quot;Location services error: %@&quot;, [error localizedDescription]);</span><br><span class="line"> </span><br><span class="line">    self.updateFailed = YES;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    for (INTULocationRequest *locationRequest in self.locationRequests) &#123;</span><br><span class="line"> </span><br><span class="line">        if (locationRequest.isRecurring) &#123;</span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line">            [self processRecurringRequest:locationRequest];</span><br><span class="line"> </span><br><span class="line">        &#125; else &#123;</span><br><span class="line"> </span><br><span class="line">   </span><br><span class="line"> </span><br><span class="line">            [self completeLocationRequest:locationRequest];</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">- (void)locationManager:(CLLocationManager *)manager </span><br><span class="line">didChangeAuthorizationStatus:(CLAuthorizationStatus)status</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    if (status == kCLAuthorizationStatusDenied || status == </span><br><span class="line">        kCLAuthorizationStatusRestricted) &#123;</span><br><span class="line"> </span><br><span class="line">        [self completeAllLocationRequests];</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//__IPHONE_OS_VERSION_MAX_ALLOWED app能运行的最高系统版本</span><br><span class="line">#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt; __IPHONE_7_1</span><br><span class="line"> </span><br><span class="line">    else if (status == kCLAuthorizationStatusAuthorizedAlways || status == </span><br><span class="line">        kCLAuthorizationStatusAuthorizedWhenInUse) &#123;</span><br><span class="line"> </span><br><span class="line">#else</span><br><span class="line"> </span><br><span class="line">    else if (status == kCLAuthorizationStatusAuthorized) &#123;</span><br><span class="line"> </span><br><span class="line">#endif /* __IPHONE_OS_VERSION_MAX_ALLOWED &gt; __IPHONE_7_1 */</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        for (INTULocationRequest *locationRequest in self.locationRequests) &#123;</span><br><span class="line"> </span><br><span class="line">            [locationRequest startTimeoutTimerIfNeeded];</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对象关系&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xqgnx.com1.z0.glb.clouddn.com/%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB.png&quot; alt=&quot;对象关系.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;对象各自的功能&lt;/p&gt;

      
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>AFNetWorking—NSURLSession</title>
    <link href="http://yoursite.com/2016/10/13/AFNetWorking%E2%80%94NSURLSession/"/>
    <id>http://yoursite.com/2016/10/13/AFNetWorking—NSURLSession/</id>
    <published>2016-10-13T14:12:31.000Z</published>
    <updated>2018-08-06T04:03:34.824Z</updated>
    
    <content type="html"><![CDATA[<p>NSURLSession是iOS7推出的新一代网络框架，在NSURLConnection的基础上多了一种选择，AFNetwrking基于NSURLSession也实现了相应的网络请求API。从功能模块划分，网络可用性，数据的序列化和反序列化以及安全策略这几部分都是一样的，主要是网络请求的管理，请求和返回的处理比前者更加简单，应该说NSURLSession从系统层面实现了NSURLConnection没有实现的部分，比如管理多个请求，直接面向应用层提供上传下载的接口，所以AFNetworking基于NSRULSession实现的网络层更简单，但是功能上没有NSURLConnection那么丰富，比如监听所有任务中完成任务的进度，还有和UIKit的集成。   </p><h3 id="AFURLSessionManager"><a href="#AFURLSessionManager" class="headerlink" title="AFURLSessionManager"></a>AFURLSessionManager</h3><ul><li><p>NSURLSession<br>支持多个用task网络请求的管理，是网络层的核心。有NSURLSessionDelegate,NSURLSessionTas<br>kDelegate,NSURLSessionDataDelegate,NSURLSessionDownloadDelegate 多个代理接口。</p></li><li><p>operationQueue<br>用于初始化NSURLSession的队列，网络请求返回的回调会在该队列中的线程执行。类比使用NSURLConnection的时候，也有一个OperationQueue，功能基本一样，虽然NSURLConnection自己就是异步线程去发起网络请求，但是如果不使用NSOpeartion和OperationQueue，网络回调都将正在主线程中执行，会影响UI操作的流畅性。在NSURLConnection的实现部分，是通过全局的网络线程去执行回调的。这是NSURLConnection和NSURLSession不太一致的地方，后者是系统层就处理了，比NSURLConnection方便不少。</p></li><li><p>responseSerializer 用于返回数据的反序列化的对象</p></li><li><p>tasks  NSURLSession管理的所有网络请求包含重复的，分为一般的api请求,上传请求和下载请求。</p></li><li><p>dataTasks 一般的api请求</p></li><li><p>uploadTasks 上传请求</p></li><li><p>downloadTasks 下载请求</p></li><li><p>completionQueue 用户端的回调所在的队列</p></li><li><p>completionGroup 用户端回调队列所在的组</p></li><li><p>AFURLSessionManagerTaskDelegagate<br>在AFURLSessionManager内部用于存储task相关数据的业务对象，详细内容下面会单独介绍。</p></li><li><p>mutableTaskDelegatesKeyedByTaskIdentifier 可变字典，用于存储task和对应delegate之间的关联。</p><p>剩下的就是在网络请求过程中各种状态的回调block对象了。</p></li></ul><h3 id="AFURLSessionManagerTaskDelegate"><a href="#AFURLSessionManagerTaskDelegate" class="headerlink" title="AFURLSessionManagerTaskDelegate"></a>AFURLSessionManagerTaskDelegate</h3><p>   在网络请求的各种回调过程中，它用来存储和记录与单个task相关的信息，在网络请求完成之后，将数据<br>返回给用户端。</p><ul><li><p>AFURLSessionManager<br>在AFURLSessionManagerTaskDelegate对象中记录的session对象，一个session对象对应这多个<br>task对象，每个task都有一个与之对应的AFURLSessionManagerTaskDelegate对象。每一个task<br>在session层面都共享了一些数据，比如序列化对象，回调的队列和组，当一个task完成的时候，都需要<br>从共享的session中获取这些数据来完成业务层的回调逻辑。</p></li><li><p>mutableData<br>存储了当前请求获得的返回的数据信息，最后会反序列化成对象或者是以文件的形式保存下来。</p></li><li><p>progress<br>记录了下载或者上传文件的进度，可以随时通过uploadProgressForTask来获取某个task完成情况，<br>该方法参数为当前task。</p></li><li><p>AFURLSessionTaskCompletionHandler 由用户端设置的，task请求完成之后的用户端回调block</p></li><li><p>AFURLSessionDownloadTaskDidFinishDownloadingBlock<br>由用户端设置的，task下载文件完成之后生成目标文件的保存路径的block</p></li><li><p>downloadFileURL<br>由上一个block生成的目标文件保存路径，在下载完成的回调中设置，然后在整个请求完成的回调中以通知的形式返回给用户端</p></li></ul><h3 id="AFURLSessionManager与AFURLSessionManagerTaskDelegate的关系"><a href="#AFURLSessionManager与AFURLSessionManagerTaskDelegate的关系" class="headerlink" title="AFURLSessionManager与AFURLSessionManagerTaskDelegate的关系"></a>AFURLSessionManager与AFURLSessionManagerTaskDelegate的关系</h3><p>   在AFURLSessionManager中实现了大部分NSURLSession的协议，而AFURLSessionManagerTaskDelegate也实现了几个重要的协议，比如数据获取，整个task请求完成，文件下载和上传的进度。不同之处在于AFURLSessionManager是针对所有请求的，而taskDelegate只是针对某次具体的请求的。taskDelegate并没有直接从系统层获得回调，而是所有的回调都会先经过AFURLSessionManager处理，然后再分发给每个具体的taskDelegate，由每个taskDelegate自己存储并记录与当前请求相关的数据和信息。至于AFURLSessionManagerTaskDelegate中会有类似以下的回调的实现逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(__unused NSURLSession *)session</span><br><span class="line"> </span><br><span class="line">              task:(__unused NSURLSessionTask *)task</span><br><span class="line"> </span><br><span class="line">   didSendBodyData:(__unused int64_t)bytesSent</span><br><span class="line"> </span><br><span class="line">    totalBytesSent:(int64_t)totalBytesSent</span><br><span class="line"> </span><br><span class="line">totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    self.progress.totalUnitCount = totalBytesExpectedToSend;</span><br><span class="line"> </span><br><span class="line">    self.progress.completedUnitCount = totalBytesSent;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   task的delegate在这里只获取有用的数据，保存了上传的进度，这样做的目的就是为了保持代码一致性阅读起来更容理解，相当于代理方法的分发。sessionManager里通过字典存下了所有的task，而又在具体的session回调中去处理每个task相关的逻辑。</p><h3 id="AFHTTPSessionManager"><a href="#AFHTTPSessionManager" class="headerlink" title="AFHTTPSessionManager"></a>AFHTTPSessionManager</h3><p>   它继承自AFURLSessionManager，主要功能增加了一些初始化的方法以及对序列化和反序列化阶段的错误检查，还有设置具体的序列化对象。只是在AFURLSessionManager的基础上做了更容易使用的接口的封装。</p><h3 id="NSURLSession和NSURLConnection"><a href="#NSURLSession和NSURLConnection" class="headerlink" title="NSURLSession和NSURLConnection"></a>NSURLSession和NSURLConnection</h3><p>   AFNetworking中NSRULSession的实现上的设计上基本是一致的，AFURLSessionManager相当于AFHTTPRequestOperationManager。而AFURLConnectionOperation类似与NSURLSessionTask。但是对网络回调的实现上是不一致的，前者是依赖NSURLSession处理，然后分发给每个task自己处理。而NSURLConnection是每个请求都是独立处理各自来自系统层的网络回调，这是由于采用了不同的系统网络框架造成的。两种实现都有一个问题，就是如果baseURL是经常变化的，下载某一个素材的时候，这个时候比较好的办法是只使用NSRULConnection中的AFURLConnectionPeration，每次url由自己指定，自己去维护OperationQueue，可能需要自己实现AFHTTPRequestOperationManager的部分。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;NSURLSession是iOS7推出的新一代网络框架，在NSURLConnection的基础上多了一种选择，AFNetwrking基于NSURLSession也实现了相应的网络请求API。从功能模块划分，网络可用性，数据的序列化和反序列化以及安全策略这几部分都是一样的，主
      
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>AFNetworking-NSURLConnection</title>
    <link href="http://yoursite.com/2016/10/13/AFNetworking-NSURLConnection/"/>
    <id>http://yoursite.com/2016/10/13/AFNetworking-NSURLConnection/</id>
    <published>2016-10-13T14:12:31.000Z</published>
    <updated>2018-08-06T04:03:34.823Z</updated>
    
    <content type="html"><![CDATA[<h3 id="AFURLConnectionOperation"><a href="#AFURLConnectionOperation" class="headerlink" title="AFURLConnectionOperation"></a>AFURLConnectionOperation</h3><p>AFURLConnectionOperation继承自NSOpeartion，并且实现了NSURLConnection协议.</p><p><strong>主要功能</strong></p><ul><li><p>全局网络线程的创建</p></li><li><p>使用网络线程创建NSURLConnection发送请求，以及实现NSURLConenction代理方法来处理请求的返回数据。</p></li><li><p>向用户发送请求的各种消息。</p></li><li><p>控制着请求的生命周期，暂停，恢复，取消。</p></li><li><p>可以监听处理批量请求的完成度，有多少个请求已经完成。</p></li><li><p>请求结束之后调用回调用户的业务逻辑</p></li></ul><p><strong>组成：</strong></p><ul><li><p>networkRequestThread 全局的网络线程对象，用于所有网络请求对象NSURLConnection的初始化|暂停|取消|。与NSURLConnection相关的逻辑都是由它来完成的。</p></li><li><p>NSURLRequest 包含了一个网络请求的封装。</p></li><li><p>NSURLResponse 包含了一个网络返回的封装，它是在connection:didReceiveResponse的方法中设置。</p></li><li><p>NSData responseData 网络返回的数据，在connectionDidFinishLoading方法中获取。</p></li><li><p>NSInputStream 一个用于读取数据的流，是为NSURLRequest httpBody准备的。</p></li><li><p>NSOutputStream 一个用户获取网络返回数据的流，在Connection:didReceiveData中将返回的数据一部分一部分的读入,然后在connectionDidFinishLoading方法中将数据填充到responseData中。相当于所有下载的数据会缓存到NSOutputStream中，最后请求结束之后在创建一个完整的responseData。</p></li><li><p>completionQueue 队列，用于当请求结束的时候将后续的用户业务逻辑以bock的方法放到该队列中执行。</p></li><li><p>completionGroup 组，用于上一条的队列，它是和batchOfRequestOperations:progressBlock:completionBlock:方法联合起来使用的，通过dispatch_group_t派发组，可以监听多个请求的返回结果的处理完成的事件以及最后所有的请求处理完成的事件。</p></li><li><p>AFNetworkingOperationDidStartNotification定义用于向用户发送网络请求已经开始的通知。</p></li><li><p>AFNetworkingOperationDidFinishNotification，定义用于向用户发送网络请求已经结束的通知，在暂停|请求成功|请求失败的时候都会触发，参数是Operation自身。</p></li><li><p>completionBlock，在NSOperation结束的时候触发，用来处理请求结束之后的业务逻辑，结束指的是请求成功|失败|暂停|取消。</p></li><li><p>error，用于保存请求中发生的任务错误信息。</p></li></ul><h3 id="AFHTTPRequestOperation"><a href="#AFHTTPRequestOperation" class="headerlink" title="AFHTTPRequestOperation"></a>AFHTTPRequestOperation</h3><p>AFHTTPRequestOperation继承自AFURLConnectionOperation,它区别与后者的部分</p><p><strong>组成：</strong></p><ul><li><p>responseSerializationError 用于保存反序列化的过程中发生的错误</p></li><li><p>responseSerializer 它是用于请求结果反序列化的对象，具体可以参考源码分析总结2，默认是AFHTTPResponseSerializer。</p></li><li><p>responseObject, 它是具体的业务对象的数据(常用的数据形式，还不是业务model层)，它是通过responseSerializer反序列化而来 </p></li></ul><p><strong>功能：</strong></p><ul><li><p>重写了父类的pause方法，在暂停的时候，对请求对象Request的header做了修改，通过response的ETag字段，设置了请求头If-Range字段。用来实现断点续传的效果，但是仅仅是在app还在运行状态的时候有用。如果app退出则无效果，因为数据是通过NSOutputStream缓存在内存中的，而且If-Range这些信息也仅仅存在于内存对象中。</p></li><li><p>重写了error方法，优先返回反序列化错误，后返回父类请求中发生的错误。</p></li><li><p>定义了自己的setCompletionBlockWithSuccess:failure:方法，先检查是否有父类的请求错误，再进行反序列化，最后才会回调请求成功的业务逻辑。</p></li></ul><h3 id="AFHTTPRequestOperationManager"><a href="#AFHTTPRequestOperationManager" class="headerlink" title="AFHTTPRequestOperationManager"></a>AFHTTPRequestOperationManager</h3><p>AFHTTPRequestOperationManager是用来管理请求的BaseURL以及多个具体的请求，维护着一个请求队列，请求参数序列化的过程中产生的错误由它以回调的方式告知用户。</p><p><strong>组成：</strong></p><ul><li><p>baseURL 用于保存请求的域</p></li><li><p>requestSerializer 用于某一个请求的参数序列化对象，它的作用就是生成一个NSMutableURLRequest请求对象，该对象最终用于生成AFHTTPRequestOperation对象，默认是AFHTTPRequestSerializer对象。</p></li><li><p>responseSerializer 用于某一个请求的返回数据的反序列化，是由AFHTTPRequestOperationManager保存，用来给AFHTTPRequestOperation设置反序列化对象。</p></li><li><p>operationQueue 存放每个请求的队列，放到队列的请求由系统分配线程完成请求。</p></li><li><p>reachabilityManager 用于判断网络是否可用的组件</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;AFURLConnectionOperation&quot;&gt;&lt;a href=&quot;#AFURLConnectionOperation&quot; class=&quot;headerlink&quot; title=&quot;AFURLConnectionOperation&quot;&gt;&lt;/a&gt;AFURLConnectio
      
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>AFNetworking-ResponseSerializer</title>
    <link href="http://yoursite.com/2016/10/13/AFNetworking-ResponseSerializer/"/>
    <id>http://yoursite.com/2016/10/13/AFNetworking-ResponseSerializer/</id>
    <published>2016-10-13T14:10:34.000Z</published>
    <updated>2018-08-06T04:03:34.824Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概况："><a href="#概况：" class="headerlink" title="概况："></a>概况：</h3><p>这部分比较简单，一共有以下几个类：</p><ul><li>AFHTTPResponseSerializer</li><li>AFJSONResponseSerializer  : AFHTTPResponseSerializer</li><li>AFXMLParseResponseSerializer : AFHTTPResponseSerializer</li><li>AFXMLDocumentResponseSerializer : AFHTTPResponseSerializer</li><li>AFPropertyListResponseSerializer : AFHTTPResponseSerializer</li><li>AFImageResponseSerializer : AFHTTPResponseSerializer</li><li>AFCompoundResponseSerializer : AFHTTPResponseSerializer</li></ul><h3 id="AFHTTPResponseSerializer"><a href="#AFHTTPResponseSerializer" class="headerlink" title="AFHTTPResponseSerializer"></a>AFHTTPResponseSerializer</h3><p>这个类主要是验证response合法性，是否是有效的response</p><p><strong>validateResponse:data:error:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)validateResponse:(NSHTTPURLResponse *)response</span><br><span class="line">                    data:(NSData *)data</span><br><span class="line">                   error:(NSError * __autoreleasing *)error</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line">    BOOL responseIsValid = YES;</span><br><span class="line">    NSError *validationError = nil;</span><br><span class="line">    if (response &amp;&amp; [response isKindOfClass:[NSHTTPURLResponse class]]) &#123;</span><br><span class="line">//acceptableContentTypes里存储了当前serializer支持的content-type，</span><br><span class="line">//可以在不同的子类init方法中指定。有时候，通过charlse去mock请求的response，</span><br><span class="line">//没有通过rewrite功能重写content-type(默认是text/plain)为application/</span><br><span class="line">//json就会被afnetworking显示请求失败，not accept content-type 错误。</span><br><span class="line">        if (self.acceptableContentTypes &amp;&amp; ![self.acceptableContentTypes </span><br><span class="line">            containsObject:[response MIMEType]]) &#123;</span><br><span class="line"> </span><br><span class="line">            if ([data length] &gt; 0 &amp;&amp; [response URL]) &#123;</span><br><span class="line"> </span><br><span class="line">                NSMutableDictionary *mutableUserInfo = [@&#123;</span><br><span class="line"> </span><br><span class="line">                                                          NSLocalizedDescriptio</span><br><span class="line">                                                          nKey: [NSString </span><br><span class="line">                                                          stringWithFormat:NSLo</span><br><span class="line">                                                        calizedStringFromTable(</span><br><span class="line">                                                            @&quot;Request failed:</span><br><span class="line">                                                        unacceptable </span><br><span class="line">                                                          content-type: %@&quot;, @&quot;</span><br><span class="line">                                                          AFNetworking&quot;, nil), </span><br><span class="line">                                                          [response MIMEType]],</span><br><span class="line"> </span><br><span class="line">                                                          NSURLErrorFailingURLE</span><br><span class="line">                                                          rrorKey:[response URL</span><br><span class="line">                                                          ],</span><br><span class="line"> </span><br><span class="line">                                                          AFNetworkingOperation</span><br><span class="line">                                                          FailingURLResponseErr</span><br><span class="line">                                                          orKey: response,</span><br><span class="line"> </span><br><span class="line">                                                        &#125; mutableCopy];</span><br><span class="line"> </span><br><span class="line">                if (data) &#123;</span><br><span class="line"> </span><br><span class="line">                    mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</span><br><span class="line"> </span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                validationError = AFErrorWithUnderlyingError([NSError </span><br><span class="line">                    errorWithDomain:AFURLResponseSerializationErrorDomain code:</span><br><span class="line">                    NSURLErrorCannotDecodeContentData userInfo:mutableUserInfo]</span><br><span class="line">                    , validationError);</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            responseIsValid = NO;</span><br><span class="line">        &#125;</span><br><span class="line">//acceptableStatusCodes存储了当前serializer支持的返回码，里面的值是在</span><br><span class="line">//AFHTTPResponseSerializer基类</span><br><span class="line">调用init方法中指定的。</span><br><span class="line">        if (self.acceptableStatusCodes &amp;&amp; ![self.acceptableStatusCodes </span><br><span class="line">            containsIndex:(NSUInteger)response.statusCode] &amp;&amp; [response URL]) &#123;</span><br><span class="line"> </span><br><span class="line">            NSMutableDictionary *mutableUserInfo = [@&#123;</span><br><span class="line"> </span><br><span class="line">                                               NSLocalizedDescriptionKey: [</span><br><span class="line">                                               NSString stringWithFormat:</span><br><span class="line">                                               NSLocalizedStringFromTable(@&quot;</span><br><span class="line">                                               Request failed: %@ (%ld)&quot;, @&quot;</span><br><span class="line">                                               AFNetworking&quot;, nil), [</span><br><span class="line">                                               NSHTTPURLResponse </span><br><span class="line">                                               localizedStringForStatusCode:</span><br><span class="line">                                               response.statusCode], (long)</span><br><span class="line">                                               response.statusCode],</span><br><span class="line"> </span><br><span class="line">                                               NSURLErrorFailingURLErrorKey:[</span><br><span class="line">                                               response URL],</span><br><span class="line"> </span><br><span class="line">                                               AFNetworkingOperationFailingURLR</span><br><span class="line">                                               esponseErrorKey: response,</span><br><span class="line"> </span><br><span class="line">                                       &#125; mutableCopy];</span><br><span class="line">            if (data) &#123;</span><br><span class="line"> </span><br><span class="line">                mutableUserInfo[</span><br><span class="line">                AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            validationError = AFErrorWithUnderlyingError([NSError </span><br><span class="line">                errorWithDomain:AFURLResponseSerializationErrorDomain code:</span><br><span class="line">                NSURLErrorBadServerResponse userInfo:mutableUserInfo], </span><br><span class="line">                validationError);                </span><br><span class="line">            responseIsValid = NO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (error &amp;&amp; !responseIsValid) &#123;</span><br><span class="line"> </span><br><span class="line">        *error = validationError;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    return responseIsValid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AFHTTPResponseSerializer</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//只做了response的验证逻辑，具体的反序列化在各个子类中实现。</span><br><span class="line">//所有的serializer都要实现这个方法,在网络请求成功返回数据之后，AFNetworking就会调用serializer这个方法来反序列化。</span><br><span class="line">- (id)responseObjectForResponse:(NSURLResponse *)response</span><br><span class="line">                           data:(NSData *)data</span><br><span class="line">                          error:(NSError *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    [self validateResponse:(NSHTTPURLResponse *)response data:data error:error];</span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AFJSONResponseSerializer"><a href="#AFJSONResponseSerializer" class="headerlink" title="AFJSONResponseSerializer"></a>AFJSONResponseSerializer</h2><p><strong>responseObjectForResponse:data:error</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">- (id)responseObjectForResponse:(NSURLResponse *)response</span><br><span class="line">                           data:(NSData *)data</span><br><span class="line">                          error:(NSError *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:</span><br><span class="line">    error]) &#123;</span><br><span class="line"> </span><br><span class="line">        if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, </span><br><span class="line">            NSURLErrorCannotDecodeContentData, </span><br><span class="line">            AFURLResponseSerializationErrorDomain)) &#123;                </span><br><span class="line"> </span><br><span class="line">            return nil;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // Workaround for behavior of Rails to return a single space for `head </span><br><span class="line">    //:ok` (a workaround for a bug in Safari), which is not interpreted as </span><br><span class="line">    //valid input by NSJSONSerialization.</span><br><span class="line"> </span><br><span class="line">    // See https://github.com/rails/rails/issues/1742</span><br><span class="line"> </span><br><span class="line">    NSStringEncoding stringEncoding = self.stringEncoding;</span><br><span class="line"> </span><br><span class="line">    if (response.textEncodingName) &#123;</span><br><span class="line"> </span><br><span class="line">        CFStringEncoding encoding = CFStringConvertIANACharSetNameToEncoding((</span><br><span class="line">            CFStringRef)response.textEncodingName);</span><br><span class="line"> </span><br><span class="line">        if (encoding != kCFStringEncodingInvalidId) &#123;</span><br><span class="line">            stringEncoding = CFStringConvertEncodingToNSStringEncoding(encoding);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    id responseObject = nil;</span><br><span class="line"> </span><br><span class="line">    NSError *serializationError = nil;</span><br><span class="line"> </span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line"> </span><br><span class="line">        NSString *responseString = [[NSString alloc] initWithData:data encoding</span><br><span class="line">        :stringEncoding];</span><br><span class="line"> </span><br><span class="line">        if (responseString &amp;&amp; ![responseString isEqualToString:@&quot; &quot;]) &#123;</span><br><span class="line"> </span><br><span class="line">            // Workaround for a bug in NSJSONSerialization when Unicode </span><br><span class="line">            //character escape codes are used instead of the actual character</span><br><span class="line"> </span><br><span class="line">            // See http://stackoverflow.com/a/12843465/157142</span><br><span class="line"> </span><br><span class="line">            data = [responseString dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line"> </span><br><span class="line">            if (data) &#123;</span><br><span class="line"> </span><br><span class="line">                if ([data length] &gt; 0) &#123;</span><br><span class="line">                    responseObject = [NSJSONSerialization JSONObjectWithData:</span><br><span class="line">                    data options:self.readingOptions error:&amp;serializationError];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return nil;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">            &#125; else &#123;</span><br><span class="line"> </span><br><span class="line">                NSDictionary *userInfo = @&#123;</span><br><span class="line"> </span><br><span class="line">                                           NSLocalizedDescriptionKey: </span><br><span class="line">                                           NSLocalizedStringFromTable(@&quot;Data </span><br><span class="line">                                           failed decoding as a UTF-8 string&quot;, </span><br><span class="line">                                           @&quot;AFNetworking&quot;, nil),</span><br><span class="line"> </span><br><span class="line">                                           NSLocalizedFailureReasonErrorKey: [</span><br><span class="line">                                           NSString stringWithFormat:</span><br><span class="line">                                           NSLocalizedStringFromTable(@&quot;Could </span><br><span class="line">                                           not decode string: %@&quot;, @&quot;</span><br><span class="line">                                           AFNetworking&quot;, nil), responseString]</span><br><span class="line"> </span><br><span class="line">                                           &#125;;</span><br><span class="line">                serializationError = [NSError errorWithDomain:</span><br><span class="line">                AFURLResponseSerializationErrorDomain code:</span><br><span class="line">                NSURLErrorCannotDecodeContentData userInfo:userInfo];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//1.removesKeysWithNullValues表示当返回的数据dictionary的value为NSNULL的情况的时候，是</span><br><span class="line">//否移除对应键值对。不处理会导致前端crash，如果不设置这个属性，默认是false</span><br><span class="line">//2.self.readingOptions可以根据需求用来设置最后反序列化出字典是否未可变类型(</span><br><span class="line">//NSJSONReadingMutableContainers)，默认是不可变类型</span><br><span class="line">    if (self.removesKeysWithNullValues &amp;&amp; responseObject) &#123;</span><br><span class="line">        responseObject = AFJSONObjectByRemovingKeysWithNullValues(</span><br><span class="line">            responseObject, self.readingOptions);</span><br><span class="line">    &#125;</span><br><span class="line">    if (error) &#123;</span><br><span class="line">        *error = AFErrorWithUnderlyingError(serializationError, *error);</span><br><span class="line">    &#125;</span><br><span class="line">    return responseObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AFCompoundResponseSerializer"><a href="#AFCompoundResponseSerializer" class="headerlink" title="AFCompoundResponseSerializer"></a>AFCompoundResponseSerializer</h2><p><strong>responseObjectForResponse:data:error:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//这个类主要是可以合并多中Serializer的功能，存储在self.responseSerializers集合中。</span><br><span class="line">- (id)responseObjectForResponse:(NSURLResponse *)response</span><br><span class="line">                           data:(NSData *)data</span><br><span class="line">                          error:(NSError *__autoreleasing *)error</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line">//这里没有调用validateResponse方法，因为这个类处理的不是某一个具体的response类型</span><br><span class="line">    for (id &lt;AFURLResponseSerialization&gt; serializer in self.responseSerializers) &#123;</span><br><span class="line">        if (![serializer isKindOfClass:[AFHTTPResponseSerializer class]]) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        NSError *serializerError = nil;</span><br><span class="line">        id responseObject = [serializer responseObjectForResponse:response data:data error:&amp;serializerError];</span><br><span class="line">        if (responseObject) &#123;</span><br><span class="line">            if (error) &#123;</span><br><span class="line">                *error = AFErrorWithUnderlyingError(serializerError, *error);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            return responseObject;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    return [super responseObjectForResponse:response data:data error:error];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概况：&quot;&gt;&lt;a href=&quot;#概况：&quot; class=&quot;headerlink&quot; title=&quot;概况：&quot;&gt;&lt;/a&gt;概况：&lt;/h3&gt;&lt;p&gt;这部分比较简单，一共有以下几个类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AFHTTPResponseSerializer&lt;/li&gt;
&lt;li&gt;A
      
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>AFNetworking-RequestSerializer</title>
    <link href="http://yoursite.com/2016/10/13/AFNetworking-RequestSerializer/"/>
    <id>http://yoursite.com/2016/10/13/AFNetworking-RequestSerializer/</id>
    <published>2016-10-13T12:00:00.000Z</published>
    <updated>2018-08-06T04:03:34.823Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概况介绍："><a href="#概况介绍：" class="headerlink" title="概况介绍："></a>概况介绍：</h2><p>这篇主要介绍AFNetworking中请求参数序列化的部分,具体代码在AFURLRequestSerialization中。AFURLRequestSerialization包含四部分:</p><ul><li>AFHTTPRequestSerializaiton</li><li>AFJSONRequestSerializer</li><li>AFPropertyListRequestSerializer</li></ul><p>AFHTTPRequestSerialization主要是设置http请求头,设置超时时间,BA认证，处理用户名密码登陆等等。主要功能分3大块：</p><ol><li>处理所有的GET,HEAD,DELETE请求</li><li>处理content-type是application/x-www-form-urlencoded类型的POST请求</li><li>处理content-type是multipart/form-data类型的POST请求，请求的构建是通过AFStreamingMultipartFormData对象实现的。</li></ol><p>AFJSONRequestSerializer继承自AFHTTPRequestSerialization类，使用NSJSONSerialization序列化json格式(application/json)的参数，将一个Dictionary对象转化成NSData，它只处理POST请求。</p><p>AFPropertyListRequestSerializer也继承了AFHTTPRequestSerialization类，使用NSPropertyListSerialization对象来序列化xml格式(application/x-plist)的参数，它也只处理POST请求。</p><p>综上所述，AFHTTPRequestSerialization是最重要也是最复杂的部分，源码也主要针对这部分做分析。</p><h2 id="源码分析："><a href="#源码分析：" class="headerlink" title="源码分析："></a>源码分析：</h2><h3 id="参数序列化和编码"><a href="#参数序列化和编码" class="headerlink" title="参数序列化和编码"></a>参数序列化和编码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request</span><br><span class="line"> </span><br><span class="line">                               withParameters:(id)parameters</span><br><span class="line"> </span><br><span class="line">                                        error:(NSError *__autoreleasing *)error</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    NSParameterAssert(request);</span><br><span class="line"> </span><br><span class="line">    NSMutableURLRequest *mutableRequest = [request mutableCopy];</span><br><span class="line">//设置http请求头</span><br><span class="line">    [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id </span><br><span class="line">        value, BOOL * __unused stop) &#123;</span><br><span class="line"> </span><br><span class="line">        if (![request valueForHTTPHeaderField:field]) &#123;</span><br><span class="line"> </span><br><span class="line">            [mutableRequest setValue:value forHTTPHeaderField:field];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">//序列化参数</span><br><span class="line">    if (parameters) &#123;</span><br><span class="line"> </span><br><span class="line">        NSString *query = nil;</span><br><span class="line">//queryStringSerilization是一个block，主要是用来自定义参数序列化的逻辑，返回一个序列化完成的结果</span><br><span class="line">        if (self.queryStringSerialization) &#123;</span><br><span class="line"> </span><br><span class="line">            NSError *serializationError;</span><br><span class="line"> </span><br><span class="line">            query = self.queryStringSerialization(request, parameters, &amp;</span><br><span class="line">                serializationError);</span><br><span class="line"> </span><br><span class="line">            if (serializationError) &#123;</span><br><span class="line"> </span><br><span class="line">                if (error) &#123;</span><br><span class="line"> </span><br><span class="line">                    *error = serializationError;</span><br><span class="line"> </span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                return nil;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line"> </span><br><span class="line">            switch (self.queryStringSerializationStyle) &#123;</span><br><span class="line">//使用AFNetworking默认的格式序列化，a=1&amp;b=2这种</span><br><span class="line">                case AFHTTPRequestQueryStringDefaultStyle:</span><br><span class="line">//这里parameters是一个dictionary对象,stringEncoding是给httpBody设置data的时候字符</span><br><span class="line">//串的编码格式</span><br><span class="line">                    query = AFQueryStringFromParametersWithEncoding(parameters, self.stringEncoding);</span><br><span class="line"> </span><br><span class="line">                    break;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">//HTTPMethodsEncodingParametersInURI定义了GET,DELETE,HEAD3种方法</span><br><span class="line">        if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request </span><br><span class="line">            HTTPMethod] uppercaseString]]) &#123;</span><br><span class="line"> </span><br><span class="line">            mutableRequest.URL = [NSURL URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? </span><br><span class="line">            @&quot;&amp;%@&quot; : @&quot;?%@&quot;, query]];</span><br><span class="line"> </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">//POST</span><br><span class="line">            if (![mutableRequest valueForHTTPHeaderField:@&quot;Content-Type&quot;]) &#123;</span><br><span class="line"> </span><br><span class="line">                [mutableRequest setValue:@&quot;application/x-www-form-urlencoded&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line">//setHTTPBody接受一个NSData的参数,将query转化成NSData</span><br><span class="line">            [mutableRequest setHTTPBody:[query dataUsingEncoding:self.stringEncoding]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return mutableRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//用于AFURLRequestSerialization内部调用的方法</span><br><span class="line">static NSString * AFQueryStringFromParametersWithEncoding(NSDictionary *parameters, NSStringEncoding stringEncoding) &#123;</span><br><span class="line"> </span><br><span class="line">    NSMutableArray *mutablePairs = [NSMutableArray array];</span><br><span class="line">//AFQueryStringPair是封装的键值对对象,主要是将dictionary中的键值对转化成query </span><br><span class="line">//string形式，包括一些特殊字符的编码</span><br><span class="line">//AFQueryStringPairsFromDictionary将dictionary转化成AFQueryStringPair集合</span><br><span class="line">    for (AFQueryStringPair *pair in AFQueryStringPairsFromDictionary(parameters)) &#123;</span><br><span class="line"> </span><br><span class="line">        [mutablePairs addObject:[pair URLEncodedStringValueWithEncoding:stringEncoding]];</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    return [mutablePairs componentsJoinedByString:@&quot;&amp;&quot;];</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)URLEncodedStringValueWithEncoding:(NSStringEncoding)stringEncoding &#123;</span><br><span class="line">//碰到nil或者NSNULL边界值的处理</span><br><span class="line">    if (!self.value || [self.value isEqual:[NSNull null]]) &#123;</span><br><span class="line">        return AFPercentEscapedQueryStringKeyFromStringWithEncoding([self.field</span><br><span class="line">         description], stringEncoding);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return [NSString stringWithFormat:@&quot;%@=%@&quot;, AFPercentEscapedQueryStringKeyFromStringWithEncoding([self.field </span><br><span class="line">            description], stringEncoding), AFPercentEscapedQueryStringValueFromStringWithEncoding([self.value </span><br><span class="line">                description], stringEncoding)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//主要调用foundation函数CFURLCreateStringByAddingPercentEscapes，它主要是将querystri</span><br><span class="line">//ng中的特殊字符(&amp;,?)编码成“%+ASCII” 形式。根据文档，建议使用NSString </span><br><span class="line">//stringByAddingPercentEncodingWithAllowedCharacters:]方法，这个方法使用UTF-8 encoding。</span><br><span class="line">static NSString * AFPercentEscapedQueryStringValueFromStringWithEncoding(</span><br><span class="line">    NSString *string, NSStringEncoding encoding) &#123;</span><br><span class="line">    return (__bridge_transfer  NSString *)CFURLCreateStringByAddingPercentEscapes(kCFAllocatorDefault, (__bridge </span><br><span class="line">        CFStringRef)string, NULL, (__bridge CFStringRef)kAFCharactersToBeEscapedInQueryString, </span><br><span class="line">        CFStringConvertNSStringEncodingToEncoding(encoding));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AFStreamingMutipartFormData"><a href="#AFStreamingMutipartFormData" class="headerlink" title="AFStreamingMutipartFormData"></a>AFStreamingMutipartFormData</h3><p>先看一个mutipart/form-data格式的请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST http://www.example.com HTTP/1.1</span><br><span class="line">Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class="line"> </span><br><span class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class="line">Content-Disposition: form-data; name=&quot;text&quot;</span><br><span class="line"> </span><br><span class="line">title</span><br><span class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chrome.png&quot;</span><br><span class="line">Content-Type: image/png</span><br><span class="line"> </span><br><span class="line">PNG ... content of chrome.png ...</span><br><span class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA--</span><br></pre></td></tr></table></figure><ol><li>它的Content-Type包含两部分，第一部分是multipart/form-data,第二部分是boundary, boundary一般是随机生成的，保持唯一即可。上面还需要有content-length，图里面没有。</li><li>每个参数的部分都有content-disposition，并且以–boundary开头,最后一个参数以–boundary–结尾。</li></ol><p>AFNetworking通过AFStreamingMutipartFormData处理multipart/form-data格式的POST请求,它通过NSInputStream来构建http请求的body。每个参数的信息封装到了AFHTTPBodyPart中，所有的参数信息封装在AFMulipartBodyStream中。AFHTTPBodyPart中有NSInputStream对象用来将每个参数的写入到body，而AFMutipartBodyStream继承子NSInputStream处理所有参数的写入到body。其结构示意如下：</p><p><img src="http://7xqgnx.com1.z0.glb.clouddn.com/AFNetworkingArch.png" alt="AFNetworkingArch"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">//处理multilpart/form-data(POST)请求</span><br><span class="line">- (NSMutableURLRequest *)multipartFormRequestWithMethod:(NSString *)method</span><br><span class="line"> </span><br><span class="line">                                              URLString:(NSString *)URLString</span><br><span class="line"> </span><br><span class="line">                                             parameters:(NSDictionary *)parameters</span><br><span class="line"> </span><br><span class="line">                              constructingBodyWithBlock:(void (^)(id &lt;AFMultipartFormData&gt; formData))block</span><br><span class="line"> </span><br><span class="line">                                                  error:(NSError *__autoreleasing *)error</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line">    NSParameterAssert(method);</span><br><span class="line"> </span><br><span class="line">    NSParameterAssert(![method isEqualToString:@&quot;GET&quot;] &amp;&amp; ![method isEqualToString:@&quot;HEAD&quot;]);</span><br><span class="line">//这里parameters传的是nil，因为当前格式(mutilpart/form-data)</span><br><span class="line">//需要由AFStreamingMulitpartFormData去构建参数。</span><br><span class="line">    NSMutableURLRequest *mutableRequest = [self requestWithMethod:method </span><br><span class="line">    URLString:URLString parameters:nil error:error];</span><br><span class="line"> </span><br><span class="line">    __block AFStreamingMultipartFormData *formData = [[AFStreamingMultipartFormData alloc] initWithURLRequest:mutableRequest </span><br><span class="line">    stringEncoding:NSUTF8StringEncoding];</span><br><span class="line"> </span><br><span class="line">    if (parameters) &#123;</span><br><span class="line"> </span><br><span class="line">        for (AFQueryStringPair *pair in AFQueryStringPairsFromDictionary(parameters)) &#123;</span><br><span class="line">//对于dictionary的参数，直接将它的值转成NSData处理，</span><br><span class="line">            NSData *data = nil;</span><br><span class="line"> </span><br><span class="line">            if ([pair.value isKindOfClass:[NSData class]]) &#123;</span><br><span class="line"> </span><br><span class="line">                data = pair.value;</span><br><span class="line"> </span><br><span class="line">            &#125; else if ([pair.value isEqual:[NSNull null]]) &#123;</span><br><span class="line"> </span><br><span class="line">                data = [NSData data];</span><br><span class="line"> </span><br><span class="line">            &#125; else &#123;</span><br><span class="line"> </span><br><span class="line">                data = [[pair.value description] dataUsingEncoding:self.stringEncoding];</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            if (data) &#123;</span><br><span class="line">//AFStreamingMultipartFormData对象的appendPartWithFormData将键值对转化成AFHTTPBodyP</span><br><span class="line">//art并且放到AFMultipartBodyStream集合中。</span><br><span class="line">                [formData appendPartWithFormData:data name:[pair.field description]];</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (block) &#123;</span><br><span class="line">//当前block用来处理非dictionary的情况，比如参数可能是一个NSURL,或者直接就是一个NSInputStream。</span><br><span class="line">        block(formData);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">//AFStreamingMultipartFormData的requestByFinalizingMultipartFormData主要是设置cont</span><br><span class="line">//ent-Type和content-Length以及boundary</span><br><span class="line">    return [formData requestByFinalizingMultipartFormData];</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (NSMutableURLRequest *)requestByFinalizingMultipartFormData &#123;</span><br><span class="line"> </span><br><span class="line">    if ([self.bodyStream isEmpty]) &#123;</span><br><span class="line"> </span><br><span class="line">        return self.request;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 设置boundary</span><br><span class="line"> </span><br><span class="line">    [self.bodyStream setInitialAndFinalBoundaries];</span><br><span class="line"> </span><br><span class="line">//将AFStreamingMultipartFormData的AFMultipartBodyStream设置到http body stream上</span><br><span class="line">    [self.request setHTTPBodyStream:self.bodyStream];</span><br><span class="line"> </span><br><span class="line">    [self.request setValue:[NSString stringWithFormat:@&quot;multipart/form-data; </span><br><span class="line">    boundary=%@&quot;, self.boundary] forHTTPHeaderField:@&quot;Content-Type&quot;];</span><br><span class="line"> </span><br><span class="line">    [self.request setValue:[NSString stringWithFormat:@&quot;%llu&quot;, [self.bodyStream</span><br><span class="line">     contentLength]] forHTTPHeaderField:@&quot;Content-Length&quot;];</span><br><span class="line"> </span><br><span class="line">    return self.request;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)setInitialAndFinalBoundaries &#123;</span><br><span class="line"> </span><br><span class="line">    if ([self.HTTPBodyParts count] &gt; 0) &#123;</span><br><span class="line"> </span><br><span class="line">        for (AFHTTPBodyPart *bodyPart in self.HTTPBodyParts) &#123;</span><br><span class="line"> </span><br><span class="line">            bodyPart.hasInitialBoundary = NO;</span><br><span class="line"> </span><br><span class="line">            bodyPart.hasFinalBoundary = NO;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">//设置boundary的头</span><br><span class="line">        [[self.HTTPBodyParts objectAtIndex:0] setHasInitialBoundary:YES];</span><br><span class="line">//设置boundary的尾</span><br><span class="line">        [[self.HTTPBodyParts lastObject] setHasFinalBoundary:YES];</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//主要是设置每个参数部分的content-disposition</span><br><span class="line">- (void)appendPartWithFormData:(NSData *)data</span><br><span class="line">                          name:(NSString *)name</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line">    NSParameterAssert(name);</span><br><span class="line"> </span><br><span class="line">    NSMutableDictionary *mutableHeaders = [NSMutableDictionary dictionary];</span><br><span class="line"> </span><br><span class="line">    [mutableHeaders setValue:[NSString stringWithFormat:@&quot;form-data; name=\&quot;%@</span><br><span class="line">    \&quot;&quot;, name] forKey:@&quot;Content-Disposition&quot;];</span><br><span class="line"> </span><br><span class="line">    [self appendPartWithHeaders:mutableHeaders body:data];</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//构建AFHTTPBodyPart对象,这种情况下，AFHTTPBody对象的body都是nsdata类型</span><br><span class="line">- (void)appendPartWithHeaders:(NSDictionary *)headers</span><br><span class="line">                         body:(NSData *)body</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line">    NSParameterAssert(body);</span><br><span class="line"> </span><br><span class="line">    AFHTTPBodyPart *bodyPart = [[AFHTTPBodyPart alloc] init];</span><br><span class="line"> </span><br><span class="line">    bodyPart.stringEncoding = self.stringEncoding;</span><br><span class="line"> </span><br><span class="line">    bodyPart.headers = headers;</span><br><span class="line"> </span><br><span class="line">    bodyPart.boundary = self.boundary;</span><br><span class="line"> </span><br><span class="line">    bodyPart.bodyContentLength = [body length];</span><br><span class="line"> </span><br><span class="line">    bodyPart.body = body;</span><br><span class="line"> </span><br><span class="line">    [self.bodyStream appendHTTPBodyPart:bodyPart];</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了NSData，还可以传入NSInputStream,NSURL去构建AFHTTPBodyPart对象，过程和NSData类似，设置Content-disposition和Content-Type，再通过data去构建AFHTTPBodyPart。</p><h3 id="AFMultipartBodyStream"><a href="#AFMultipartBodyStream" class="headerlink" title="AFMultipartBodyStream"></a>AFMultipartBodyStream</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">- (NSInteger)read:(uint8_t *)buffer</span><br><span class="line"> </span><br><span class="line">        maxLength:(NSUInteger)length</span><br><span class="line">&#123;</span><br><span class="line">//AFStreamingMutipartFormData将AFMultipartBodyStream设置到NSUrlRequest的httpbodys</span><br><span class="line">//tream之后，foundation会自动调用read:maxLength:方法，改方法实现中遍历之前构建的所有AFHTTP</span><br><span class="line">//BodyPart对象，分别调用它们的read:maxLength:方法来获取数据。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if ([self streamStatus] == NSStreamStatusClosed) &#123;</span><br><span class="line"> </span><br><span class="line">        return 0;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    NSInteger totalNumberOfBytesRead = 0;</span><br><span class="line"> </span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line"> </span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wgnu&quot;</span><br><span class="line"> </span><br><span class="line">    while ((NSUInteger)totalNumberOfBytesRead &lt; MIN(length, self.</span><br><span class="line">        numberOfBytesInPacket)) &#123;</span><br><span class="line"> </span><br><span class="line">        if (!self.currentHTTPBodyPart || ![self.currentHTTPBodyPart </span><br><span class="line">            hasBytesAvailable]) &#123;</span><br><span class="line"> </span><br><span class="line">            if (!(self.currentHTTPBodyPart = [self.HTTPBodyPartEnumerator </span><br><span class="line">                nextObject])) &#123;</span><br><span class="line"> </span><br><span class="line">                break;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125; else &#123;</span><br><span class="line"> </span><br><span class="line">            NSUInteger maxLength = length - (NSUInteger)totalNumberOfBytesRead;</span><br><span class="line"> </span><br><span class="line">            NSInteger numberOfBytesRead = [self.currentHTTPBodyPart read:&amp;</span><br><span class="line">            buffer[totalNumberOfBytesRead] maxLength:maxLength];</span><br><span class="line"> </span><br><span class="line">            if (numberOfBytesRead == -1) &#123;</span><br><span class="line"> </span><br><span class="line">                self.streamError = self.currentHTTPBodyPart.inputStream.</span><br><span class="line">                streamError;</span><br><span class="line"> </span><br><span class="line">                break;</span><br><span class="line"> </span><br><span class="line">            &#125; else &#123;</span><br><span class="line"> </span><br><span class="line">                totalNumberOfBytesRead += numberOfBytesRead;</span><br><span class="line"> </span><br><span class="line">                if (self.delay &gt; 0.0f) &#123;</span><br><span class="line"> </span><br><span class="line">                    [NSThread sleepForTimeInterval:self.delay];</span><br><span class="line"> </span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    return totalNumberOfBytesRead;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AFHTTPBodyPart"><a href="#AFHTTPBodyPart" class="headerlink" title="AFHTTPBodyPart"></a>AFHTTPBodyPart</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//根据body类型生成对应的inputStream</span><br><span class="line">- (NSInputStream *)inputStream &#123;</span><br><span class="line"> </span><br><span class="line">    if (!_inputStream) &#123;</span><br><span class="line"> </span><br><span class="line">        if ([self.body isKindOfClass:[NSData class]]) &#123;</span><br><span class="line"> </span><br><span class="line">            _inputStream = [NSInputStream inputStreamWithData:self.body];</span><br><span class="line"> </span><br><span class="line">        &#125; else if ([self.body isKindOfClass:[NSURL class]]) &#123;</span><br><span class="line"> </span><br><span class="line">            _inputStream = [NSInputStream inputStreamWithURL:self.body];</span><br><span class="line"> </span><br><span class="line">        &#125; else if ([self.body isKindOfClass:[NSInputStream class]]) &#123;</span><br><span class="line"> </span><br><span class="line">            _inputStream = self.body;</span><br><span class="line"> </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            _inputStream = [NSInputStream inputStreamWithData:[NSData data]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return _inputStream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">- (NSInteger)read:(uint8_t *)buffer</span><br><span class="line"> </span><br><span class="line">        maxLength:(NSUInteger)length</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    NSInteger totalNumberOfBytesRead = 0;</span><br><span class="line">    if (_phase == AFEncapsulationBoundaryPhase) &#123;</span><br><span class="line">//boundary部分，转成NSData</span><br><span class="line">        NSData *encapsulationBoundaryData = [([self hasInitialBoundary] ? </span><br><span class="line">            AFMultipartFormInitialBoundary(self.boundary) : </span><br><span class="line">            AFMultipartFormEncapsulationBoundary(self.boundary)) </span><br><span class="line">            dataUsingEncoding:self.stringEncoding];</span><br><span class="line"> </span><br><span class="line">        totalNumberOfBytesRead += [self readData:encapsulationBoundaryData </span><br><span class="line">        intoBuffer:&amp;buffer[totalNumberOfBytesRead] maxLength:(length - (</span><br><span class="line">            NSUInteger)totalNumberOfBytesRead)];</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    if (_phase == AFHeaderPhase) &#123;</span><br><span class="line">//content-disposition和content-length,转成NSData</span><br><span class="line">        NSData *headersData = [[self stringForHeaders] dataUsingEncoding:self.</span><br><span class="line">        stringEncoding];</span><br><span class="line"> </span><br><span class="line">        totalNumberOfBytesRead += [self readData:headersData intoBuffer:&amp;buffer</span><br><span class="line">        [totalNumberOfBytesRead] maxLength:(length - (NSUInteger)</span><br><span class="line">        totalNumberOfBytesRead)];</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (_phase == AFBodyPhase) &#123;</span><br><span class="line">        NSInteger numberOfBytesRead = 0;</span><br><span class="line">//每个AFHTTPBodyPart的body部分，也就是实际传输的数据部分，都通过在inputStream方法里根据其实</span><br><span class="line">//际数据类型转化成了NSInputStream类型对象，所以这里只需要调用foundation自带的read:maxLength方法就行了。</span><br><span class="line">        numberOfBytesRead = [self.inputStream read:&amp;buffer[</span><br><span class="line">        totalNumberOfBytesRead] maxLength:(length - (NSUInteger)</span><br><span class="line">        totalNumberOfBytesRead)];</span><br><span class="line"> </span><br><span class="line">        if (numberOfBytesRead == -1) &#123;</span><br><span class="line"> </span><br><span class="line">            return -1;</span><br><span class="line"> </span><br><span class="line">        &#125; else &#123;</span><br><span class="line"> </span><br><span class="line">            totalNumberOfBytesRead += numberOfBytesRead;</span><br><span class="line">            if ([self.inputStream streamStatus] &gt;= NSStreamStatusAtEnd) &#123;</span><br><span class="line"> </span><br><span class="line">                [self transitionToNextPhase];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (_phase == AFFinalBoundaryPhase) &#123;</span><br><span class="line">//如果当前AFHTTPBodyPart是最后一个参数，那么会比其他参数多一个--boundary--的部分,转成NSData</span><br><span class="line">        NSData *closingBoundaryData = ([self hasFinalBoundary] ? [</span><br><span class="line">            AFMultipartFormFinalBoundary(self.boundary) dataUsingEncoding:self.</span><br><span class="line">            stringEncoding] : [NSData data]);</span><br><span class="line"> </span><br><span class="line">        totalNumberOfBytesRead += [self readData:closingBoundaryData intoBuffer</span><br><span class="line">        :&amp;buffer[totalNumberOfBytesRead] maxLength:(length - (NSUInteger)</span><br><span class="line">        totalNumberOfBytesRead)];</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return totalNumberOfBytesRead;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//将data读入buffer中</span><br><span class="line">- (NSInteger)readData:(NSData *)data</span><br><span class="line"> </span><br><span class="line">           intoBuffer:(uint8_t *)buffer</span><br><span class="line"> </span><br><span class="line">            maxLength:(NSUInteger)length</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line"> </span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wgnu&quot;</span><br><span class="line">/*没有明白为什么读data的时候range为什么要从_phaseReadOffset开始，不应该是从0开始吗，因为每次</span><br><span class="line">都是一个全新的data*/</span><br><span class="line">    NSRange range = NSMakeRange((NSUInteger)_phaseReadOffset, MIN([data length]</span><br><span class="line">     - ((NSUInteger)_phaseReadOffset), length));</span><br><span class="line">//将data中range范围之内的数据复制到buffer里</span><br><span class="line">    [data getBytes:buffer range:range];</span><br><span class="line"> </span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line"> </span><br><span class="line">    _phaseReadOffset += range.length;</span><br><span class="line"> </span><br><span class="line">    if (((NSUInteger)_phaseReadOffset) &gt;= [data length]) &#123;</span><br><span class="line"> </span><br><span class="line">        [self transitionToNextPhase];</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    return (NSInteger)range.length;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//序列化AFHTTPBodyPart的headers部分</span><br><span class="line">- (NSString *)stringForHeaders &#123;</span><br><span class="line">    NSMutableString *headerString = [NSMutableString string];</span><br><span class="line"> </span><br><span class="line">    for (NSString *field in [self.headers allKeys]) &#123;</span><br><span class="line"> </span><br><span class="line">        [headerString appendString:[NSString stringWithFormat:@&quot;%@: %@%@&quot;, </span><br><span class="line">        field, [self.headers valueForKey:field], kAFMultipartFormCRLF]];</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    [headerString appendString:kAFMultipartFormCRLF];</span><br><span class="line">    return [NSString stringWithString:headerString];</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//计算每个AFHTTPBodyPart的内容长度，包括传输参数，请求头和boundary信息,在AFMultiStream里会</span><br><span class="line">//将所有的AFHTTPBodyPart的content-length加起来，做为整个POST请求体的content-length。</span><br><span class="line">- (unsigned long long)contentLength &#123;</span><br><span class="line">    unsigned long long length = 0;</span><br><span class="line">//boundary</span><br><span class="line">    NSData *encapsulationBoundaryData = [([self hasInitialBoundary] ? </span><br><span class="line">        AFMultipartFormInitialBoundary(self.boundary) : </span><br><span class="line">    AFMultipartFormEncapsulationBoundary(self.boundary)) dataUsingEncoding:self</span><br><span class="line">    .stringEncoding];</span><br><span class="line">    length += [encapsulationBoundaryData length];</span><br><span class="line">//headers</span><br><span class="line">    NSData *headersData = [[self stringForHeaders] dataUsingEncoding:self.</span><br><span class="line">    stringEncoding];</span><br><span class="line">    length += [headersData length];</span><br><span class="line">//data</span><br><span class="line">    length += _bodyContentLength;</span><br><span class="line">//close boudary</span><br><span class="line">    NSData *closingBoundaryData = ([self hasFinalBoundary] ? [</span><br><span class="line">        AFMultipartFormFinalBoundary(self.boundary) dataUsingEncoding:self.</span><br><span class="line">    stringEncoding] : [NSData data]);</span><br><span class="line">    length += [closingBoundaryData length];</span><br><span class="line">    return length;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概况介绍：&quot;&gt;&lt;a href=&quot;#概况介绍：&quot; class=&quot;headerlink&quot; title=&quot;概况介绍：&quot;&gt;&lt;/a&gt;概况介绍：&lt;/h2&gt;&lt;p&gt;这篇主要介绍AFNetworking中请求参数序列化的部分,具体代码在AFURLRequestSerializati
      
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>CFRunLoop</title>
    <link href="http://yoursite.com/2016/01/26/CFRunLoop/"/>
    <id>http://yoursite.com/2016/01/26/CFRunLoop/</id>
    <published>2016-01-26T09:02:11.000Z</published>
    <updated>2018-08-06T04:03:34.825Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><strong>__CFRunLoopMode</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span> &#123;</span></span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> _lock;  <span class="comment">/* must have the run loop locked before locking </span></span><br><span class="line"><span class="comment">    this */</span></span><br><span class="line"><span class="comment">//mode名</span></span><br><span class="line">    CFStringRef _name;</span><br><span class="line">    Boolean _stopped;</span><br><span class="line">    <span class="keyword">char</span> _padding[<span class="number">3</span>];</span><br><span class="line"><span class="comment">//source0 源</span></span><br><span class="line">    CFMutableSetRef _sources0;</span><br><span class="line"><span class="comment">//source1 源</span></span><br><span class="line">    CFMutableSetRef _sources1;</span><br><span class="line"><span class="comment">//observer 源</span></span><br><span class="line">    CFMutableArrayRef _observers;</span><br><span class="line"><span class="comment">//timer 源</span></span><br><span class="line">    CFMutableArrayRef _timers;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//mach port 到 mode的映射,为了在runloop主逻辑中过滤runloop自己的port消息。</span></span><br><span class="line">    CFMutableDictionaryRef _portToV1SourceMap;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//记录了所有当前mode中需要监听的port，作为调用监听消息函数的参数。</span></span><br><span class="line">    __CFPortSet _portSet;</span><br><span class="line">    CFIndex _observerMask;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span></span><br><span class="line">    <span class="keyword">dispatch_source_t</span> _timerSource;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> _queue;</span><br><span class="line">    Boolean _timerFired; <span class="comment">// set to true by the source when a timer has fired</span></span><br><span class="line">    Boolean _dispatchTimerArmed;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_MK_TIMER_TOO</span></span><br><span class="line"><span class="comment">//使用 mk timer， 用到的mach port，和source1类似，都依赖于mach port</span></span><br><span class="line">    <span class="keyword">mach_port_t</span> _timerPort;</span><br><span class="line">    Boolean _mkTimerArmed;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//timer触发的理想时间</span></span><br><span class="line">    <span class="keyword">uint64_t</span> _timerSoftDeadline; <span class="comment">/* TSR */</span></span><br><span class="line"><span class="comment">//timer触发的实际时间，理想时间加上tolerance（偏差）</span></span><br><span class="line">    <span class="keyword">uint64_t</span> _timerHardDeadline; <span class="comment">/* TSR */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>__CFRunLoop</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoop</span> &#123;</span></span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> _lock;          <span class="comment">/* locked for accessing mode list */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//用于手动将当前runloop线程唤醒，通过调用CFRunLoopWakeUp完成，</span></span><br><span class="line"><span class="comment">//CFRunLoopWakeUp会向_wakeUpPort发送一条消息</span></span><br><span class="line">    __CFPort _wakeUpPort;           <span class="comment">// used for CFRunLoopWakeUp </span></span><br><span class="line">    Boolean _unused;</span><br><span class="line">    <span class="keyword">volatile</span> _per_run_data *_perRunData; <span class="comment">// reset for runs of the run loop</span></span><br><span class="line">    <span class="keyword">pthread_t</span> _pthread;</span><br><span class="line">    <span class="keyword">uint32_t</span> _winthread;</span><br><span class="line"><span class="comment">//记录了当前runloop中所有的mode名</span></span><br><span class="line">    CFMutableSetRef _commonModes;</span><br><span class="line"><span class="comment">//记录了当前runloop中所有注册到commonMode中的源</span></span><br><span class="line">    CFMutableSetRef _commonModeItems;</span><br><span class="line">    CFRunLoopModeRef _currentMode;</span><br><span class="line">    CFMutableSetRef _modes;</span><br><span class="line"><span class="comment">//记录了添加到runloop中的block，它也可以像其他源一样被runloop处理，</span></span><br><span class="line"><span class="comment">//通过CFRunLoopPerformBlock可向runloop中添加block任务。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">block_item</span> *_<span class="title">blocks_head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">block_item</span> *_<span class="title">blocks_tail</span>;</span></span><br><span class="line">    CFTypeRef _counterpart;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>__CFRunLoops</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局字典，保存线程和对应runloop之间的关系</span></span><br><span class="line"><span class="keyword">static</span> CFMutableDictionaryRef __CFRunLoops = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h2 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h2><p><strong>__CFRunLoopRun</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int32_t</span> __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, </span><br><span class="line">    CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef </span><br><span class="line">    previousMode) &#123;</span><br><span class="line">    <span class="comment">//获取系统启动之后cpu嘀嗒数</span></span><br><span class="line">    <span class="keyword">uint64_t</span> startTSR = mach_absolute_time();</span><br><span class="line">    <span class="keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">        __CFRunLoopUnsetStopped(rl);</span><br><span class="line">    <span class="keyword">return</span> kCFRunLoopRunStopped;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;</span><br><span class="line">    rlm-&gt;_stopped = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> kCFRunLoopRunStopped;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//mach 端口, 线程之间通信的对象</span></span><br><span class="line">    <span class="keyword">mach_port_name_t</span> dispatchPort = MACH_PORT_NULL;</span><br><span class="line">    <span class="comment">//这里主要是为了判断当前线程是否为主线程        </span></span><br><span class="line">    Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((</span><br><span class="line">        HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; <span class="literal">NULL</span> == previousMode) || (!</span><br><span class="line">        HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; <span class="number">0</span> == _CFGetTSD(</span><br><span class="line">            __CFTSDKeyIsInGCDMainQ)));</span><br><span class="line">    <span class="keyword">if</span> (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl</span><br><span class="line">        -&gt;_commonModes, rlm-&gt;_name)) dispatchPort = </span><br><span class="line">        _dispatch_get_main_queue_port_4CF();</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//使用GCD实现runloop超时功能</span></span><br><span class="line">    <span class="keyword">dispatch_source_t</span> timeout_timer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">timeout_context</span> *<span class="title">timeout_context</span> = (<span class="title">struct</span> __<span class="title">timeout_context</span> *)</span></span><br><span class="line"><span class="class">    <span class="title">malloc</span>(<span class="title">sizeof</span>(*<span class="title">timeout_context</span>));</span></span><br><span class="line">    <span class="comment">//seconds是设置的runloop超时时间</span></span><br><span class="line">    <span class="keyword">if</span> (seconds &lt;= <span class="number">0.0</span>) &#123; <span class="comment">// instant timeout</span></span><br><span class="line">        seconds = <span class="number">0.0</span>;</span><br><span class="line">        timeout_context-&gt;termTSR = <span class="number">0U</span>LL;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(</span><br><span class="line">        DISPATCH_QUEUE_PRIORITY_HIGH, DISPATCH_QUEUE_OVERCOMMIT);</span><br><span class="line">    timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, </span><br><span class="line">        <span class="built_in">queue</span>);</span><br><span class="line">        dispatch_retain(timeout_timer);</span><br><span class="line">    timeout_context-&gt;ds = timeout_timer;</span><br><span class="line">    timeout_context-&gt;rl = (CFRunLoopRef)CFRetain(rl);</span><br><span class="line">    timeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds);</span><br><span class="line">    dispatch_set_context(timeout_timer, timeout_context); <span class="comment">// source gets </span></span><br><span class="line">    <span class="comment">//ownership of context</span></span><br><span class="line">    dispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout);</span><br><span class="line">        dispatch_source_set_cancel_handler_f(timeout_timer, </span><br><span class="line">            __CFRunLoopTimeoutCancel);</span><br><span class="line">        <span class="keyword">uint64_t</span> ns_at = (<span class="keyword">uint64_t</span>)((__CFTSRToTimeInterval(startTSR) + seconds)</span><br><span class="line">         * <span class="number">1000000000U</span>LL);</span><br><span class="line">        dispatch_source_set_timer(timeout_timer, dispatch_time(<span class="number">1</span>, ns_at), </span><br><span class="line">        DISPATCH_TIME_FOREVER, <span class="number">1000U</span>LL);</span><br><span class="line">        dispatch_resume(timeout_timer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// infinite timeout</span></span><br><span class="line">        seconds = <span class="number">9999999999.0</span>;</span><br><span class="line">        timeout_context-&gt;termTSR = UINT64_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    Boolean didDispatchPortLastTime = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int32_t</span> retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">uint8_t</span> msg_buffer[<span class="number">3</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">mach_msg_header_t</span> *msg = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">mach_port_t</span> livePort = MACH_PORT_NULL;</span><br><span class="line">    __CFPortSet waitSet = rlm-&gt;_portSet;</span><br><span class="line">        __CFRunLoopUnsetIgnoreWakeUps(rl);</span><br><span class="line">        <span class="comment">//rl-&gt;_perRunData-&gt;ignoreWakeUps = 0x0;</span></span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers</span><br><span class="line">        (rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) </span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line"><span class="comment">//Perform blocks queued by CFRunLoopPerformBlock;</span></span><br><span class="line">    __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, </span><br><span class="line">            stopAfterHandle);</span><br><span class="line">        <span class="comment">//如果rl中有source0消息</span></span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">            <span class="comment">//处理block  Perform blocks newly queued by CFRunLoopPerformBlock;</span></span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//poll标志着有没有处理source0的消息，如果没有则为false，反之为true</span></span><br><span class="line">        Boolean poll = sourceHandledThisLoop || (<span class="number">0U</span>LL == timeout_context-&gt;</span><br><span class="line">            termTSR);</span><br><span class="line">        <span class="comment">//第一次进来不走这个逻辑，didDispatchPortLastTime是true</span></span><br><span class="line">        <span class="keyword">if</span> (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123;</span><br><span class="line">            msg = (<span class="keyword">mach_msg_header_t</span> *)msg_buffer;</span><br><span class="line">            <span class="comment">//__CFRunLoopServiceMachPort用于接受指定端口(一个也可以是多个)</span></span><br><span class="line">            <span class="comment">//的消息,最后一个参数代表当端口无消息的时候是否休眠,0是立刻返回不休眠,</span></span><br><span class="line">            <span class="comment">//TIMEOUT_INFINITY代表休眠</span></span><br><span class="line">            <span class="comment">//处理通过GCD派发到主线程的任务,这些任务优先级最高会被最先处理</span></span><br><span class="line">            <span class="keyword">if</span> (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, <span class="keyword">sizeof</span>(</span><br><span class="line">                msg_buffer), &amp;livePort, <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">goto</span> handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        didDispatchPortLastTime = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//根据之前有没有处理过source0消息，来判断如果也没有source1消息的时候是否让线程进入睡眠，这里处</span></span><br><span class="line"><span class="comment">//理observer源，如果睡眠则通知Observer进入睡眠。</span></span><br><span class="line">    <span class="keyword">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) </span><br><span class="line">    __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">    __CFRunLoopSetSleeping(rl);</span><br><span class="line">    <span class="comment">// do not do any user callouts after this point (after notifying of </span></span><br><span class="line">        <span class="comment">//sleeping)</span></span><br><span class="line">        <span class="comment">// Must push the local-to-this-activation ports in on every loop</span></span><br><span class="line">        <span class="comment">// iteration, as this mode could be run re-entrantly and we don't</span></span><br><span class="line">        <span class="comment">// want these ports to get serviced.</span></span><br><span class="line">        __CFPortSetInsert(dispatchPort, waitSet);</span><br><span class="line">         </span><br><span class="line">    __CFRunLoopModeUnlock(rlm);</span><br><span class="line">    __CFRunLoopUnlock(rl);</span><br><span class="line">    <span class="keyword">if</span> (kCFUseCollectableAllocator) &#123;</span><br><span class="line">        objc_clear_stack(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">memset</span>(msg_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg_buffer));</span><br><span class="line">    &#125;</span><br><span class="line">    msg = (<span class="keyword">mach_msg_header_t</span> *)msg_buffer;</span><br><span class="line">    <span class="comment">//如果poll为null，且waitset中无port有消息,线程进入休眠</span></span><br><span class="line">    __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, </span><br><span class="line">    poll ? <span class="number">0</span> : TIMEOUT_INFINITY);</span><br><span class="line">     </span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    __CFRunLoopModeLock(rlm);</span><br><span class="line">    <span class="comment">// Must remove the local-to-this-activation ports in on every loop</span></span><br><span class="line">    <span class="comment">// iteration, as this mode could be run re-entrantly and we don't</span></span><br><span class="line">    <span class="comment">// want these ports to get serviced. Also, we don't want them left</span></span><br><span class="line">    <span class="comment">// in there if this function returns.</span></span><br><span class="line">    __CFPortSetRemove(dispatchPort, waitSet);</span><br><span class="line">     </span><br><span class="line">    __CFRunLoopSetIgnoreWakeUps(rl);</span><br><span class="line">        <span class="comment">// user callouts now OK again</span></span><br><span class="line">    __CFRunLoopUnsetSleeping(rl);</span><br><span class="line">    <span class="comment">//处理observer源，线程醒来</span></span><br><span class="line">    <span class="keyword">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting)) </span><br><span class="line">    __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line">        handle_msg:;</span><br><span class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</span><br><span class="line">        <span class="keyword">if</span> (MACH_PORT_NULL == livePort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_NOTHING();</span><br><span class="line">            <span class="comment">// handle nothing</span></span><br><span class="line"><span class="comment">//通过CFRunloopWake将当前线程唤醒</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (livePort == rl-&gt;_wakeUpPort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_WAKEUP();</span><br><span class="line">            <span class="comment">// do nothing on Mac OS</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//处理timer源</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;</span><br><span class="line">            _timerPort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</span><br><span class="line">            <span class="keyword">if</span> (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">                <span class="comment">// Re-arm the next timer</span></span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//通过GCD派发给主线程的任务</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (livePort == dispatchPort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_DISPATCH();</span><br><span class="line">            __CFRunLoopModeUnlock(rlm);</span><br><span class="line">            __CFRunLoopUnlock(rl);</span><br><span class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (<span class="keyword">void</span> *)<span class="number">6</span>, <span class="literal">NULL</span>);</span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (<span class="keyword">void</span> *)<span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">            __CFRunLoopLock(rl);</span><br><span class="line">            __CFRunLoopModeLock(rlm);</span><br><span class="line">            sourceHandledThisLoop = <span class="literal">true</span>;</span><br><span class="line">            didDispatchPortLastTime = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//通过macPort给当前线程派发消息,处理source1</span></span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_SOURCE();</span><br><span class="line">            <span class="comment">// Despite the name, this works for windows handles as well</span></span><br><span class="line">            <span class="comment">//过滤macPort消息，有一些消息不一定是runloop中注册的，这里只处理runloop中注册的</span></span><br><span class="line">            <span class="comment">//消息，在rlm-&gt;_portToV1SourceMap通过macPort找有没有对应的runloopMode</span></span><br><span class="line">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, </span><br><span class="line">                rlm, livePort);</span><br><span class="line">            <span class="keyword">if</span> (rls) &#123;</span><br><span class="line">                <span class="keyword">mach_msg_header_t</span> *reply = <span class="literal">NULL</span>;</span><br><span class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg,</span><br><span class="line">                 msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">NULL</span> != reply) &#123;</span><br><span class="line">                    <span class="comment">//当前线程处理完source1，给发消息的线程反馈消息, </span></span><br><span class="line">                    <span class="comment">//MACH_SEND_MSG表示给replay端口发送消息</span></span><br><span class="line">                    (<span class="keyword">void</span>)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, <span class="number">0</span>, </span><br><span class="line">                        MACH_PORT_NULL, <span class="number">0</span>, MACH_PORT_NULL);</span><br><span class="line">                    CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg &amp;&amp; msg != (<span class="keyword">mach_msg_header_t</span> *)msg_buffer) <span class="built_in">free</span>(msg);</span><br><span class="line">         </span><br><span class="line">    __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">    <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">        retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">        <span class="comment">//runloop超时时间到</span></span><br><span class="line">            retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">            __CFRunLoopUnsetStopped(rl);</span><br><span class="line">        retVal = kCFRunLoopRunStopped;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;</span><br><span class="line">        rlm-&gt;_stopped = <span class="literal">false</span>;</span><br><span class="line">        retVal = kCFRunLoopRunStopped;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">        retVal = kCFRunLoopRunFinished;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span> == retVal);</span><br><span class="line">    <span class="keyword">if</span> (timeout_timer) &#123;</span><br><span class="line">        dispatch_source_cancel(timeout_timer);</span><br><span class="line">        dispatch_release(timeout_timer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">free</span>(timeout_context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CFRunLoopAddSource</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CFRunLoopAddSource</span><span class="params">(CFRunLoopRef rl, CFRunLoopSourceRef rls, </span></span></span><br><span class="line"><span class="function"><span class="params">    CFStringRef modeName)</span> </span>&#123;    <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="keyword">if</span> (__CFRunLoopIsDeallocating(rl)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!__CFIsValid(rls)) <span class="keyword">return</span>;</span><br><span class="line">    Boolean doVer0Callout = <span class="literal">false</span>;</span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    <span class="keyword">if</span> (modeName == kCFRunLoopCommonModes) &#123;</span><br><span class="line">        <span class="comment">//par1 : 处理commonModeItmes的逻辑</span></span><br><span class="line"><span class="comment">/*rl-&gt;_commonModes的作用是记录了当前runloop中标记为commonMode的mode，rl-&gt;_commonModeI</span></span><br><span class="line"><span class="comment">tems记录了当前runloop中注册到commonMode中的源</span></span><br><span class="line"><span class="comment">两者用来处理跟commonMode相关的逻辑，比如当一个mode被标记为commonMode的时候，会将rl-&gt;_common</span></span><br><span class="line"><span class="comment">ModeItems中的源添加到新的mode当中去，在当前mode下这些源的消息就会被</span></span><br><span class="line"><span class="comment">监听并处理。例如一个timer被注册到commonMode中，那么在所有被标记为commonMode的mode中都会处理该timer的消息。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    CFSetRef <span class="built_in">set</span> = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault</span><br><span class="line">        , rl-&gt;_commonModes) : <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == rl-&gt;_commonModeItems) &#123;</span><br><span class="line">        rl-&gt;_commonModeItems = CFSetCreateMutable(kCFAllocatorSystemDefault, <span class="number">0</span>, &amp;kCFTypeSetCallBacks);</span><br><span class="line">    &#125;</span><br><span class="line">    CFSetAddValue(rl-&gt;_commonModeItems, rls);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != <span class="built_in">set</span>) &#123;</span><br><span class="line">        CFTypeRef context[<span class="number">2</span>] = &#123;rl, rls&#125;;</span><br><span class="line">        <span class="comment">/* add new item to all common-modes */</span></span><br><span class="line">        <span class="comment">//对每一个mode，调用part2的逻辑</span></span><br><span class="line">        CFSetApplyFunction(<span class="built_in">set</span>, (__CFRunLoopAddItemToCommonModes), (<span class="keyword">void</span> *)context);</span><br><span class="line">        CFRelease(<span class="built_in">set</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//part2 : 处理某个具体的mode中addSource的逻辑</span></span><br><span class="line">    CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != rlm &amp;&amp; <span class="literal">NULL</span> == rlm-&gt;_sources0) &#123;</span><br><span class="line">        rlm-&gt;_sources0 = CFSetCreateMutable(kCFAllocatorSystemDefault, <span class="number">0</span>, &amp;</span><br><span class="line">            kCFTypeSetCallBacks);</span><br><span class="line">        rlm-&gt;_sources1 = CFSetCreateMutable(kCFAllocatorSystemDefault, <span class="number">0</span>, &amp;</span><br><span class="line">            kCFTypeSetCallBacks);</span><br><span class="line">        rlm-&gt;_portToV1SourceMap = CFDictionaryCreateMutable(</span><br><span class="line">            kCFAllocatorSystemDefault, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != rlm &amp;&amp; !CFSetContainsValue(rlm-&gt;_sources0, rls) &amp;&amp; !</span><br><span class="line">    CFSetContainsValue(rlm-&gt;_sources1, rls)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == rls-&gt;_context.version0.version) &#123;</span><br><span class="line">            CFSetAddValue(rlm-&gt;_sources0, rls);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">1</span> == rls-&gt;_context.version0.version) &#123;</span><br><span class="line">            CFSetAddValue(rlm-&gt;_sources1, rls);</span><br><span class="line">        __CFPort src_port = rls-&gt;_context.version1.getPort(rls-&gt;_context.</span><br><span class="line">            version1.info);</span><br><span class="line">        <span class="keyword">if</span> (CFPORT_NULL != src_port) &#123;</span><br><span class="line">        <span class="comment">//rlm-&gt;_portToV1SourceMap是port到source1的映射，</span></span><br><span class="line">        <span class="comment">//为了在runloop主逻辑中过滤runloop自己的port消息。</span></span><br><span class="line">            CFDictionarySetValue(rlm-&gt;_portToV1SourceMap, (<span class="keyword">const</span> <span class="keyword">void</span> *)(</span><br><span class="line">                <span class="keyword">uintptr_t</span>)src_port, rls);</span><br><span class="line">        <span class="comment">//rml-&gt;_portSet记录了所有当前mode中需要监听的port，作为调用监听消息函数的参数。</span></span><br><span class="line">            __CFPortSetInsert(src_port, rlm-&gt;_portSet);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        __CFRunLoopSourceLock(rls);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == rls-&gt;_runLoops) &#123;</span><br><span class="line">            rls-&gt;_runLoops = CFBagCreateMutable(kCFAllocatorSystemDefault, <span class="number">0</span>, &amp;</span><br><span class="line">            kCFTypeBagCallBacks); <span class="comment">// sources retain run loops!</span></span><br><span class="line">        &#125;</span><br><span class="line">        CFBagAddValue(rls-&gt;_runLoops, rl);</span><br><span class="line">        __CFRunLoopSourceUnlock(rls);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == rls-&gt;_context.version0.version) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">NULL</span> != rls-&gt;_context.version0.schedule) &#123;</span><br><span class="line">                doVer0Callout = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != rlm) &#123;</span><br><span class="line">        __CFRunLoopModeUnlock(rlm);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __CFRunLoopUnlock(rl);</span><br><span class="line">    <span class="keyword">if</span> (doVer0Callout) &#123;</span><br><span class="line">        <span class="comment">// although it looses some protection for the source, we have no </span></span><br><span class="line">        <span class="comment">//choice but</span></span><br><span class="line">        <span class="comment">// to do this after unlocking the run loop and mode locks, to avoid </span></span><br><span class="line">        <span class="comment">//deadlocks</span></span><br><span class="line">        <span class="comment">// where the source wants to take a lock which is already held in </span></span><br><span class="line">        <span class="comment">//another</span></span><br><span class="line">        <span class="comment">// thread which is itself waiting for a run loop/mode lock</span></span><br><span class="line">    rls-&gt;_context.version0.schedule(rls-&gt;_context.version0.info, rl, modeName);   <span class="comment">/* CALLOUT */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CFRunLoopRemoveSource</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CFRunLoopRemoveSource</span><span class="params">(CFRunLoopRef rl, CFRunLoopSourceRef rls, </span></span></span><br><span class="line"><span class="function"><span class="params">    CFStringRef modeName)</span> </span>&#123; <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    Boolean doVer0Callout = <span class="literal">false</span>, doRLSRelease = <span class="literal">false</span>;</span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    <span class="keyword">if</span> (modeName == kCFRunLoopCommonModes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != rl-&gt;_commonModeItems &amp;&amp; CFSetContainsValue(rl-&gt;</span><br><span class="line">            _commonModeItems, rls)) &#123;</span><br><span class="line">            CFSetRef <span class="built_in">set</span> = rl-&gt;_commonModes ? CFSetCreateCopy(</span><br><span class="line">                kCFAllocatorSystemDefault, rl-&gt;_commonModes) : <span class="literal">NULL</span>;</span><br><span class="line">            CFSetRemoveValue(rl-&gt;_commonModeItems, rls);</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">NULL</span> != <span class="built_in">set</span>) &#123;</span><br><span class="line">            CFTypeRef context[<span class="number">2</span>] = &#123;rl, rls&#125;;</span><br><span class="line">            <span class="comment">/* remove new item from all common-modes */</span></span><br><span class="line">            CFSetApplyFunction(<span class="built_in">set</span>, (__CFRunLoopRemoveItemFromCommonModes), (</span><br><span class="line">                <span class="keyword">void</span> *)context);</span><br><span class="line">            CFRelease(<span class="built_in">set</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != rlm &amp;&amp; ((<span class="literal">NULL</span> != rlm-&gt;_sources0 &amp;&amp; CFSetContainsValue(rlm-&gt;</span><br><span class="line">        _sources0, rls)) || (<span class="literal">NULL</span> != rlm-&gt;_sources1 &amp;&amp; CFSetContainsValue(rlm-&gt;</span><br><span class="line">            _sources1, rls)))) &#123;</span><br><span class="line">        <span class="comment">//source0或者source1中的一种</span></span><br><span class="line">        CFRetain(rls);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == rls-&gt;_context.version0.version) &#123;</span><br><span class="line">        __CFPort src_port = rls-&gt;_context.version1.getPort(rls-&gt;_context.</span><br><span class="line">            version1.info);</span><br><span class="line">                <span class="keyword">if</span> (CFPORT_NULL != src_port) &#123;</span><br><span class="line">            CFDictionaryRemoveValue(rlm-&gt;_portToV1SourceMap, (<span class="keyword">const</span> <span class="keyword">void</span> *)(</span><br><span class="line">                <span class="keyword">uintptr_t</span>)src_port);</span><br><span class="line">                    __CFPortSetRemove(src_port, rlm-&gt;_portSet);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        CFSetRemoveValue(rlm-&gt;_sources0, rls);</span><br><span class="line">        CFSetRemoveValue(rlm-&gt;_sources1, rls);</span><br><span class="line">            __CFRunLoopSourceLock(rls);</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">NULL</span> != rls-&gt;_runLoops) &#123;</span><br><span class="line">                CFBagRemoveValue(rls-&gt;_runLoops, rl);</span><br><span class="line">            &#125;</span><br><span class="line">            __CFRunLoopSourceUnlock(rls);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == rls-&gt;_context.version0.version) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">NULL</span> != rls-&gt;_context.version0.cancel) &#123;</span><br><span class="line">                doVer0Callout = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        doRLSRelease = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != rlm) &#123;</span><br><span class="line">        __CFRunLoopModeUnlock(rlm);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __CFRunLoopUnlock(rl);</span><br><span class="line">    <span class="keyword">if</span> (doVer0Callout) &#123;</span><br><span class="line">        <span class="comment">// although it looses some protection for the source, we have no choice but</span></span><br><span class="line">        <span class="comment">// to do this after unlocking the run loop and mode locks, to avoid deadlocks</span></span><br><span class="line">        <span class="comment">// where the source wants to take a lock which is already held in another</span></span><br><span class="line">        <span class="comment">// thread which is itself waiting for a run loop/mode lock</span></span><br><span class="line">        rls-&gt;_context.version0.cancel(rls-&gt;_context.version0.info, rl, modeName); <span class="comment">/* CALLOUT */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (doRLSRelease) CFRelease(rls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CFRunLoopAddTimer</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CFRunLoopAddTimer</span><span class="params">(CFRunLoopRef rl, CFRunLoopTimerRef rlt, CFStringRef </span></span></span><br><span class="line"><span class="function"><span class="params">    modeName)</span> </span>&#123;   </span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="keyword">if</span> (__CFRunLoopIsDeallocating(rl)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!__CFIsValid(rlt) || (<span class="literal">NULL</span> != rlt-&gt;_runLoop &amp;&amp; rlt-&gt;_runLoop != rl)) </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    <span class="keyword">if</span> (modeName == kCFRunLoopCommonModes) &#123;</span><br><span class="line">    CFSetRef <span class="built_in">set</span> = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault</span><br><span class="line">        , rl-&gt;_commonModes) : <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == rl-&gt;_commonModeItems) &#123;</span><br><span class="line">        rl-&gt;_commonModeItems = CFSetCreateMutable(kCFAllocatorSystemDefault, <span class="number">0</span>,</span><br><span class="line">         &amp;kCFTypeSetCallBacks);</span><br><span class="line">    &#125;</span><br><span class="line">    CFSetAddValue(rl-&gt;_commonModeItems, rlt);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != <span class="built_in">set</span>) &#123;</span><br><span class="line">        CFTypeRef context[<span class="number">2</span>] = &#123;rl, rlt&#125;;</span><br><span class="line">        <span class="comment">/* add new item to all common-modes */</span></span><br><span class="line">        CFSetApplyFunction(<span class="built_in">set</span>, (__CFRunLoopAddItemToCommonModes), (<span class="keyword">void</span> *)</span><br><span class="line">        context);</span><br><span class="line">        CFRelease(<span class="built_in">set</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != rlm) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">NULL</span> == rlm-&gt;_timers) &#123;</span><br><span class="line">                CFArrayCallBacks cb = kCFTypeArrayCallBacks;</span><br><span class="line">                cb.equal = <span class="literal">NULL</span>;</span><br><span class="line">                rlm-&gt;_timers = CFArrayCreateMutable(kCFAllocatorSystemDefault, </span><br><span class="line">                    <span class="number">0</span>, &amp;cb);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != rlm &amp;&amp; !CFSetContainsValue(rlt-&gt;_rlModes, rlm-&gt;_name)) &#123;</span><br><span class="line">            __CFRunLoopTimerLock(rlt);</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">NULL</span> == rlt-&gt;_runLoop) &#123;</span><br><span class="line">        rlt-&gt;_runLoop = rl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rl != rlt-&gt;_runLoop) &#123;</span><br><span class="line">                __CFRunLoopTimerUnlock(rlt);</span><br><span class="line">            __CFRunLoopModeUnlock(rlm);</span><br><span class="line">                __CFRunLoopUnlock(rl);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        CFSetAddValue(rlt-&gt;_rlModes, rlm-&gt;_name);</span><br><span class="line">            __CFRunLoopTimerUnlock(rlt);</span><br><span class="line">            __CFRunLoopTimerFireTSRLock();</span><br><span class="line">            <span class="comment">//__CFRepositionTimerInMode是添加或者删除timer,</span></span><br><span class="line">            <span class="comment">//这里是往rlm-&gt;_timers添加timer</span></span><br><span class="line">            __CFRepositionTimerInMode(rlm, rlt, <span class="literal">false</span>);</span><br><span class="line">            __CFRunLoopTimerFireTSRUnlock();</span><br><span class="line">            <span class="keyword">if</span> (!_CFExecutableLinkedOnOrAfter(CFSystemVersionLion)) &#123;</span><br><span class="line">                <span class="comment">// Normally we don't do this on behalf of clients, but for</span></span><br><span class="line">                <span class="comment">// backwards compatibility due to the change in timer handling...</span></span><br><span class="line">                <span class="keyword">if</span> (rl != CFRunLoopGetCurrent()) CFRunLoopWakeUp(rl);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != rlm) &#123;</span><br><span class="line">        __CFRunLoopModeUnlock(rlm);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __CFRunLoopUnlock(rl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>__CFRunLoopFindMode</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> CFRunLoopModeRef __CFRunLoopFindMode(CFRunLoopRef rl, CFStringRef </span><br><span class="line">    modeName, Boolean create) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    CFRunLoopModeRef rlm;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span> <span class="title">srlm</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;srlm, <span class="number">0</span>, <span class="keyword">sizeof</span>(srlm));</span><br><span class="line">    _CFRuntimeSetInstanceTypeIDAndIsa(&amp;srlm, __kCFRunLoopModeTypeID);</span><br><span class="line">    srlm._name = modeName;</span><br><span class="line">    rlm = (CFRunLoopModeRef)CFSetGetValue(rl-&gt;_modes, &amp;srlm);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != rlm) &#123;</span><br><span class="line">    __CFRunLoopModeLock(rlm);</span><br><span class="line">    <span class="keyword">return</span> rlm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!create) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rlm = (CFRunLoopModeRef)_CFRuntimeCreateInstance(kCFAllocatorSystemDefault,</span><br><span class="line">     __kCFRunLoopModeTypeID, <span class="keyword">sizeof</span>(struct __CFRunLoopMode) - <span class="keyword">sizeof</span>(</span><br><span class="line">        CFRuntimeBase), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == rlm) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    __CFRunLoopLockInit(&amp;rlm-&gt;_lock);</span><br><span class="line">    rlm-&gt;_name = CFStringCreateCopy(kCFAllocatorSystemDefault, modeName);</span><br><span class="line">    rlm-&gt;_stopped = <span class="literal">false</span>;</span><br><span class="line">    rlm-&gt;_portToV1SourceMap = <span class="literal">NULL</span>;</span><br><span class="line">    rlm-&gt;_sources0 = <span class="literal">NULL</span>;</span><br><span class="line">    rlm-&gt;_sources1 = <span class="literal">NULL</span>;</span><br><span class="line">    rlm-&gt;_observers = <span class="literal">NULL</span>;</span><br><span class="line">    rlm-&gt;_timers = <span class="literal">NULL</span>;</span><br><span class="line">    rlm-&gt;_observerMask = <span class="number">0</span>;</span><br><span class="line">    rlm-&gt;_portSet = __CFPortSetAllocate();</span><br><span class="line">    rlm-&gt;_timerSoftDeadline = UINT64_MAX;</span><br><span class="line">    rlm-&gt;_timerHardDeadline = UINT64_MAX;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">kern_return_t</span> ret = KERN_SUCCESS;</span><br><span class="line">    <span class="comment">//1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span></span><br><span class="line">    rlm-&gt;_timerFired = <span class="literal">false</span>;</span><br><span class="line">    rlm-&gt;_queue = _dispatch_runloop_root_queue_create_4CF(<span class="string">"Run Loop Mode Queue"</span></span><br><span class="line">    , <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">mach_port_t</span> queuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;</span><br><span class="line">        _queue);</span><br><span class="line">    <span class="keyword">if</span> (queuePort == MACH_PORT_NULL) CRASH(<span class="string">"*** Unable to create run loop mode </span></span><br><span class="line"><span class="string">    queue port. (%d) ***"</span>, <span class="number">-1</span>);</span><br><span class="line">    rlm-&gt;_timerSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        , rlm-&gt;_queue);</span><br><span class="line">     </span><br><span class="line">    __block Boolean *timerFiredPointer = &amp;(rlm-&gt;_timerFired);</span><br><span class="line">    dispatch_source_set_event_handler(rlm-&gt;_timerSource, ^&#123;</span><br><span class="line">        *timerFiredPointer = <span class="literal">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// Set timer to far out there. The unique leeway makes this timer easy to spot in debug output.</span></span><br><span class="line">    _dispatch_source_set_runloop_timer_4CF(rlm-&gt;_timerSource, </span><br><span class="line">        DISPATCH_TIME_FOREVER, DISPATCH_TIME_FOREVER, <span class="number">321</span>);</span><br><span class="line">    dispatch_resume(rlm-&gt;_timerSource);</span><br><span class="line">     </span><br><span class="line">    ret = __CFPortSetInsert(queuePort, rlm-&gt;_portSet);</span><br><span class="line">    <span class="keyword">if</span> (KERN_SUCCESS != ret) CRASH(<span class="string">"*** Unable to insert timer port into port </span></span><br><span class="line"><span class="string">    set. (%d) ***"</span>, ret);</span><br><span class="line">     </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_MK_TIMER_TOO</span></span><br><span class="line">    rlm-&gt;_timerPort = mk_timer_create();</span><br><span class="line">    ret = __CFPortSetInsert(rlm-&gt;_timerPort, rlm-&gt;_portSet);</span><br><span class="line">    <span class="keyword">if</span> (KERN_SUCCESS != ret) CRASH(<span class="string">"*** Unable to insert timer port into port </span></span><br><span class="line"><span class="string">    set. (%d) ***"</span>, ret);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">     </span><br><span class="line">    ret = __CFPortSetInsert(rl-&gt;_wakeUpPort, rlm-&gt;_portSet);</span><br><span class="line">    <span class="keyword">if</span> (KERN_SUCCESS != ret) CRASH(<span class="string">"*** Unable to insert wake up port into </span></span><br><span class="line"><span class="string">    port set. (%d) ***"</span>, ret);</span><br><span class="line">     </span><br><span class="line">    CFSetAddValue(rl-&gt;_modes, rlm);</span><br><span class="line">    CFRelease(rlm);</span><br><span class="line">    __CFRunLoopModeLock(rlm);   <span class="comment">/* return mode locked */</span></span><br><span class="line">    <span class="keyword">return</span> rlm;</span><br><span class="line">&#125;  ``<span class="keyword">return</span>` `rlm;``&#125;`</span><br></pre></td></tr></table></figure><p><strong>__CFRepositionTimerInMode</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRepositionTimerInMode(CFRunLoopModeRef rlm, CFRunLoopTimerRef </span><br><span class="line">    rlt, Boolean isInArray) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!rlt) <span class="keyword">return</span>;</span><br><span class="line">     </span><br><span class="line">    CFMutableArrayRef timerArray = rlm-&gt;_timers;</span><br><span class="line">    <span class="keyword">if</span> (!timerArray) <span class="keyword">return</span>;</span><br><span class="line">    Boolean found = <span class="literal">false</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// If we know in advance that the timer is not in the array (just being added now) then we can skip this search</span></span><br><span class="line">    <span class="keyword">if</span> (isInArray) &#123;</span><br><span class="line">        CFIndex idx = CFArrayGetFirstIndexOfValue(timerArray, CFRangeMake(<span class="number">0</span>, </span><br><span class="line">            CFArrayGetCount(timerArray)), rlt);</span><br><span class="line">        <span class="keyword">if</span> (kCFNotFound != idx) &#123;</span><br><span class="line">            CFRetain(rlt);</span><br><span class="line">            CFArrayRemoveValueAtIndex(timerArray, idx);</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!found &amp;&amp; isInArray) <span class="keyword">return</span>;</span><br><span class="line">    CFIndex newIdx = __CFRunLoopInsertionIndexInTimerArray(timerArray, rlt);</span><br><span class="line">   <span class="comment">//timer开始计时</span></span><br><span class="line">    CFArrayInsertValueAtIndex(timerArray, newIdx, rlt);</span><br><span class="line">    __CFArmNextTimerInMode(rlm, rlt-&gt;_runLoop);</span><br><span class="line">    <span class="keyword">if</span> (isInArray) CFRelease(rlt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>__CFArmNextTimerInMode</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFArmNextTimerInMode(CFRunLoopModeRef rlm, CFRunLoopRef rl) &#123;   </span><br><span class="line">    <span class="keyword">uint64_t</span> nextHardDeadline = UINT64_MAX;</span><br><span class="line">    <span class="keyword">uint64_t</span> nextSoftDeadline = UINT64_MAX;</span><br><span class="line">    <span class="keyword">if</span> (rlm-&gt;_timers) &#123;</span><br><span class="line">        <span class="comment">// Look at the list of timers. We will calculate two TSR values; the </span></span><br><span class="line"><span class="comment">//next soft and next hard deadline.</span></span><br><span class="line">        <span class="comment">// The next soft deadline is the first time we can fire any timer. </span></span><br><span class="line"><span class="comment">//This is the fire date of the first timer in our sorted list of timers.</span></span><br><span class="line">        <span class="comment">// The next hard deadline is the last time at which we can fire the </span></span><br><span class="line"><span class="comment">//timer before we've moved out of the allowable tolerance of the timers in our list.</span></span><br><span class="line">        <span class="keyword">for</span> (CFIndex idx = <span class="number">0</span>, cnt = CFArrayGetCount(rlm-&gt;_timers); idx &lt; cnt; </span><br><span class="line">idx++) &#123;</span><br><span class="line">            CFRunLoopTimerRef t = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(rlm</span><br><span class="line">    -&gt;_timers , idx);</span><br><span class="line">            <span class="comment">// discount timers currently firing</span></span><br><span class="line">            <span class="keyword">if</span> (__CFRunLoopTimerIsFiring(t)) <span class="keyword">continue</span>;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">int32_t</span> err = CHECKINT_NO_ERROR;</span><br><span class="line">            <span class="keyword">uint64_t</span> oneTimerSoftDeadline = t-&gt;_fireTSR;</span><br><span class="line">            <span class="keyword">uint64_t</span> oneTimerHardDeadline = check_uint64_add(t-&gt;_fireTSR, </span><br><span class="line">    __CFTimeIntervalToTSR(t-&gt;_tolerance), &amp;err);</span><br><span class="line">            <span class="keyword">if</span> (err != CHECKINT_NO_ERROR) oneTimerHardDeadline = UINT64_MAX;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">// We can stop searching if the soft deadline for this timer exceeds the current hard deadline. Otherwise, later timers with lower tolerance could still have earlier hard deadlines.</span></span><br><span class="line">            <span class="keyword">if</span> (oneTimerSoftDeadline &gt; nextHardDeadline) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span> (oneTimerSoftDeadline &lt; nextSoftDeadline) &#123;</span><br><span class="line">                nextSoftDeadline = oneTimerSoftDeadline;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span> (oneTimerHardDeadline &lt; nextHardDeadline) &#123;</span><br><span class="line">                nextHardDeadline = oneTimerHardDeadline;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span> (nextSoftDeadline &lt; UINT64_MAX &amp;&amp; (nextHardDeadline != rlm-&gt;</span><br><span class="line">    _timerHardDeadline || nextSoftDeadline != rlm-&gt;_timerSoftDeadline)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (CFRUNLOOP_NEXT_TIMER_ARMED_ENABLED()) &#123;</span><br><span class="line">                CFRUNLOOP_NEXT_TIMER_ARMED((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nextSoftDeadline - </span><br><span class="line">    mach_absolute_time()));</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span></span><br><span class="line">            <span class="comment">// We're going to hand off the range of allowable timer fire date </span></span><br><span class="line"><span class="comment">//to dispatch and let it fire when appropriate for the system.</span></span><br><span class="line">            <span class="keyword">uint64_t</span> leeway = __CFTSRToNanoseconds(nextHardDeadline - </span><br><span class="line">    nextSoftDeadline);</span><br><span class="line">            <span class="keyword">dispatch_time_t</span> deadline = __CFTSRToDispatchTime(nextSoftDeadline);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_MK_TIMER_TOO</span></span><br><span class="line"><span class="comment">//leeway表示timer的偏差，如果_tolerance(&gt;=0)为0，则leeway等于0</span></span><br><span class="line">            <span class="keyword">if</span> (leeway &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//GCD timer</span></span><br><span class="line">                <span class="comment">// Only use the dispatch timer if we have any leeway</span></span><br><span class="line">                <span class="comment">// &lt;rdar://problem/14447675&gt;</span></span><br><span class="line">                 </span><br><span class="line">                <span class="comment">// Cancel the mk timer</span></span><br><span class="line">                <span class="keyword">if</span> (rlm-&gt;_mkTimerArmed &amp;&amp; rlm-&gt;_timerPort) &#123;</span><br><span class="line">                    AbsoluteTime dummy;</span><br><span class="line">                    mk_timer_cancel(rlm-&gt;_timerPort, &amp;dummy);</span><br><span class="line">                    rlm-&gt;_mkTimerArmed = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">// Arm the dispatch timer</span></span><br><span class="line">                _dispatch_source_set_runloop_timer_4CF(rlm-&gt;_timerSource, </span><br><span class="line">    deadline, DISPATCH_TIME_FOREVER, leeway);</span><br><span class="line">                rlm-&gt;_dispatchTimerArmed = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//mk timer，实际中是这种情况</span></span><br><span class="line">                <span class="comment">// Cancel the dispatch timer</span></span><br><span class="line">                <span class="keyword">if</span> (rlm-&gt;_dispatchTimerArmed) &#123;</span><br><span class="line">                    <span class="comment">// Cancel the dispatch timer</span></span><br><span class="line">                    _dispatch_source_set_runloop_timer_4CF(rlm-&gt;_timerSource, </span><br><span class="line">    DISPATCH_TIME_FOREVER, DISPATCH_TIME_FOREVER, <span class="number">888</span>);</span><br><span class="line">                    rlm-&gt;_dispatchTimerArmed = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">// Arm the mk timer</span></span><br><span class="line">                <span class="keyword">if</span> (rlm-&gt;_timerPort) &#123;</span><br><span class="line"><span class="comment">//timer开始运行</span></span><br><span class="line">                    mk_timer_arm(rlm-&gt;_timerPort, __CFUInt64ToAbsoluteTime(</span><br><span class="line">    nextSoftDeadline));</span><br><span class="line">                    rlm-&gt;_mkTimerArmed = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            _dispatch_source_set_runloop_timer_4CF(rlm-&gt;_timerSource, deadline,</span><br><span class="line"> DISPATCH_TIME_FOREVER, leeway);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">if</span> (rlm-&gt;_timerPort) &#123;</span><br><span class="line">                mk_timer_arm(rlm-&gt;_timerPort, __CFUInt64ToAbsoluteTime(</span><br><span class="line">    nextSoftDeadline));</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextSoftDeadline == UINT64_MAX) &#123;</span><br><span class="line">            <span class="comment">// Disarm the timers - there is no timer scheduled</span></span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span> (rlm-&gt;_mkTimerArmed &amp;&amp; rlm-&gt;_timerPort) &#123;</span><br><span class="line">                AbsoluteTime dummy;</span><br><span class="line">                mk_timer_cancel(rlm-&gt;_timerPort, &amp;dummy);</span><br><span class="line">                rlm-&gt;_mkTimerArmed = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span></span><br><span class="line">            <span class="keyword">if</span> (rlm-&gt;_dispatchTimerArmed) &#123;</span><br><span class="line">                _dispatch_source_set_runloop_timer_4CF(rlm-&gt;_timerSource, </span><br><span class="line">    DISPATCH_TIME_FOREVER, DISPATCH_TIME_FOREVER, <span class="number">333</span>);</span><br><span class="line">                rlm-&gt;_dispatchTimerArmed = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rlm-&gt;_timerHardDeadline = nextHardDeadline;</span><br><span class="line">    rlm-&gt;_timerSoftDeadline = nextSoftDeadline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>_CFRunLoopGet0</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(<span class="keyword">pthread_t</span> t) &#123;</span><br><span class="line">    <span class="comment">//判断t是否是传的空，如果是当成主线程处理</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_equal(t, kNilPthreadT)) &#123;</span><br><span class="line">        t = pthread_main_thread_np();</span><br><span class="line">    &#125;</span><br><span class="line">    __CFSpinLock(&amp;loopsLock);</span><br><span class="line"><span class="comment">//__CFRunLoops是全局存储线程和runloop关系的字典</span></span><br><span class="line">    <span class="keyword">if</span> (!__CFRunLoops) &#123;</span><br><span class="line"><span class="comment">//__CFRunLoop第一次初始化</span></span><br><span class="line">        __CFSpinUnlock(&amp;loopsLock);</span><br><span class="line"><span class="comment">//初始化__CFRunLoop</span></span><br><span class="line">    CFMutableDictionaryRef dict = CFDictionaryCreateMutable(</span><br><span class="line">        kCFAllocatorSystemDefault, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line"><span class="comment">//生成主线程对应runloop</span></span><br><span class="line">    CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</span><br><span class="line"><span class="comment">//存储到__CFRunLoop字典中</span></span><br><span class="line">    CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</span><br><span class="line">    <span class="keyword">if</span> (!OSAtomicCompareAndSwapPtrBarrier(<span class="literal">NULL</span>, dict, (<span class="keyword">void</span> * <span class="keyword">volatile</span> *)&amp;</span><br><span class="line">    __CFRunLoops)) &#123;</span><br><span class="line">        CFRelease(dict);</span><br><span class="line">    &#125;</span><br><span class="line">    CFRelease(mainLoop);</span><br><span class="line">        __CFSpinLock(&amp;loopsLock);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//找到线程t对应的runloop</span></span><br><span class="line">    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, </span><br><span class="line">        pthreadPointer(t));</span><br><span class="line">    __CFSpinUnlock(&amp;loopsLock);</span><br><span class="line">    <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line"><span class="comment">//没有找到，创建一个</span></span><br><span class="line">    CFRunLoopRef newLoop = __CFRunLoopCreate(t);</span><br><span class="line">        __CFSpinLock(&amp;loopsLock);</span><br><span class="line"><span class="comment">//??????</span></span><br><span class="line">    loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">    <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line"><span class="comment">//保存到全局字典中</span></span><br><span class="line">        CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);</span><br><span class="line">        loop = newLoop;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// don't release run loops inside the loopsLock, because </span></span><br><span class="line">        <span class="comment">//CFRunLoopDeallocate may end up taking it --&gt; --&gt;</span></span><br><span class="line">        __CFSpinUnlock(&amp;loopsLock);</span><br><span class="line">    CFRelease(newLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pthread_equal(t, pthread_self())) &#123;</span><br><span class="line">        _CFSetTSD(__CFTSDKeyRunLoop, (<span class="keyword">void</span> *)loop, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</span><br><span class="line">            _CFSetTSD(__CFTSDKeyRunLoopCntr, (<span class="keyword">void</span> *)(</span><br><span class="line">                PTHREAD_DESTRUCTOR_ITERATIONS<span class="number">-1</span>), (<span class="keyword">void</span> (*)(<span class="keyword">void</span> *))</span><br><span class="line">                __CFFinalizeRunLoop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;__CFRunLoopMode&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; __&lt;span class=&quot;title&quot;&gt;CFRunLoopMode&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CFRuntimeBase _base;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;pthread_mutex_t&lt;/span&gt; _lock;  &lt;span class=&quot;comment&quot;&gt;/* must have the run loop locked before locking &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    this */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//mode名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CFStringRef _name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Boolean _stopped;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; _padding[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//source0 源&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CFMutableSetRef _sources0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//source1 源&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CFMutableSetRef _sources1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//observer 源&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CFMutableArrayRef _observers;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//timer 源&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CFMutableArrayRef _timers;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//mach port 到 mode的映射,为了在runloop主逻辑中过滤runloop自己的port消息。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CFMutableDictionaryRef _portToV1SourceMap;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//记录了所有当前mode中需要监听的port，作为调用监听消息函数的参数。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __CFPortSet _portSet;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CFIndex _observerMask;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;if&lt;/span&gt; USE_DISPATCH_SOURCE_FOR_TIMERS&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;dispatch_source_t&lt;/span&gt; _timerSource;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;dispatch_queue_t&lt;/span&gt; _queue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Boolean _timerFired; &lt;span class=&quot;comment&quot;&gt;// set to true by the source when a timer has fired&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Boolean _dispatchTimerArmed;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;if&lt;/span&gt; USE_MK_TIMER_TOO&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//使用 mk timer， 用到的mach port，和source1类似，都依赖于mach port&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;mach_port_t&lt;/span&gt; _timerPort;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Boolean _mkTimerArmed;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//timer触发的理想时间&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint64_t&lt;/span&gt; _timerSoftDeadline; &lt;span class=&quot;comment&quot;&gt;/* TSR */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//timer触发的实际时间，理想时间加上tolerance（偏差）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint64_t&lt;/span&gt; _timerHardDeadline; &lt;span class=&quot;comment&quot;&gt;/* TSR */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>RunLoop介绍</title>
    <link href="http://yoursite.com/2016/01/26/RunLoop%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2016/01/26/RunLoop介绍/</id>
    <published>2016-01-26T09:01:31.000Z</published>
    <updated>2018-08-06T04:03:34.830Z</updated>
    
    <content type="html"><![CDATA[<h3 id="RunLoop-的概念"><a href="#RunLoop-的概念" class="headerlink" title="RunLoop 的概念"></a><strong>RunLoop 的概念</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    initialize();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var message = get_next_message();</span><br><span class="line">        process_message(message);</span><br><span class="line">    &#125; <span class="keyword">while</span> (message != quit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="RunLoop-与线程的关系"><a href="#RunLoop-与线程的关系" class="headerlink" title="RunLoop 与线程的关系"></a><strong>RunLoop 与线程的关系</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef</span></span><br><span class="line"><span class="keyword">static</span> CFMutableDictionaryRef loopsDic;</span><br><span class="line"><span class="comment">/// 访问 loopsDic 时的锁</span></span><br><span class="line"><span class="keyword">static</span> CFSpinLock_t loopsLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 获取一个 pthread 对应的 RunLoop。</span></span><br><span class="line">CFRunLoopRef _CFRunLoopGet(<span class="keyword">pthread_t</span> thread) &#123;</span><br><span class="line">    OSSpinLockLock(&amp;loopsLock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!loopsDic) &#123;</span><br><span class="line">        <span class="comment">// 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。</span></span><br><span class="line">        loopsDic = CFDictionaryCreateMutable();</span><br><span class="line">        CFRunLoopRef mainLoop = _CFRunLoopCreate();</span><br><span class="line">        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 直接从 Dictionary 里获取。</span></span><br><span class="line">    CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line">        <span class="comment">/// 取不到时，创建一个</span></span><br><span class="line">        loop = _CFRunLoopCreate();</span><br><span class="line">        CFDictionarySetValue(loopsDic, thread, loop);</span><br><span class="line">        <span class="comment">/// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。</span></span><br><span class="line">        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OSSpinLockUnLock(&amp;loopsLock);</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">CFRunLoopRef <span class="title">CFRunLoopGetMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _CFRunLoopGet(pthread_main_thread_np());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">CFRunLoopRef <span class="title">CFRunLoopGetCurrent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _CFRunLoopGet(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RunLoop核心数据结构"><a href="#RunLoop核心数据结构" class="headerlink" title="RunLoop核心数据结构"></a>RunLoop核心数据结构</h3><ul><li>CFRunLoopRef</li></ul><ul><li>CFRunLoopModeRef</li><li>CFRunLoopSourceRef</li><li>CFRunLoopTimerRef</li><li>CFRunLoopObserverRef</li></ul><p><img src="http://7xqgnx.com1.z0.glb.clouddn.com/MomaTechRunloop%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="Runloop"></p><p>CFRunLoop中包含多个CFRunLoopMode对象，每个CFRunLoopMode对象都可以包含Source(Set)，Oberserver(Array)，Timer(Array)对象集合.</p><p>CFRunLoopSourceRef：</p><p><em>source0</em> : 包含了一个函数指针。 CFRunLoopSourceSignal(source) CFRunLoopWakeUp(runloop)  手动唤醒线程runloop</p><p><em>source1</em> ：基于Mach Port ,包含了一个函数指针和一个MachPort端口，能主动唤醒线程runloop。</p><p><em>CFRunLoopTimerRef</em>：也跟machPort有点关系，其实它是通过mk_timer实现的。</p><p><em>CFRunLoopObserverRef</em>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</span><br><span class="line">    kCFRunLoopEntry         = (<span class="number">1U</span>L &lt;&lt; <span class="number">0</span>), <span class="comment">// 即将进入Loop</span></span><br><span class="line">    kCFRunLoopBeforeTimers  = (<span class="number">1U</span>L &lt;&lt; <span class="number">1</span>), <span class="comment">// 即将处理 Timer</span></span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1U</span>L &lt;&lt; <span class="number">2</span>), <span class="comment">// 即将处理 Source</span></span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">5</span>), <span class="comment">// 即将进入休眠</span></span><br><span class="line">    kCFRunLoopAfterWaiting  = (<span class="number">1U</span>L &lt;&lt; <span class="number">6</span>), <span class="comment">// 刚从休眠中唤醒</span></span><br><span class="line">    kCFRunLoopExit          = (<span class="number">1U</span>L &lt;&lt; <span class="number">7</span>), <span class="comment">// 即将退出Loop</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>RunLoop 和 RunloopMode</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span> &#123;</span></span><br><span class="line">    CFStringRef _name;            <span class="comment">// Mode Name, 例如 @"kCFRunLoopDefaultMode"</span></span><br><span class="line">    CFMutableSetRef _sources0;    <span class="comment">// Set</span></span><br><span class="line">    CFMutableSetRef _sources1;    <span class="comment">// Set</span></span><br><span class="line">    CFMutableArrayRef _observers; <span class="comment">// Array</span></span><br><span class="line">    CFMutableArrayRef _timers;    <span class="comment">// Array</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoop</span> &#123;</span></span><br><span class="line">    CFMutableSetRef _commonModes;     <span class="comment">// Set</span></span><br><span class="line">    CFMutableSetRef _commonModeItems; <span class="comment">// Set</span></span><br><span class="line">    CFRunLoopModeRef _currentMode;    <span class="comment">// Current Runloop Mode</span></span><br><span class="line">    CFMutableSetRef _modes;           <span class="comment">// Set</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Runloop内部循环的逻辑"><a href="#Runloop内部循环的逻辑" class="headerlink" title="Runloop内部循环的逻辑"></a>Runloop内部循环的逻辑</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// RunLoop的实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CFRunLoopRunSpecific</span><span class="params">(runloop, modeName, seconds, stopAfterHandle)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 首先根据modeName找到对应mode</span></span><br><span class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">/// 如果mode里没有source/timer/observer, 直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(currentMode)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 1. 通知 Observers: RunLoop 即将进入 loop。</span></span><br><span class="line">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 内部函数，进入loop</span></span><br><span class="line">    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</span><br><span class="line"></span><br><span class="line">        Boolean sourceHandledThisLoop = NO;</span><br><span class="line">        <span class="keyword">int</span> retVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span></span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class="line">            <span class="comment">/// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span></span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class="line">            <span class="comment">/// 执行被加入的block</span></span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// 4. RunLoop 触发 Source0 (非port) 回调。</span></span><br><span class="line">            sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);</span><br><span class="line">            <span class="comment">/// 执行被加入的block</span></span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span></span><br><span class="line">            <span class="keyword">if</span> (__Source0DidDispatchPortLastTime) &#123;</span><br><span class="line">                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)</span><br><span class="line">                <span class="keyword">if</span> (hasMsg) <span class="keyword">goto</span> handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// 通知 Observers: RunLoop 的线程进入休眠(sleep)。</span></span><br><span class="line">            <span class="keyword">if</span> (!sourceHandledThisLoop) &#123;</span><br><span class="line">                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span></span><br><span class="line">            <span class="comment">/// ? 一个基于 port 的Source 的事件。</span></span><br><span class="line">            <span class="comment">/// ? 一个 Timer 到时间了</span></span><br><span class="line">            <span class="comment">/// ? RunLoop 自身的超时时间到了</span></span><br><span class="line">            <span class="comment">/// ? 被其他什么调用者手动唤醒</span></span><br><span class="line">            mach_msg(msg, MACH_RCV_MSG, port); <span class="comment">// thread wait for receive msg</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span></span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// 收到消息，处理消息。</span></span><br><span class="line">            handle_msg:</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span></span><br><span class="line">            <span class="keyword">if</span> (msg_is_timer) &#123;</span><br><span class="line">                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            <span class="comment">/// 9.2 如果有dispatch到main_queue的block，执行block。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (msg_is_dispatch) &#123;</span><br><span class="line">                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            <span class="comment">/// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</span><br><span class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</span><br><span class="line">                <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">                    mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// 执行加入到Loop的block</span></span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">                <span class="comment">/// 进入loop时参数说处理完事件就返回。</span></span><br><span class="line">                retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">                <span class="comment">/// 超出传入参数标记的超时时间了</span></span><br><span class="line">                retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(runloop)) &#123;</span><br><span class="line">                <span class="comment">/// 被外部调用者强制停止了</span></span><br><span class="line">                retVal = kCFRunLoopRunStopped;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</span><br><span class="line">                <span class="comment">/// source/timer/observer一个都没有了</span></span><br><span class="line">                retVal = kCFRunLoopRunFinished;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (retVal == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 10. 通知 Observers: RunLoop 即将退出。</span></span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下图所示：</p><p><img src="http://7xqgnx.com1.z0.glb.clouddn.com/MomaTechRunloop%E5%BE%AA%E7%8E%AF%E9%80%BB%E8%BE%91.png" alt="循环"></p><p>这里等待唤醒的时候是通过Source1去实现的，所以这张图有问题。</p><h4 id="mach-msg"><a href="#mach-msg" class="headerlink" title="mach_msg"></a>mach_msg</h4><p><img src="http://7xqgnx.com1.z0.glb.clouddn.com/MomaTech%E5%86%85%E6%A0%B8%E7%BB%93%E6%9E%84.png" alt="内核"></p><p>OKit 层是为设备驱动提供了一个面向对象(C++)的一个框架。</p><p>BSD 层可以看作围绕 Mach 层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。</p><p>Mach 有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为”对象”。和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。”消息”是 Mach 中最基础的概念，消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。</p><p><img src="http://7xqgnx.com1.z0.glb.clouddn.com/MomaTechmach_msg.png" alt="mach_msg"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;RunLoop-的概念&quot;&gt;&lt;a href=&quot;#RunLoop-的概念&quot; class=&quot;headerlink&quot; title=&quot;RunLoop 的概念&quot;&gt;&lt;/a&gt;&lt;strong&gt;RunLoop 的概念&lt;/strong&gt;&lt;/h3&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;function &lt;span class=&quot;title&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    initialize();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var message = get_next_message();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        process_message(message);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (message != quit);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>hexo+github搭建博客</title>
    <link href="http://yoursite.com/2016/01/26/hexo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2016/01/26/hexo-github搭建博客/</id>
    <published>2016-01-26T07:00:42.000Z</published>
    <updated>2018-08-06T04:03:34.825Z</updated>
    
    <content type="html"><![CDATA[<p>前提环境：node.js git</p><h4 id="1-hexo安装"><a href="#1-hexo安装" class="headerlink" title="1.hexo安装"></a>1.hexo安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir MyBlog</span><br><span class="line">cd MyBlog</span><br><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>这个时候应该在console会显示：</p><p> Hexo is running at <a href="http://0.0.0.0:4000/" target="_blank" rel="noopener">http://0.0.0.0:4000/</a>.</p><p>这个时候直接访问该地址，即部署到本地的博客：</p><p><img src="http://7xqgnx.com1.z0.glb.clouddn.com/localBlog.png" alt="本地hexo博客"></p><a id="more"></a><h3 id="2-公钥和私钥生成及其配置"><a href="#2-公钥和私钥生成及其配置" class="headerlink" title="2.公钥和私钥生成及其配置"></a>2.公钥和私钥生成及其配置</h3><p>进入~/.ssh目录，目录中可能已经存在其他公钥和私钥对，现在要专门添加一个新的公私钥对。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//以指定名称生成公私钥对</span><br><span class="line">ssh-keygen -t rsa -C "B" -f B</span><br></pre></td></tr></table></figure><p>然后将公钥添加到github账号下</p><p>这个时候，.ssh目录下应该有多对公私钥，现在查看密钥列表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add -l</span><br></pre></td></tr></table></figure><p>密钥列表里面应该没有刚才新建的密钥，现在将它添加进去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add ~/.ssh/B</span><br></pre></td></tr></table></figure><p>然后再使用ssh-add -l 发现已经添加了，A是我之前添加的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2048 ac:51:8d:fc:1e:6f:07:ca:3b:3d:c7:0b:79:ee:a1:27 A (RSA)</span><br><span class="line">2048 73:81:8f:03:04:7e:56:a0:cf:22:98:52:47:12:ee:3b /Users/user/.ssh/B (RSA)</span><br></pre></td></tr></table></figure><p>现在.ssh目录中就了2对连接github.com的公私钥对，现在通过.ssh下config文件去配置host，在不同的情况下通过对应的公私钥对连接github，配置如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Host github</span><br><span class="line">     HostName github.com</span><br><span class="line">     User git</span><br><span class="line">     IdentityFile ~/.ssh/A</span><br><span class="line">Host myBlog</span><br><span class="line">     HostName github.com</span><br><span class="line">     User git</span><br><span class="line">     IdentityFile ~/.ssh/B</span><br></pre></td></tr></table></figure><p>然后通过如下方式，确认以私钥B连接到github</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@myBlog</span><br></pre></td></tr></table></figure><p>输出：</p><p>Hi yourName! You’ve successfully authenticated, but GitHub does not provide shell access.</p><p>说明已经成功</p><h4 id="3-在github上新建repo，以yourName-github-io方式命名-必须-，youName是github上的账号名称。"><a href="#3-在github上新建repo，以yourName-github-io方式命名-必须-，youName是github上的账号名称。" class="headerlink" title="3.在github上新建repo，以yourName.github.io方式命名(必须)，youName是github上的账号名称。"></a>3.在github上新建repo，以yourName.github.io方式命名(必须)，youName是github上的账号名称。</h4><h4 id="4-配置hexo部署到github"><a href="#4-配置hexo部署到github" class="headerlink" title="4.配置hexo部署到github"></a>4.配置hexo部署到github</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim _config.yml</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@myBlog:yourName/yourName.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>hexo配置文件的语法是冒号后面必须有空格，否则在之后部署的时候会报错。</p><p>然后执行如下命令，安装git部署的工具:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>最后生成静态文件并部署：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>访问yourName.github.io可以查看最后部署到github上的效果</p><h4 id="问题解答："><a href="#问题解答：" class="headerlink" title="问题解答："></a>问题解答：</h4><p>1.执行hexo g -d的时候，遇到:</p><p>Error: Permission denied(publickey).</p><p>fatal: Could not read from remote repository</p><p>解决办法：</p><p>1.先看一下.ssh目录下的配置文件config</p><p>cd ~/.ssh</p><p>vim config</p><p>看一下host 别名配置的是什么，比如</p><p>Host github</p><p>​         HostName github.com</p><p>​         user git</p><p>​         IdentityFile ~/.ssh/zhengzhiwenBlog</p><p>host的别名就是github</p><p>通过ssh -T git@github 看一下是否能够连接，如果不能连接，说明github账号下没有配置公钥，先去github上配置公钥</p><p>2.确定可以通过ssh连接github之后：</p><p>查看一下系统ssh-key的代理：</p><p>ssh-add -l</p><p>如果出现 The agent has no identities。说明没有代理，需要添加，按上文中提到的方式：</p><p>ssh-add ~/.ssh/zhengzhiwenBlog</p><p>得到提示：</p><p>Identity added: /Users/zhengzhiwen/.ssh/moma (/Users/zhengzhiwen/.ssh/zhengzhiwenBlog)</p><p>说明添加成功</p><p>再试试hexo g -d命令，进行部署。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前提环境：node.js git&lt;/p&gt;
&lt;h4 id=&quot;1-hexo安装&quot;&gt;&lt;a href=&quot;#1-hexo安装&quot; class=&quot;headerlink&quot; title=&quot;1.hexo安装&quot;&gt;&lt;/a&gt;1.hexo安装&lt;/h4&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mkdir MyBlog&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd MyBlog&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-cli -g&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo init&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个时候应该在console会显示：&lt;/p&gt;
&lt;p&gt; Hexo is running at &lt;a href=&quot;http://0.0.0.0:4000/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://0.0.0.0:4000/&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;这个时候直接访问该地址，即部署到本地的博客：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xqgnx.com1.z0.glb.clouddn.com/localBlog.png&quot; alt=&quot;本地hexo博客&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Runloop和多线程</title>
    <link href="http://yoursite.com/2016/01/25/Runloop%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2016/01/25/Runloop和多线程/</id>
    <published>2016-01-25T08:49:34.000Z</published>
    <updated>2018-08-06T04:03:34.830Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="http://huanshijiushiniu.github.io/2016/01/26/RunLoop%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener">CFRunloop</a>中已经说明了一个线程及其runloop的对应关系 ，现在以iOS中NSThread的实际使用来说明runloop在线程中的意义。</p><a id="more"></a> <p>在iOS中直接使用NSThread有一下几种方式，但是归根到底，当一个线程需要长时间的去跟踪一个任务的时候，这几种方式做的事情是一样的，只不过接口名称和参数不一样，感觉是为了使用起来更加方便。因为这些接口内部都需要依赖runloop去实现事件的监听，这个可以通过调用堆栈证实。</p><p><code>- (void)performSelectorInBackground:(SEL)aSelector withObject:(id)arg</code></p><p><code>- (void)performSelector:(SEL)aSelector onThread:(NSThread*)thr withObject:(id)arg waitUntilDone:(BOOL)wait</code></p><p>以上两个方法都是NSObject的方法，可以直接通过一个对象来创建一个线程。第二个方法具有更多的灵活性，它可以让你自己指定线程，第一个方法是自己默认创建一个线程。第二个方法的最后一个参数是指定是否等待aSelector执行完毕。</p><p><code>+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(id)argument;</code></p><p>该方法是NSThread的类方法，跟第一个方法是类似的功能。</p><p>下面通过在子线程发起一个网络请求，去发现一些问题，然后通过runloop去解释原因，并推测API背后的实现方式。</p><p><strong>代码1</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> performSelectorInBackground:<span class="keyword">@selector</span>(multiThread) withObject:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)multiThread</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (![<span class="built_in">NSThread</span> isMainThread]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.request = [[<span class="built_in">NSMutableURLRequest</span> alloc]</span><br><span class="line"></span><br><span class="line">                                        initWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"</span></span><br><span class="line"><span class="string">                                        http://www.baidu.com"</span>]</span><br><span class="line"></span><br><span class="line">                                        cachePolicy:<span class="built_in">NSURLCacheStorageNotAllowed</span></span><br><span class="line"></span><br><span class="line">                                        timeoutInterval:<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        [<span class="keyword">self</span>.request setHTTPMethod: <span class="string">@"GET"</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.connection =[[<span class="built_in">NSURLConnection</span> alloc] initWithRequest:<span class="keyword">self</span>.request</span><br><span class="line"></span><br><span class="line">                                                         delegate:<span class="keyword">self</span></span><br><span class="line"></span><br><span class="line">                                                 startImmediately:<span class="literal">YES</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"network callback"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后，可以发现在子线程中发起的网络请求，回调没有被调用。根据<a href="http://huanshijiushiniu.github.io/2016/01/26/RunLoop%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener">CFRunloop</a>介绍的知识可以大致猜测可能跟runloop有关系，也就是子线程的runloop中没有注册网络回调的消息，所以该子线程自己相关的runloop没有收到回调。实际上     </p><p><code>- (instancetype)initWithRequest:(NSURLRequest *)request delegate:(id)delegate startImmediately:(BOOL)</code></p><p> 这个方法的第三个参数的bool值表示是否在创建完NSURLConnection对象之后立刻发起请求，一般情况下是YES，什么时候会传NO呢。</p><p>事实上，对于以上这种方式创建的线程，默认是没有生成该线程对应的runloop的。也就是说这种情况下，需要自己去创建对应线程的runloop，并且让他run起来，去不断监听各种往runloop里注册的消息。但是对于主线程而言，其对应的runloop会由系统建立，并且自己run起来。由于平时工作在主线程下，这些工作大部分情况下不需要人为参与，所以一到子线程就会有各种问题。子线程中起timer没有生效也是相同的原因。所以以上函数第三个参数的意思就是，如果是当前线程已经runloop跑起来的情况下，传YES。除此之外，需要自己创建runloop去run，再将网络请求消息注册到runloop中。</p><p>现在根据以上分析修改代码：</p><p><strong>代码2</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.request = [[<span class="built_in">NSMutableURLRequest</span> alloc]</span><br><span class="line"></span><br><span class="line">                                initWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://</span></span><br><span class="line"><span class="string">                                www.baidu.com"</span>]</span><br><span class="line"></span><br><span class="line">                                cachePolicy:<span class="built_in">NSURLCacheStorageNotAllowed</span></span><br><span class="line"></span><br><span class="line">                                timeoutInterval:<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.request setHTTPMethod: <span class="string">@"GET"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.connection =[[<span class="built_in">NSURLConnection</span> alloc] initWithRequest:<span class="keyword">self</span>.request</span><br><span class="line"></span><br><span class="line">                                                 delegate:<span class="keyword">self</span></span><br><span class="line"></span><br><span class="line">                                         startImmediately:<span class="literal">NO</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line"></span><br><span class="line">[runLoop run];</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.connection scheduleInRunLoop:[<span class="built_in">NSRunLoop</span> currentRunLoop] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.connection start];</span><br></pre></td></tr></table></figure><p><strong>代码3</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.request = [[<span class="built_in">NSMutableURLRequest</span> alloc]</span><br><span class="line"></span><br><span class="line">                                initWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://</span></span><br><span class="line"><span class="string">                                www.baidu.com"</span>]</span><br><span class="line"></span><br><span class="line">                                cachePolicy:<span class="built_in">NSURLCacheStorageNotAllowed</span></span><br><span class="line"></span><br><span class="line">                                timeoutInterval:<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.request setHTTPMethod: <span class="string">@"GET"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.connection =[[<span class="built_in">NSURLConnection</span> alloc] initWithRequest:<span class="keyword">self</span>.request</span><br><span class="line"></span><br><span class="line">                                                 delegate:<span class="keyword">self</span></span><br><span class="line"></span><br><span class="line">                                         startImmediately:<span class="literal">NO</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.connection scheduleInRunLoop:[<span class="built_in">NSRunLoop</span> currentRunLoop] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.connection start];</span><br><span class="line"></span><br><span class="line">[runLoop run];</span><br></pre></td></tr></table></figure><p>然后就发现网络回调被调用了。</p><p>之后分析了一下调用堆栈：</p><p>第一个：在multiThread里面是这样的：</p><p><img src="http://7xqgnx.com1.z0.glb.clouddn.com/MomaTechmultiThread.png" alt="multiThread.png"></p><p>第二个：网络回调里面是这样的：</p><p><img src="http://7xqgnx.com1.z0.glb.clouddn.com/MomaTech%E7%BD%91%E7%BB%9C%E5%9B%9E%E8%B0%83.png" alt="网络回调.png"></p><p>通过堆栈可以得知，这两个函数都是由线程6调用的，也就是创建的子线程，也就是创建的子线程，但是堆栈中的内容很不一样。很显然第二个是从runloop 调出的，并且是Sources0这个消息调出的。而第一个是线程运行时候的初始化方法。所以当调用runloop run的时候，其实是线程进入自己的runloop去监听时间了，从此以后，所有的代码都会从runloop CALLOUT出来。所以这种情况下，需要把先把消息注册到runloop中，让runloop跑起来是最后需要做的事情。</p><p>以下是开源库AFNetworking网络请求的实现：</p><p><strong>AFNetworking</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)start &#123;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isCancelled]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(cancelConnection) onThread:[[<span class="keyword">self</span> <span class="keyword">class</span></span><br><span class="line">        ] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span>.</span><br><span class="line">        runLoopModes allObjects]];</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span> isReady]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.state = AFOperationExecutingState;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(operationDidStart) onThread:[[<span class="keyword">self</span> </span><br><span class="line">        <span class="keyword">class</span>] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[</span><br><span class="line">        <span class="keyword">self</span>.runLoopModes allObjects]];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="keyword">void</span>)networkRequestThreadEntryPoint:(<span class="keyword">id</span>)__unused object &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [[<span class="built_in">NSThread</span> currentThread] setName:<span class="string">@"AFNetworking"</span>];</span><br><span class="line">        <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">        [runLoop addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSThread</span> *)networkRequestThread &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSThread</span> *_networkRequestThread = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> oncePredicate;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _networkRequestThread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:</span><br><span class="line">        <span class="keyword">@selector</span>(networkRequestThreadEntryPoint:) object:<span class="literal">nil</span>];</span><br><span class="line">        [_networkRequestThread start];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _networkRequestThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AFNetworking使用的是</p><p><code>- (void)performSelector:(SEL)aSelector onThread:(NSThread\*)thr withObject:(id)arg waitUntilDone:(BOOL)wait</code></p><p>这个方法，但是为什么它没有使用</p><p><code>- (void)performSelectorInBackground:(SEL)aSelector withObject:(id)arg</code></p><p>这个方法呢？</p><p>通过断点，发现了AFNetwokring网络请求中一些函数的调用顺序：</p><p>1.networkRequestThread</p><p>2.networkRequestThreadEntryPoint</p><p>3.operationDidStart</p><p>为什么operationDidStart会在networkRequestThreadEntryPoint之后调用？</p><p>在networkRequestThreadEntryPoint里主要是生成网络线程的runloop并且让它跑起来，里面的  </p><p><code>[runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]</code></p><p>这主要是为了在没有任何网络请求的时候让网络线程保持监听状态，否则网络线程的loop会直接返回，之后再调用网络线程请求就没有意义了。再结合调用堆栈，发现operationDidStart是在runloop callout出来的，而networkRequestThreadEntryPoint是网络线程的入口方法。这跟之前的例子是一样的。所以，我猜测</p><p><code>- (void)performSelector:(SEL)aSelector onThread:(NSThread\*)thr withObject:(id)arg waitUntilDone:(BOOL)wait</code></p><p>这个方法背后是由主线程将aSelector作为消息注册到runloop中时间发生在networkRequestThreadEntryPoint方法调用之前，所以在networkRequestThreadEntryPoint方法中调用 。 NSRunLoop currentRunLoop的时候其实runloop本身应该已经被创建了。原因是因为在这个地方断点 ，打印runloop对象可以发现里面已经注册了source0的消息，如下截图：</p><p><img src="http://7xqgnx.com1.z0.glb.clouddn.com/MomaTechcurrentRunloop.png" alt="currentRunloop.png"></p><p>也就是说父线程在</p><p><code>- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait**函数中将aSelector</code></p><p>注册成source0，这是该函数背后的大致实现。通过查阅apple官方文档，基本属实，如下所示：</p><p><img src="http://7xqgnx.com1.z0.glb.clouddn.com/MomaTech%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3.png" alt="官方文档.png"></p><p>通过上面的分析，可以得出使用<strong>performSelector</strong>方法可以将子线程runloop的初始化实现在子线程的初始化方法里实现，如果使用<code>performSelectorInBackground</code></p><p>方法，那么子线程runloop的初始化和业务逻辑就会混到一起，并且每一次都会重新初始化。AFNetworking通过一个静态全局的子线程去管理所有的网络请求，其对应的runloop也只需要初始化一次。</p><p>通过以上分析，可以知道如果需要让一个子线程去持续的监听时间，就需要启动它的runloop并且忘其中注册source，timer，oberserver三者之一的消息类型。在默认情况下子线程的runloop是不会自己创建和启动的。</p><h2 id="线程之间的通讯：NSMachPort"><a href="#线程之间的通讯：NSMachPort" class="headerlink" title="线程之间的通讯：NSMachPort"></a>线程之间的通讯：NSMachPort</h2><p>NSNotificationCenter是iOS中全局的观察者，可以用于不同页面之间消息传递解耦。</p><p>先看一段代码：</p><p><strong>代码1</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"current thread = %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(</span><br><span class="line">        handleNotification:) name:TEST_NOTIFICATION object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span></span><br><span class="line">        ), ^&#123;</span><br><span class="line"></span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:TEST_NOTIFICATION object:<span class="literal">nil</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)handleNotification:(<span class="built_in">NSNotification</span> *)notification</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"current thread = %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"test notification"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>输出如下：</p><p><strong>输出</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">current thread = &lt;NSThread: <span class="number">0x7fbb23412f30</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line">current thread = &lt;NSThread: <span class="number">0x7fbb23552370</span>&gt;&#123;number = <span class="number">2</span>, name = (null)&#125;</span><br><span class="line">test[<span class="number">865</span>:<span class="number">45174</span>] test notification</span><br></pre></td></tr></table></figure><p>在主线程中注册了一个通知，在子线程中抛出事件，最后在子线程中处理事件。</p><p>但是有些时候，可能需要在同一个线程中处理事件，比如更新UI的操作只能放到主线程中进行。所以，需要做一次线程之间消息的转发。如果是子线程往主线程转发，通过GCD即可实现。但是如果是任意两个线程之间通讯，则需要依赖NSMachPort通过它往目标线程的runloop中注册事件来完成。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> () &lt;<span class="title">NSMachPortDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSMutableArray</span>    *notifications;         <span class="comment">// 通知队列</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSThread</span>          *notificationThread;    <span class="comment">// 期望线程</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSLock</span>            *notificationLock;      <span class="comment">// 用于对通知队列加锁的锁对象，避免线程冲突</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSMachPort</span>        *notificationPort;      <span class="comment">// 用于向期望线程发送信号的通信端口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"current thread = %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">self</span>.notifications = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.notificationLock = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.notificationThread = [<span class="built_in">NSThread</span> currentThread];</span><br><span class="line">    <span class="keyword">self</span>.notificationPort = [[<span class="built_in">NSMachPort</span> alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.notificationPort.delegate = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往当前线程的run loop添加端口源</span></span><br><span class="line">    <span class="comment">// 当Mach消息到达而接收线程的run loop没有运行时，则内核会保存这条消息，直到下一次进入run loop</span></span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:<span class="keyword">self</span>.notificationPort</span><br><span class="line">                                forMode:(__bridge <span class="built_in">NSString</span> *)</span><br><span class="line">                                kCFRunLoopCommonModes];</span><br><span class="line"></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(</span><br><span class="line">        processNotification:) name:<span class="string">@"TestNotification"</span> object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span></span><br><span class="line">        ), ^&#123;</span><br><span class="line"></span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:TEST_NOTIFICATION object:<span class="literal">nil</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NSMacPort回调方法</span></span><br><span class="line">- (<span class="keyword">void</span>)handleMachMessage:(<span class="keyword">void</span> *)msg &#123;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.notificationLock lock];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ([<span class="keyword">self</span>.notifications count]) &#123;</span><br><span class="line">        <span class="built_in">NSNotification</span> *notification = [<span class="keyword">self</span>.notifications objectAtIndex:<span class="number">0</span>];</span><br><span class="line">        [<span class="keyword">self</span>.notifications removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">        [<span class="keyword">self</span>.notificationLock unlock];</span><br><span class="line">        [<span class="keyword">self</span> processNotification:notification];</span><br><span class="line">        [<span class="keyword">self</span>.notificationLock lock];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.notificationLock unlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)processNotification:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSThread</span> currentThread] != _notificationThread) &#123;</span><br><span class="line">        <span class="comment">// Forward the notification to the correct thread.</span></span><br><span class="line">        [<span class="keyword">self</span>.notificationLock lock];</span><br><span class="line">        [<span class="keyword">self</span>.notifications addObject:notification];</span><br><span class="line">        [<span class="keyword">self</span>.notificationLock unlock];</span><br><span class="line">        [<span class="keyword">self</span>.notificationPort sendBeforeDate:[<span class="built_in">NSDate</span> date]</span><br><span class="line">                                   components:<span class="literal">nil</span></span><br><span class="line">                                         from:<span class="literal">nil</span></span><br><span class="line">                                     reserved:<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Process the notification here;</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"current thread = %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"process notification"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>输入如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test[<span class="number">1474</span>:<span class="number">92483</span>] current thread = &lt;NSThread: <span class="number">0x7ffa4070ed50</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line">test[<span class="number">1474</span>:<span class="number">92483</span>] current thread = &lt;NSThread: <span class="number">0x7ffa4070ed50</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line">test[<span class="number">1474</span>:<span class="number">92483</span>] process notification</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;http://huanshijiushiniu.github.io/2016/01/26/RunLoop%E4%BB%8B%E7%BB%8D/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CFRunloop&lt;/a&gt;中已经说明了一个线程及其runloop的对应关系 ，现在以iOS中NSThread的实际使用来说明runloop在线程中的意义。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa2</title>
    <link href="http://yoursite.com/2016/01/25/ReactiveCocoa2/"/>
    <id>http://yoursite.com/2016/01/25/ReactiveCocoa2/</id>
    <published>2016-01-25T08:38:24.000Z</published>
    <updated>2018-08-06T04:03:34.829Z</updated>
    
    <content type="html"><![CDATA[<h3 id="RACCommand"><a href="#RACCommand" class="headerlink" title="RACCommand"></a>RACCommand</h3><p>理解：个人觉得是对RACSignal的封装，侧重于对事件的信号的封装。有了RACComand，就可以把动作通过它很方便的放到ViewModel中，类似于以下这种方式:</p><p>1.在ViewModel中定义RACCommand</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface SubscribeViewModel : NSObject</span><br><span class="line">@property(nonatomic, strong) RACCommand *subscribeCommand;</span><br><span class="line"> </span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>2.在ViewModel中处理具体的RACCommand封装的动作信号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> - (RACCommand *)subscribeCommand &#123;</span><br><span class="line">  if (!_subscribeCommand) &#123;</span><br><span class="line">      NSString *email = self.email;</span><br><span class="line">      _subscribeCommand = [[RACCommand alloc] initWithEnabled:self.</span><br><span class="line">      emailValidSignal signalBlock:^RACSignal *(id input) &#123;</span><br><span class="line">          return [SubscribeViewModel postEmail:email];</span><br><span class="line">      &#125;];</span><br><span class="line">  &#125;</span><br><span class="line">  return _subscribeCommand;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>input参数是在command调用excute方法的时候传进来的。</p><p>3.在ViewController中将ViewModel的RACCommand绑定到控件的事件信号上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.subscribeButton.rac_command = self.viewModel.subscribeCommand;</span><br></pre></td></tr></table></figure><p>如果要对某个行为进行单元测试也非常方便，直接对ViewModel层进行测试就可以了，并且没有任务Uiew层的显示逻辑，纯业务逻辑测起来很方便。如果没有RACCommand，直接通过signal去处理，可能类似这种方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[self.button rac_signalForControlEvents:UIControlEventTouchUpInside]</span><br><span class="line">subscribeNext:^(id x) &#123;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>直接在ViewController中定义了动作的逻辑，没有很好的分离。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_subscribeCommand = [[RACCommand alloc] initWithEnabled:self.emailValidSignal </span><br><span class="line">signalBlock:^RACSignal *(id input) &#123;</span><br><span class="line">      return [SubscribeViewModel postEmail:email];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>signalBlock必须要返回一个信号，不能传nil，如果不想传递信号，则可以创建空的信号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[RACSignal empty]</span><br></pre></td></tr></table></figure><p>RAC</p><p>emailValidSignal用来指定创建的命令是否能够执行，self.emailValidSignal定义如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_emailValidSignal = [RACObserve(self, email) map:^id(NSString *email) &#123;</span><br><span class="line">         return @([email isValidEmail]);</span><br><span class="line">     &#125;];</span><br></pre></td></tr></table></figure><p>当self.emailValidSignal信号返回数据为yes的时候，_subscribeCommand才能够响应行为</p><p>signalBlock是当_subscribeCommand执行的时候会被调用的逻辑，该block返回的是一个包含了命令执行之后结果的signal。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>allowsConcurrentExecution代表当该命令正在执行的时候，是否能够再次触发改命令。</p><p>RACCommand内部是如何通过它去控制当前命令能不能够被执行以及能不能并发的执行:</p><p>以UIButton举例：</p><p><strong>UIButton+RACCommandSupport.m</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//UIButton的enabel和command的enabel绑定起来了，也就是如果command的enabel</span><br><span class="line">//设置未false，那么button则不可用。</span><br><span class="line"> disposable = [command.enabled setKeyPath:@keypath(self.enabled) onObject:self];</span><br></pre></td></tr></table></figure><p>以下是RACCommand中有关allowsConcurrentExecution的源码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if (enabledSignal == nil) &#123;</span><br><span class="line">       enabledSignal = [RACSignal return:@YES];</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       enabledSignal = [[[enabledSignal</span><br><span class="line">           startWith:@YES]</span><br><span class="line">           takeUntil:self.rac_willDeallocSignal]</span><br><span class="line">           replayLast];</span><br><span class="line">   &#125;</span><br><span class="line">   _immediateEnabled = [[RACSignal</span><br><span class="line">       combineLatest:@[ enabledSignal, moreExecutionsAllowed ]]</span><br><span class="line">       and];</span><br><span class="line"> </span><br><span class="line">   _enabled = [[[[[self.immediateEnabled</span><br><span class="line">       take:1]</span><br><span class="line">       concat:[[self.immediateEnabled skip:1] deliverOn:RACScheduler.</span><br><span class="line">       mainThreadScheduler]]</span><br><span class="line">       distinctUntilChanged]</span><br><span class="line">       replayLast]</span><br><span class="line">       setNameWithFormat:@&quot;%@ -enabled&quot;, self];</span><br></pre></td></tr></table></figure><p>整个command是否可用，是由immeditateEnable来决定的，而imediateEnabled是取enableSignal和moreExecutionsAllowed的与操作。</p><p>enableSignal是command初始化方法传进来的第一个参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *immediateExecuting = [RACObserve(self, activeExecutionSignals) map:^</span><br><span class="line">(NSArray *activeSignals) &#123;</span><br><span class="line">        return @(activeSignals.count &gt; 0);</span><br><span class="line">    &#125;];</span><br><span class="line"> </span><br><span class="line">    RACSignal *moreExecutionsAllowed = [RACSignal</span><br><span class="line">        if:RACObserve(self, allowsConcurrentExecution)</span><br><span class="line">        then:[RACSignal return:@YES]</span><br><span class="line">        else:[immediateExecuting not]];</span><br></pre></td></tr></table></figure><p>imediateExecuting是当前正在执行未完成的命令数量的信号，如果command的allowsConcurrentExecution设置的yes，则moreExcutionsAllowed返回yes，反之则取决于有没有正在执行的信号，如果有就返回false，没有返回yes。一个信号是否执行完，根据signal有没有发出complete事件来判断的。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="excute"><a href="#excute" class="headerlink" title="excute"></a>excute</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal =[command execute:@2];</span><br></pre></td></tr></table></figure><p>在command的初始化方法中，有一个signalBlock参数，该block有一个input参数，在command执行excute方法的时候传入的参数被当作signalBlock的input参数传到signalBlock中。比如通常将一个网络请求的封装成一个Command，此时网络请求的参数就可以通过调用excute的时候传入。</p><p>这种情况下，获取command执行之后返回的数据可以通过:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal =[command execute:@2];</span><br><span class="line">// 在这里就可以订阅信号了 </span><br><span class="line">[signal subscribeNext:^(id x) &#123; </span><br><span class="line">    NSLog(@&quot;%@&quot;,x); </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p><strong>订阅命令完成的信号</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[self.viewModel.subscribeCommand execute:nil] subscribeCompleted:^&#123;</span><br><span class="line">  NSLog(@&quot;The command executed&quot;);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="executionSignals"><a href="#executionSignals" class="headerlink" title="executionSignals"></a>executionSignals</h4><p>属于信号中的信号，在subscribeNext中返回的是信号x，再次订阅信号x才能获取具体数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[command.executionSignals subscribeNext:^(RACSignal *x) &#123; </span><br><span class="line">       [x subscribeNext:^(id x) &#123; </span><br><span class="line">           NSLog(@&quot;%@&quot;, x); </span><br><span class="line">       &#125;];</span><br></pre></td></tr></table></figure><p>也可以直接使用excutionSignals.switchToLatest subscribeNext:获取到数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> // 监听登录产生的数据</span><br><span class="line">[_LoginCommand.executionSignals.switchToLatest subscribeNext:^(id x) &#123;</span><br><span class="line"> </span><br><span class="line">    if ([x isEqualToString:@&quot;登录成功&quot;]) &#123;</span><br><span class="line">        NSLog(@&quot;登录成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;RACCommand&quot;&gt;&lt;a href=&quot;#RACCommand&quot; class=&quot;headerlink&quot; title=&quot;RACCommand&quot;&gt;&lt;/a&gt;RACCommand&lt;/h3&gt;&lt;p&gt;理解：个人觉得是对RACSignal的封装，侧重于对事件的信号的封装。有了R
      
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>ReactCocoa源码分析1</title>
    <link href="http://yoursite.com/2016/01/25/ReactCocoa%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901/"/>
    <id>http://yoursite.com/2016/01/25/ReactCocoa源码分析1/</id>
    <published>2016-01-25T08:38:24.000Z</published>
    <updated>2018-08-06T04:03:34.828Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h2><p>在看代码的时候，发现代码中使用到了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidload</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidload];</span><br><span class="line">    [self bindData];</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">- (void)bindData</span><br><span class="line">&#123;</span><br><span class="line">    [[RACObserve(self, propertyA) ignore:nil] </span><br><span class="line">                                 subscribeNext:^(NSArray *dataA) &#123;</span><br><span class="line">        NSLog(@&quot;use dataA&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在这个类的propertyA是在init之后去设置的，在viewDidload之前。也就是在使用RAC订阅属性变化信号之前，但是use dataA打印出来了。猜测RACObserve宏生成信号在调用subscribeNext中，直接就调用了dataA的block的逻辑。但是感觉比较奇怪，不应该是propertyA变化的时候才会调用dataA的block的逻辑吗。</p><p>现在具体看一下，一个信号的创建和订阅的源码：</p><a id="more"></a> <h3 id="信号创建："><a href="#信号创建：" class="headerlink" title="信号创建："></a>信号创建：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))</span><br><span class="line">didSubscribe &#123;</span><br><span class="line"> </span><br><span class="line">    return [RACDynamicSignal createSignal:didSubscribe];</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">+ (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))</span><br><span class="line">didSubscribe &#123;</span><br><span class="line"> </span><br><span class="line">    RACDynamicSignal *signal = [[self alloc] init];</span><br><span class="line"> </span><br><span class="line">    signal-&gt;_didSubscribe = [didSubscribe copy];</span><br><span class="line"> </span><br><span class="line">    return [signal setNameWithFormat:@&quot;+createSignal:&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建一个信号的时候，会传进来一个叫didSubscribe的block，该信号会把它存下来。</p><h3 id="信号订阅"><a href="#信号订阅" class="headerlink" title="信号订阅"></a>信号订阅</h3><p>RACSignal的subscribeNext方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock &#123;</span><br><span class="line">    NSCParameterAssert(nextBlock != NULL);</span><br><span class="line">    RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:NULL completed:NULL];</span><br><span class="line">    return [self subscribe:o];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在singal的subscribeNext中，生成了一个subscriber。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)subscriberWithNext:(void (^)(id x))next error:(void (^)(NSError</span><br><span class="line"> *error))error completed:(void (^)(void))completed &#123;</span><br><span class="line"> </span><br><span class="line">    RACSubscriber *subscriber = [[self alloc] init];</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    subscriber-&gt;_next = [next copy];</span><br><span class="line"> </span><br><span class="line">    subscriber-&gt;_error = [error copy];</span><br><span class="line"> </span><br><span class="line">    subscriber-&gt;_completed = [completed copy];</span><br><span class="line"> </span><br><span class="line">    return subscriber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>subscriber保存了nextBlock，errorBlock，completedBlock等数据信息</p><p>接着看signal的subscribe方法，改方法的参数是subscribeNext方法中生成的subscriber对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line"> </span><br><span class="line">    NSCParameterAssert(subscriber != nil);</span><br><span class="line"> </span><br><span class="line">    RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"> </span><br><span class="line">    subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable];</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    if (self.didSubscribe != NULL) &#123;</span><br><span class="line"> </span><br><span class="line">        RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123;</span><br><span class="line"> </span><br><span class="line">            RACDisposable *innerDisposable = self.didSubscribe(subscriber);</span><br><span class="line"> </span><br><span class="line">            [disposable addDisposable:innerDisposable];</span><br><span class="line"> </span><br><span class="line">        &#125;];</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        [disposable addDisposable:schedulingDisposable];</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return disposable;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)schedule:(void (^)(void))block &#123;</span><br><span class="line">    NSCParameterAssert(block != NULL);</span><br><span class="line"> </span><br><span class="line">    if (RACScheduler.currentScheduler == nil) return [self.backgroundScheduler schedule:block];</span><br><span class="line"> </span><br><span class="line">    block();</span><br><span class="line"> </span><br><span class="line">    return nil;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在signal的subscribe方法中，调用了RACScheduler.subscriptionScheduler schedule 方法，直接就将传入的block调用了，最终调用了signal的didSubscribe block，将subscriber传入。</p><p>再看一下RACObserve在生成一个signal的时候，传入的didSubscribe block逻辑的怎样的，以下是RACObserve相关源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#define RACObserve(TARGET, KEYPATH) \</span><br><span class="line"> </span><br><span class="line">    (&#123; \</span><br><span class="line"> </span><br><span class="line">        _Pragma(&quot;clang diagnostic push&quot;) \</span><br><span class="line"> </span><br><span class="line">        _Pragma(&quot;clang diagnostic ignored \&quot;-Wreceiver-is-weak\&quot;&quot;) \</span><br><span class="line"> </span><br><span class="line">        __weak id target_ = (TARGET); \</span><br><span class="line"> </span><br><span class="line">        [target_ rac_valuesForKeyPath:@keypath(TARGET, KEYPATH) observer:self];</span><br><span class="line">         \</span><br><span class="line"> </span><br><span class="line">        _Pragma(&quot;clang diagnostic pop&quot;) \</span><br><span class="line"> </span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>在NSObject的RACPropertySubscribing分类中定义rac_valuesForKeyPath:observer:self:方法</p><p>继续：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)rac_valuesForKeyPath:(NSString *)keyPath observer:(__weak </span><br><span class="line">    NSObject *)observer &#123;</span><br><span class="line"> </span><br><span class="line">    return [[[self</span><br><span class="line"> </span><br><span class="line">        rac_valuesAndChangesForKeyPath:keyPath options:NSKeyValueObservingOptionInitial observer:observer]</span><br><span class="line"> </span><br><span class="line">        map:^(RACTuple *value) &#123;</span><br><span class="line"> </span><br><span class="line">            // -map: because it doesn&apos;t require the block trampoline that -reduceEach: uses</span><br><span class="line"> </span><br><span class="line">            return value[0];</span><br><span class="line"> </span><br><span class="line">        &#125;]</span><br><span class="line"> </span><br><span class="line">        setNameWithFormat:@&quot;RACObserve(%@, %@)&quot;, self.rac_description, keyPath];</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)rac_valuesAndChangesForKeyPath:(NSString *)keyPath options:(</span><br><span class="line">    NSKeyValueObservingOptions)options observer:(__weak NSObject *)</span><br><span class="line">    weakObserver &#123;</span><br><span class="line"> </span><br><span class="line">    NSObject *strongObserver = weakObserver;</span><br><span class="line"> </span><br><span class="line">    keyPath = [keyPath copy];</span><br><span class="line"> </span><br><span class="line">    NSRecursiveLock *objectLock = [[NSRecursiveLock alloc] init];</span><br><span class="line"> </span><br><span class="line">    objectLock.name = @&quot;</span><br><span class="line">    org.reactivecocoa.ReactiveCocoa.NSObjectRACPropertySubscribing&quot;;</span><br><span class="line"> </span><br><span class="line">    __weak NSObject *weakSelf = self;</span><br><span class="line"> </span><br><span class="line">    RACSignal *deallocSignal = [[RACSignal</span><br><span class="line"> </span><br><span class="line">        zip:@[</span><br><span class="line"> </span><br><span class="line">            self.rac_willDeallocSignal,</span><br><span class="line"> </span><br><span class="line">            strongObserver.rac_willDeallocSignal ?: [RACSignal never]</span><br><span class="line"> </span><br><span class="line">        ]]</span><br><span class="line"> </span><br><span class="line">        doCompleted:^&#123;</span><br><span class="line"> </span><br><span class="line">            // Forces deallocation to wait if the object variables are currently</span><br><span class="line"> </span><br><span class="line">            // being read on another thread.</span><br><span class="line"> </span><br><span class="line">            [objectLock lock];</span><br><span class="line"> </span><br><span class="line">            @onExit &#123;</span><br><span class="line"> </span><br><span class="line">                [objectLock unlock];</span><br><span class="line"> </span><br><span class="line">            &#125;;</span><br><span class="line"> </span><br><span class="line">        &#125;];</span><br><span class="line"> </span><br><span class="line">//重点关注这里，createSignal之后的参数就是该信号的didSubscribe block逻辑了。</span><br><span class="line">    return [[[RACSignal</span><br><span class="line"> </span><br><span class="line">        createSignal:^ RACDisposable * (id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line"> </span><br><span class="line">            // Hold onto the lock the whole time we&apos;re setting up the KVO</span><br><span class="line"> </span><br><span class="line">            // observation, because any resurrection that might be caused by our</span><br><span class="line"> </span><br><span class="line">            // retaining below must be balanced out by the time -dealloc returns</span><br><span class="line"> </span><br><span class="line">            // (if another thread is waiting on the lock above).</span><br><span class="line"> </span><br><span class="line">            [objectLock lock];</span><br><span class="line"> </span><br><span class="line">            @onExit &#123;</span><br><span class="line"> </span><br><span class="line">                [objectLock unlock];</span><br><span class="line"> </span><br><span class="line">            &#125;;</span><br><span class="line"> </span><br><span class="line">            __strong NSObject *observer __attribute__((objc_precise_lifetime)) </span><br><span class="line">            = weakObserver;</span><br><span class="line"> </span><br><span class="line">            __strong NSObject *self __attribute__((objc_precise_lifetime)) = </span><br><span class="line">            weakSelf;</span><br><span class="line"> </span><br><span class="line">            if (self == nil) &#123;</span><br><span class="line"> </span><br><span class="line">                [subscriber sendCompleted];</span><br><span class="line"> </span><br><span class="line">                return nil;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            return [self rac_observeKeyPath:keyPath options:options observer:</span><br><span class="line">            observer block:^(id value, NSDictionary *change, BOOL </span><br><span class="line">                causedByDealloc, BOOL affectedOnlyLastComponent) &#123;</span><br><span class="line"> </span><br><span class="line">                [subscriber sendNext:RACTuplePack(value, change)];</span><br><span class="line"> </span><br><span class="line">            &#125;];</span><br><span class="line"> </span><br><span class="line">        &#125;]</span><br><span class="line"> </span><br><span class="line">        takeUntil:deallocSignal]</span><br><span class="line"> </span><br><span class="line">        setNameWithFormat:@&quot;%@ -rac_valueAndChangesForKeyPath: %@ options: %lu </span><br><span class="line">        observer: %@&quot;, self.rac_description, keyPath, (unsigned long)options, </span><br><span class="line">        strongObserver.rac_description];</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在RACObserver宏定义的signal的didSubscriber block中又调用了rac_observeKeyPath:keyPath options: observer: block</p><p>继续(太长了只贴重点)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)rac_observeKeyPath:(NSString *)keyPath options:(</span><br><span class="line">    NSKeyValueObservingOptions)options observer:(__weak NSObject *)</span><br><span class="line">    weakObserver block:(void (^)(id, NSDictionary *, BOOL, BOOL))block &#123;</span><br><span class="line"> </span><br><span class="line">    NSCParameterAssert(block != nil);</span><br><span class="line"> </span><br><span class="line">    NSCParameterAssert(keyPath.rac_keyPathComponents.count &gt; 0);</span><br><span class="line"> </span><br><span class="line">    //省略数十行</span><br><span class="line">    // Call the block with the initial value if needed.</span><br><span class="line"> </span><br><span class="line">    if ((options &amp; NSKeyValueObservingOptionInitial) != 0) &#123;</span><br><span class="line"> </span><br><span class="line">        id initialValue = [self valueForKeyPath:keyPath];</span><br><span class="line"> </span><br><span class="line">        NSDictionary *initialChange = @&#123;</span><br><span class="line"> </span><br><span class="line">            NSKeyValueChangeKindKey: @(NSKeyValueChangeSetting),</span><br><span class="line"> </span><br><span class="line">            NSKeyValueChangeNewKey: initialValue ?: NSNull.null,</span><br><span class="line"> </span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line">        block(initialValue, initialChange, NO, keyPathHasOneComponent);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    //省略数十行</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明一下，options是NSKeyValueObservingOptions属于NS_OPTIONS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, NSKeyValueObservingOptions) &#123;</span><br><span class="line"> </span><br><span class="line">    NSKeyValueObservingOptionNew = 0x01,</span><br><span class="line"> </span><br><span class="line">    NSKeyValueObservingOptionOld = 0x02,</span><br><span class="line"> </span><br><span class="line">    NSKeyValueObservingOptionInitial NS_ENUM_AVAILABLE(10_5, 2_0) = 0x04,</span><br><span class="line"> </span><br><span class="line">    NSKeyValueObservingOptionPrior NS_ENUM_AVAILABLE(10_5, 2_0) = 0x08</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在以上方法中，它判断了，传入的options是否是NSKeyValueObservingOptionInitial类型，而在调用rac_observeKeyPath: options: observer: block:的时候，option就是传的NSKeyValueObservingOptionInitial，所以会直接调用传进来的block，在rac_valuesAndChangesForKeyPath: options: observer:中调用rac_observeKeyPath: options: observer: block:的时候传入block里面的逻辑是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[subscriber sendNext:RACTuplePack(value, change)];</span><br></pre></td></tr></table></figure><p>综上所述，RACObserver生成的signal在调用subscribeNext方法订阅该信号的时候，会直接调用一次订阅信号之后next block的逻辑，所以即便是属性变化之后订阅属性变化信号，它也会默认先调用一次next block的逻辑。</p><p>正常kvo检测转化成信号的逻辑：</p><p>在RACObserver初始化的过程中，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)rac_observeKeyPath:(NSString *)keyPath options:(</span><br><span class="line">    NSKeyValueObservingOptions)options observer:(__weak NSObject *)</span><br><span class="line">    weakObserver block:(void (^)(id, NSDictionary *, BOOL, BOOL))block &#123;</span><br><span class="line"> </span><br><span class="line">    NSCParameterAssert(block != nil);</span><br><span class="line"> </span><br><span class="line">    NSCParameterAssert(keyPath.rac_keyPathComponents.count &gt; 0);</span><br><span class="line"> </span><br><span class="line">    //省略数十行</span><br><span class="line"> </span><br><span class="line">    NSKeyValueObservingOptions trampolineOptions = (options | </span><br><span class="line">        NSKeyValueObservingOptionPrior) &amp; ~NSKeyValueObservingOptionInitial;</span><br><span class="line"> </span><br><span class="line">    RACKVOTrampoline *trampoline = [[RACKVOTrampoline alloc] initWithTarget:</span><br><span class="line">    self observer:strongObserver keyPath:keyPathHead options:trampolineOptions </span><br><span class="line">    block:^(id trampolineTarget, id trampolineObserver, NSDictionary *change) &#123;</span><br><span class="line"> </span><br><span class="line">        // If this is a prior notification, clean up all the callbacks added to the</span><br><span class="line"> </span><br><span class="line">        // previous value and call the callback block. Everything else is deferred</span><br><span class="line"> </span><br><span class="line">        // until after we get the notification after the change.</span><br><span class="line"> </span><br><span class="line">        if ([change[NSKeyValueChangeNotificationIsPriorKey] boolValue]) &#123;</span><br><span class="line"> </span><br><span class="line">            [firstComponentDisposable() dispose];</span><br><span class="line"> </span><br><span class="line">            if ((options &amp; NSKeyValueObservingOptionPrior) != 0) &#123;</span><br><span class="line"> </span><br><span class="line">                block([trampolineTarget valueForKeyPath:keyPath], change, NO, </span><br><span class="line">                    keyPathHasOneComponent);</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        // From here the notification is not prior.</span><br><span class="line"> </span><br><span class="line">        NSObject *value = [trampolineTarget valueForKey:keyPathHead];</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        // If the value has changed but is nil, there is no need to add callbacks to</span><br><span class="line"> </span><br><span class="line">        // it, just call the callback block.</span><br><span class="line"> </span><br><span class="line">        if (value == nil) &#123;</span><br><span class="line">            block(nil, change, NO, keyPathHasOneComponent);</span><br><span class="line"> </span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        // From here the notification is not prior and the value is not nil.</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        // Create a new firstComponentDisposable while getting rid of the old one at</span><br><span class="line"> </span><br><span class="line">        // the same time, in case this is being called concurrently.</span><br><span class="line"> </span><br><span class="line">        RACDisposable *oldFirstComponentDisposable = [</span><br><span class="line">        firstComponentSerialDisposable swapInDisposable:[RACCompoundDisposable </span><br><span class="line">        compoundDisposable]];</span><br><span class="line"> </span><br><span class="line">        [oldFirstComponentDisposable dispose];</span><br><span class="line"> </span><br><span class="line">        addDeallocObserverToPropertyValue(value);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        // If there are no further key path components, there is no need to add the</span><br><span class="line"> </span><br><span class="line">        // other callbacks, just call the callback block with the value itself.</span><br><span class="line"> </span><br><span class="line">        if (keyPathHasOneComponent) &#123;</span><br><span class="line"> </span><br><span class="line">            block(value, change, NO, keyPathHasOneComponent);</span><br><span class="line"> </span><br><span class="line">            return;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        // The value has changed, is not nil, and there are more key path components</span><br><span class="line"> </span><br><span class="line">        // to consider. Add the callbacks to the value for the remaining key path</span><br><span class="line"> </span><br><span class="line">        // components and call the callback block with the current value of the full</span><br><span class="line"> </span><br><span class="line">        // key path.</span><br><span class="line"> </span><br><span class="line">        addObserverToValue(value);</span><br><span class="line"> </span><br><span class="line">        block([value valueForKeyPath:keyPathTail], change, NO, keyPathHasOneComponent);</span><br><span class="line"> </span><br><span class="line">    &#125;];</span><br><span class="line"> </span><br><span class="line">    // Stop the KVO observation when this one is disposed of.</span><br><span class="line"> </span><br><span class="line">    [disposable addDisposable:trampoline];</span><br><span class="line">  </span><br><span class="line">    //省略数十行</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该方法中生成了一个RACKVOTrampoline中间对象，看它的源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">- (id)initWithTarget:(__weak NSObject *)target observer:(__weak NSObject *)</span><br><span class="line">observer keyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)</span><br><span class="line">options block:(RACKVOBlock)block &#123;</span><br><span class="line"> </span><br><span class="line">    NSCParameterAssert(keyPath != nil);</span><br><span class="line"> </span><br><span class="line">    NSCParameterAssert(block != nil);</span><br><span class="line"> </span><br><span class="line">    NSObject *strongTarget = target;</span><br><span class="line"> </span><br><span class="line">    if (strongTarget == nil) return nil;</span><br><span class="line"> </span><br><span class="line">    self = [super init];</span><br><span class="line"> </span><br><span class="line">    if (self == nil) return nil;</span><br><span class="line">    _keyPath = [keyPath copy];</span><br><span class="line"> </span><br><span class="line">    _block = [block copy];</span><br><span class="line"> </span><br><span class="line">    _weakTarget = target;</span><br><span class="line"> </span><br><span class="line">    _unsafeTarget = strongTarget;</span><br><span class="line"> </span><br><span class="line">    _observer = observer;</span><br><span class="line"> </span><br><span class="line">    [RACKVOProxy.sharedProxy addObserver:self forContext:(__bridge void *)self];</span><br><span class="line"> </span><br><span class="line">    [strongTarget addObserver:RACKVOProxy.sharedProxy forKeyPath:self.keyPath </span><br><span class="line">    options:options context:(__bridge void *)self];</span><br><span class="line"> </span><br><span class="line">    [strongTarget.rac_deallocDisposable addDisposable:self];</span><br><span class="line"> </span><br><span class="line">    [self.observer.rac_deallocDisposable addDisposable:self];</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line"> </span><br><span class="line">    [self dispose];</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">#pragma mark Observation</span><br><span class="line"> </span><br><span class="line">- (void)dispose &#123;</span><br><span class="line"> </span><br><span class="line">    NSObject *target;</span><br><span class="line"> </span><br><span class="line">    NSObject *observer;</span><br><span class="line"> </span><br><span class="line">    @synchronized (self) &#123;</span><br><span class="line"> </span><br><span class="line">        _block = nil;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        // The target should still exist at this point, because we still need to</span><br><span class="line"> </span><br><span class="line">        // tear down its KVO observation. Therefore, we can use the unsafe</span><br><span class="line"> </span><br><span class="line">        // reference (and need to, because the weak one will have been zeroed by</span><br><span class="line"> </span><br><span class="line">        // now).</span><br><span class="line"> </span><br><span class="line">        target = self.unsafeTarget;</span><br><span class="line"> </span><br><span class="line">        observer = self.observer;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        _unsafeTarget = nil;</span><br><span class="line"> </span><br><span class="line">        _observer = nil;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    [target.rac_deallocDisposable removeDisposable:self];</span><br><span class="line"> </span><br><span class="line">    [observer.rac_deallocDisposable removeDisposable:self];</span><br><span class="line"> </span><br><span class="line">    [target removeObserver:RACKVOProxy.sharedProxy forKeyPath:self.keyPath </span><br><span class="line">    context:(__bridge void *)self];</span><br><span class="line"> </span><br><span class="line">    [RACKVOProxy.sharedProxy removeObserver:self forContext:(__bridge void *)self];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//系统的代理方法，其实是由RACKVOProxy.sharedProxy对象转发的，RACKVOProxy.sharedProxy才是真正处理系统消息的对象。</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(</span><br><span class="line">    NSDictionary *)change context:(void *)context &#123;</span><br><span class="line"> </span><br><span class="line">    if (context != (__bridge void *)self) &#123;</span><br><span class="line"> </span><br><span class="line">        [super observeValueForKeyPath:keyPath ofObject:object change:change </span><br><span class="line">        context:context];</span><br><span class="line"> </span><br><span class="line">        return;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    RACKVOBlock block;</span><br><span class="line"> </span><br><span class="line">    id observer;</span><br><span class="line"> </span><br><span class="line">    id target;</span><br><span class="line"> </span><br><span class="line">    @synchronized (self) &#123;</span><br><span class="line"> </span><br><span class="line">        block = self.block;</span><br><span class="line"> </span><br><span class="line">        observer = self.observer;</span><br><span class="line"> </span><br><span class="line">        target = self.weakTarget;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (block == nil || target == nil) return;</span><br><span class="line"> </span><br><span class="line">    block(target, observer, change);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到RACKVOTrampoline对象替代原来使用KVO的对象，作为系统的代理，实现了代理方法。实际上，真正调用系统KVO注册的方法的时候，是往一个叫RACKVOProxy.sharedProxy的全局单例对象注册的。RACKVOTrampoline是具体处理KVO消息的对象，在RACKVOPorxy.shareProxy对象中注册了所有使用RAC KVO的系统消息，再由它转发给具体的RACKVOTrampoline进行处理，而在RACKVOTrampoline处理的时候，调用了RACKVOtrampoline初始化的时候传进来的block。之后在RACKVOTrampoline参数block调用过程中就会调用sendNext方法了，往外面发信号数据。</p><p>以下是RACKVOProxy.sharedProxy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">@interface RACKVOProxy()</span><br><span class="line"> </span><br><span class="line">@property (strong, nonatomic, readonly) NSMapTable *trampolines;</span><br><span class="line"> </span><br><span class="line">@property (strong, nonatomic, readonly) dispatch_queue_t queue;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">@end</span><br><span class="line"> </span><br><span class="line">@implementation RACKVOProxy</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">+ (instancetype)sharedProxy &#123;</span><br><span class="line"> </span><br><span class="line">    static RACKVOProxy *proxy;</span><br><span class="line"> </span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line"> </span><br><span class="line">        proxy = [[self alloc] init];</span><br><span class="line"> </span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    return proxy;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line"> </span><br><span class="line">    self = [super init];</span><br><span class="line"> </span><br><span class="line">    if (self == nil) return nil;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    _queue = dispatch_queue_create(&quot;org.reactivecocoa.ReactiveCocoa.RACKVOProxy</span><br><span class="line">    &quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"> </span><br><span class="line">    _trampolines = [NSMapTable strongToWeakObjectsMapTable];</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    return self;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)addObserver:(__weak NSObject *)observer forContext:(void *)context &#123;</span><br><span class="line"> </span><br><span class="line">    NSValue *valueContext = [NSValue valueWithPointer:context];</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    dispatch_sync(self.queue, ^&#123;</span><br><span class="line"> </span><br><span class="line">        [self.trampolines setObject:observer forKey:valueContext];</span><br><span class="line"> </span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)removeObserver:(NSObject *)observer forContext:(void *)context &#123;</span><br><span class="line"> </span><br><span class="line">    NSValue *valueContext = [NSValue valueWithPointer:context];</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    dispatch_sync(self.queue, ^&#123;</span><br><span class="line"> </span><br><span class="line">        [self.trampolines removeObjectForKey:valueContext];</span><br><span class="line"> </span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(</span><br><span class="line">    NSDictionary *)change context:(void *)context &#123;</span><br><span class="line"> </span><br><span class="line">    NSValue *valueContext = [NSValue valueWithPointer:context];</span><br><span class="line"> </span><br><span class="line">    __block NSObject *trueObserver;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    dispatch_sync(self.queue, ^&#123;</span><br><span class="line"> </span><br><span class="line">        trueObserver = [self.trampolines objectForKey:valueContext];</span><br><span class="line"> </span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    if (trueObserver != nil) &#123;</span><br><span class="line"> </span><br><span class="line">        [trueObserver observeValueForKeyPath:keyPath ofObject:object change:</span><br><span class="line">        change context:context];</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RACKVOProxy.sharedProxy管理了整个RAC 中KVO的处理系统KVO消息的中间对象和系统KVO消息的转发。</p><p>综合上面的代码可以看出，正是由于各种中间对象替用户实现了代理方法起了代理对象的作用，用户才能把代码写的更加紧凑清晰。</p><h2 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h2><p>看以下代码，假设combineLatest之后得到的信号是A</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[RACSignal combineLatest:@[[RACObserve(self, propertyA) ignore:nil], [</span><br><span class="line">RACObserve(self, propertyB) ignore:nil]]] subscribeNext:^(RACTuple *tuple) &#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>1.使用combineLatest的时候，第一次订阅会不会触发subscribeNext后面的block</p><p>2.combineLatest中的信号，是同时调用了sendNext之后会触发A调用sendNext，还是只需要其中有一个信号调用了sendNext会触发A调用sendNext</p><p>看一下combineLatest源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)combineLatest:(id&lt;NSFastEnumeration&gt;)signals &#123;</span><br><span class="line"> </span><br><span class="line">    return [[self join:signals block:^(RACSignal *left, RACSignal *right) &#123;</span><br><span class="line"> </span><br><span class="line">        return [left combineLatestWith:right];</span><br><span class="line"> </span><br><span class="line">    &#125;] setNameWithFormat:@&quot;+combineLatest: %@&quot;, signals];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续 join: block:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)join:(id&lt;NSFastEnumeration&gt;)streams block:(RACStream * (^)(id, </span><br><span class="line">    id))block &#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//第一段</span><br><span class="line">    RACStream *current = nil;</span><br><span class="line">    // Creates streams of successively larger tuples by combining the input</span><br><span class="line"> </span><br><span class="line">    // streams one-by-one.</span><br><span class="line"> </span><br><span class="line">    for (RACStream *stream in streams) &#123;</span><br><span class="line"> </span><br><span class="line">        // For the first stream, just wrap its values in a RACTuple. That way,</span><br><span class="line"> </span><br><span class="line">        // if only one stream is given, the result is still a stream of tuples.</span><br><span class="line"> </span><br><span class="line">        if (current == nil) &#123;</span><br><span class="line"> </span><br><span class="line">            current = [stream map:^(id x) &#123;</span><br><span class="line"> </span><br><span class="line">                return RACTuplePack(x);</span><br><span class="line"> </span><br><span class="line">            &#125;];</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        current = block(current, stream);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    if (current == nil) return [self empty];</span><br><span class="line">//第二段</span><br><span class="line">    return [current map:^(RACTuple *xs) &#123;</span><br><span class="line"> </span><br><span class="line">        // Right now, each value is contained in its own tuple, sorta like:</span><br><span class="line"> </span><br><span class="line">        //</span><br><span class="line"> </span><br><span class="line">        // (((1), 2), 3)</span><br><span class="line"> </span><br><span class="line">        //</span><br><span class="line"> </span><br><span class="line">        // We need to unwrap all the layers and create a tuple out of the result.</span><br><span class="line"> </span><br><span class="line">        NSMutableArray *values = [[NSMutableArray alloc] init];</span><br><span class="line"> </span><br><span class="line">        while (xs != nil) &#123;</span><br><span class="line">            [values insertObject:xs.last ?: RACTupleNil.tupleNil atIndex:0];</span><br><span class="line"> </span><br><span class="line">            xs = (xs.count &gt; 1 ? xs.first : nil);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        return [RACTuple tupleWithObjectsFromArray:values];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分代码分2段，第一段是将两个信号合并的逻辑，具体的合并逻辑是由外面传进来的block确定的。第二段是通过map将信号的值重新做了处理，第一段得到的信号属于signal of signals的类型，第二段将它打平。</p><p>再看一下combineLatestWith:方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)combineLatestWith:(RACSignal *)signal &#123;</span><br><span class="line">    NSCParameterAssert(signal != nil);</span><br><span class="line"> </span><br><span class="line">    return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line"> </span><br><span class="line">        RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"> </span><br><span class="line">        __block id lastSelfValue = nil;</span><br><span class="line"> </span><br><span class="line">        __block BOOL selfCompleted = NO;</span><br><span class="line"> </span><br><span class="line">        __block id lastOtherValue = nil;</span><br><span class="line"> </span><br><span class="line">        __block BOOL otherCompleted = NO;</span><br><span class="line"> </span><br><span class="line">        void (^sendNext)(void) = ^&#123;</span><br><span class="line"> </span><br><span class="line">            @synchronized (disposable) &#123;</span><br><span class="line"> </span><br><span class="line">                if (lastSelfValue == nil || lastOtherValue == nil) return;</span><br><span class="line"> </span><br><span class="line">                [subscriber sendNext:RACTuplePack(lastSelfValue, lastOtherValue)];</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line">        RACDisposable *selfDisposable = [self subscribeNext:^(id x) &#123;</span><br><span class="line"> </span><br><span class="line">            @synchronized (disposable) &#123;</span><br><span class="line"> </span><br><span class="line">                lastSelfValue = x ?: RACTupleNil.tupleNil;</span><br><span class="line"> </span><br><span class="line">                sendNext();</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125; error:^(NSError *error) &#123;</span><br><span class="line"> </span><br><span class="line">            [subscriber sendError:error];</span><br><span class="line"> </span><br><span class="line">        &#125; completed:^&#123;</span><br><span class="line"> </span><br><span class="line">            @synchronized (disposable) &#123;</span><br><span class="line"> </span><br><span class="line">                selfCompleted = YES;</span><br><span class="line"> </span><br><span class="line">                if (otherCompleted) [subscriber sendCompleted];</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;];</span><br><span class="line"> </span><br><span class="line">        [disposable addDisposable:selfDisposable];</span><br><span class="line"> </span><br><span class="line">        RACDisposable *otherDisposable = [signal subscribeNext:^(id x) &#123;</span><br><span class="line"> </span><br><span class="line">            @synchronized (disposable) &#123;</span><br><span class="line"> </span><br><span class="line">                lastOtherValue = x ?: RACTupleNil.tupleNil;</span><br><span class="line"> </span><br><span class="line">                sendNext();</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125; error:^(NSError *error) &#123;</span><br><span class="line"> </span><br><span class="line">            [subscriber sendError:error];</span><br><span class="line"> </span><br><span class="line">        &#125; completed:^&#123;</span><br><span class="line"> </span><br><span class="line">            @synchronized (disposable) &#123;</span><br><span class="line"> </span><br><span class="line">                otherCompleted = YES;</span><br><span class="line"> </span><br><span class="line">                if (selfCompleted) [subscriber sendCompleted];</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;];</span><br><span class="line"> </span><br><span class="line">        [disposable addDisposable:otherDisposable];</span><br><span class="line">        return disposable;</span><br><span class="line"> </span><br><span class="line">    &#125;] setNameWithFormat:@&quot;[%@] -combineLatestWith: %@&quot;, self.name, signal];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上代码中，调用了当前信号的subscribeNext方法，同时也调用了需要合并的信号的subscribeNext方法。subscribeNext方法block中调用了sendNext block，这个block是在combineLatestWith中定义，判断两个信号是否已经调用过sendNext，如果都同时掉用过sendNext就会触发combineLatest信号调用didSubscribe block，最终触发订阅combineLatest信号的传入的subscribeNext后的block。</p><p>综合上面的分析，类似于以下的使用方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[RACSignal combineLatest:@[[RACObserve(self, propertyA) ignore:nil], [RACObserve(self, propertyB) ignore:nil]]] subscribeNext:^(RACTuple *tuple) &#123;</span><br><span class="line"> </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>第一次订阅就会触发subscribeNext之后的block逻辑，并且是RACObserve这种类型的combineLatest才会，最上面已经分析了RACObserver生成的信号在第一次订阅调用的时候信号就会调用sendNext。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题1&quot;&gt;&lt;a href=&quot;#问题1&quot; class=&quot;headerlink&quot; title=&quot;问题1&quot;&gt;&lt;/a&gt;问题1&lt;/h2&gt;&lt;p&gt;在看代码的时候，发现代码中使用到了&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)viewDidload&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [super viewDidload];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self bindData];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)bindData&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [[RACObserve(self, propertyA) ignore:nil] &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                 subscribeNext:^(NSArray *dataA) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@&amp;quot;use dataA&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是在这个类的propertyA是在init之后去设置的，在viewDidload之前。也就是在使用RAC订阅属性变化信号之前，但是use dataA打印出来了。猜测RACObserve宏生成信号在调用subscribeNext中，直接就调用了dataA的block的逻辑。但是感觉比较奇怪，不应该是propertyA变化的时候才会调用dataA的block的逻辑吗。&lt;/p&gt;
&lt;p&gt;现在具体看一下，一个信号的创建和订阅的源码：&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>MJExtension</title>
    <link href="http://yoursite.com/2016/01/25/MJExtension/"/>
    <id>http://yoursite.com/2016/01/25/MJExtension/</id>
    <published>2016-01-25T08:38:24.000Z</published>
    <updated>2018-08-06T04:03:34.827Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.KVC，字典转化成对象的时候，需要给对象的属性赋值。MJExtentsion是通过KVC实现的，所以对象都需要继承NSObject。</p><p>2.Runtime</p><pre><code>1)对与某一个类型,通过runtime去查找它自己所有的属性，再根据属性去字典里查找对应的value。2)通过runtime在运行时给对象增加字段信息，比如记录哪些属性进行转化，哪些属性忽略转化。3)通过runtime给对应的类增加缓存信息，提高转化效率。</code></pre><p>3.递归，针对对象中又包含对象，数组包含对象等情况，通过递归实现属性的赋值。</p><p>4.self用在类方法中意思是代表当前类，用在对象方法中代表当前对象。通过一个实例对象的指针调用一个类方法可以这么做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class cls = [self class];</span><br><span class="line">[cls classMethod];</span><br></pre></td></tr></table></figure><p>5.instanceType</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)objectWithKeyValues:(id)keyValues</span><br></pre></td></tr></table></figure><p>该方法定义在NSObject中，但在不同的子业务类型中，通过instanceType会返回具体的类型对象。</p><a id="more"></a> <h2 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h2><p>1.字典转对象的时候，如果某个属性是NULL，会被过滤，也就是该对象的这个属性的值是默认值。整型是0,对象类型是nil。</p><p>2.在对象转字典的时候，如果对象本身的属性包含了superClass,debugDescription,description,hash这四种中的一种，会被MJExtension过滤掉。因为它认为是系统自动增加的元素，所以当前情况下，需要把这些属性手动增加上去。</p><p>3.在对象转字典的时候，如果对象某个字段为nil，生成的结果字典里就不会存在这个键值对。</p><p>4.在对象中的属性与字典的字段不匹配的时候，需要手动指定。指定的方式是自己实现一个replacedKeyFromPropertyName方法，这个方法是手写的，写错一个字母转化就会有问题。不过也有别的方式，可以通过setupObjectWithBlock去指定，但是key必须传MJReplacedKeyFromPropertyNameKey，因为它取的时候是按这个key去取的。</p><h2 id="核心实现"><a href="#核心实现" class="headerlink" title="核心实现"></a>核心实现</h2><p>MJExtension中最核心的两个函数分别是</p><p>- (instancetype)setKeyValues:(id)keyValues context:(NSManagedObjectContext <em>)context error:(NSError *</em>)error;</p><p>- (NSDictionary <em>)keyValuesWithKeys:(NSArray </em>)keys ignoredKeys:(NSArray <em>)ignoredKeys error:(NSError </em>__autoreleasing*)error</p><p>其他的函数都是最终调用这两个函数，只是封装了一下参数</p><p>1.字典转对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)setKeyValues:(id)keyValues context:(NSManagedObjectContext *)</span><br><span class="line">context error:(NSError *__autoreleasing *)error</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    // 如果是JSON字符串</span><br><span class="line"> </span><br><span class="line">    if ([keyValues isKindOfClass:[NSString class]]) &#123;</span><br><span class="line">  </span><br><span class="line">    //json格式字符串转字典,通过NSJONSerializaton 先字符串转nsdata 再反序列化成nsdictionary</span><br><span class="line">        keyValues = [((NSString *)keyValues) JSONObject];</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    MJAssertError([keyValues isKindOfClass:[NSDictionary class]], self, error, </span><br><span class="line">        @&quot;keyValues参数不是一个字典&quot;);</span><br><span class="line"> </span><br><span class="line">    @try &#123;</span><br><span class="line"> </span><br><span class="line">        Class aClass = [self class];</span><br><span class="line">//哪些属性需要被转化</span><br><span class="line">        NSArray *allowedPropertyNames = [aClass totalAllowedPropertyNames];</span><br><span class="line">//哪些属性不需要转化</span><br><span class="line">        NSArray *ignoredPropertyNames = [aClass totalIgnoredPropertyNames];</span><br><span class="line"> </span><br><span class="line">         </span><br><span class="line"> </span><br><span class="line">        //通过封装的方法回调一个通过运行时编写的，用于返回属性列表的方法。</span><br><span class="line"> </span><br><span class="line">        [aClass enumeratePropertiesWithBlock:^(MJProperty *property, BOOL *stop</span><br><span class="line">            ) &#123;</span><br><span class="line"> </span><br><span class="line">            // 0.检测是否被忽略</span><br><span class="line"> </span><br><span class="line">            if (allowedPropertyNames.count &amp;&amp; ![allowedPropertyNames containsObject:property.name]) return;</span><br><span class="line"> </span><br><span class="line">            if ([ignoredPropertyNames containsObject:property.name]) return;</span><br><span class="line"> </span><br><span class="line">             </span><br><span class="line"> </span><br><span class="line">            // 1.取出属性值</span><br><span class="line"> </span><br><span class="line">            id value = keyValues ;</span><br><span class="line">//得到当前属性对应到字典中的字段名称或者路径</span><br><span class="line">            NSArray *keys = [property keysFromClass:[self class]];</span><br><span class="line">//这个循环覆盖到了某个属性对应的是字典中某个path的情况，</span><br><span class="line">//例如对象的oldName属性对应到字典中是name.oldName的情况</span><br><span class="line">            for (NSString *key in keys) &#123;</span><br><span class="line"> </span><br><span class="line">                if (![value isKindOfClass:[NSDictionary class]]) continue;</span><br><span class="line">                value = value[key];</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            if (!value || value == [NSNull null]) return;</span><br><span class="line"> </span><br><span class="line">             </span><br><span class="line"> </span><br><span class="line">            // 2.如果是模型属性</span><br><span class="line"> </span><br><span class="line">            MJType *type = property.type;</span><br><span class="line"> </span><br><span class="line">            Class typeClass = type.typeClass;</span><br><span class="line">//当前属性是一个数组，得到数组中的对象类型</span><br><span class="line">            Class objectClass = [property objectClassInArrayFromClass:[self </span><br><span class="line">            class]];</span><br><span class="line"> </span><br><span class="line">            if (!type.isFromFoundation &amp;&amp; typeClass) &#123;</span><br><span class="line">//当前属性是一个业务对象，递归</span><br><span class="line">                value = [typeClass objectWithKeyValues:value context:context </span><br><span class="line">                error:error];</span><br><span class="line"> </span><br><span class="line">            &#125; else if (objectClass) &#123;</span><br><span class="line"> </span><br><span class="line">                // 3.字典数组--&gt;模型数组</span><br><span class="line"> </span><br><span class="line">                value = [objectClass objectArrayWithKeyValuesArray:value </span><br><span class="line">                context:context error:error];</span><br><span class="line">//以下主要是处理属性和字典中的数据类型不匹配的问题，进行数据类型的转换</span><br><span class="line">            &#125; else if (typeClass == [NSString class]) &#123;</span><br><span class="line"> </span><br><span class="line">                if ([value isKindOfClass:[NSNumber class]]) &#123;</span><br><span class="line"> </span><br><span class="line">                    // NSNumber -&gt; NSString</span><br><span class="line"> </span><br><span class="line">                    value = [value description];</span><br><span class="line"> </span><br><span class="line">                &#125; else if ([value isKindOfClass:[NSURL class]]) &#123;</span><br><span class="line"> </span><br><span class="line">                    // NSURL -&gt; NSString</span><br><span class="line"> </span><br><span class="line">                    value = [value absoluteString];</span><br><span class="line"> </span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">            &#125; else if ([value isKindOfClass:[NSString class]]) &#123;</span><br><span class="line"> </span><br><span class="line">                if (typeClass == [NSURL class]) &#123;</span><br><span class="line"> </span><br><span class="line">                    // NSString -&gt; NSURL</span><br><span class="line"> </span><br><span class="line">                    value = [NSURL URLWithString:value];</span><br><span class="line"> </span><br><span class="line">                &#125; else if (type.isNumberType) &#123;</span><br><span class="line"> </span><br><span class="line">                    NSString *oldValue = value;</span><br><span class="line"> </span><br><span class="line">                     </span><br><span class="line"> </span><br><span class="line">                    // NSString -&gt; NSNumber</span><br><span class="line"> </span><br><span class="line">                    value = [_numberFormatter numberFromString:oldValue];</span><br><span class="line"> </span><br><span class="line">                     </span><br><span class="line"> </span><br><span class="line">                    // 如果是BOOL</span><br><span class="line"> </span><br><span class="line">                    if ([type.code isEqualToString:MJTypeBOOL]) &#123;</span><br><span class="line"> </span><br><span class="line">                        // 字符串转BOOL（字符串没有charValue方法）</span><br><span class="line"> </span><br><span class="line">                        // 系统会调用字符串的charValue转为BOOL类型</span><br><span class="line"> </span><br><span class="line">                        NSString *lower = [oldValue lowercaseString];</span><br><span class="line"> </span><br><span class="line">                        if ([lower isEqualToString:@&quot;yes&quot;] || [lower </span><br><span class="line">                        isEqualToString:@&quot;true&quot;]) &#123;</span><br><span class="line"> </span><br><span class="line">                            value = @YES;</span><br><span class="line"> </span><br><span class="line">                        &#125; else if ([lower isEqualToString:@&quot;no&quot;] || [lower </span><br><span class="line">                        isEqualToString:@&quot;false&quot;]) &#123;</span><br><span class="line"> </span><br><span class="line">                            value = @NO;</span><br><span class="line"> </span><br><span class="line">                        &#125;</span><br><span class="line"> </span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">             </span><br><span class="line"> </span><br><span class="line">            // 4.赋值</span><br><span class="line"> </span><br><span class="line">            [property setValue:value forObject:self];</span><br><span class="line"> </span><br><span class="line">        &#125;];</span><br><span class="line"> </span><br><span class="line">         </span><br><span class="line"> </span><br><span class="line">        // 转换完毕</span><br><span class="line"> </span><br><span class="line">        if ([self respondsToSelector:@selector(keyValuesDidFinishConvertingToObject)]) &#123;</span><br><span class="line"> </span><br><span class="line">            [self keyValuesDidFinishConvertingToObject];</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125; @catch (NSException *exception) &#123;</span><br><span class="line"> </span><br><span class="line">        MJBuildError(error, exception.reason);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return self;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.对象转字典</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">- (NSDictionary *)keyValuesWithKeys:(NSArray *)keys ignoredKeys:(NSArray *)</span><br><span class="line">ignoredKeys error:(NSError *__autoreleasing *)error</span><br><span class="line"> </span><br><span class="line">&#123;  </span><br><span class="line">    // 如果自己不是模型类</span><br><span class="line">    if ([MJFoundation isClassFromFoundation:[self class]]) return (NSDictionary *)self;</span><br><span class="line"> </span><br><span class="line">    __block NSMutableDictionary *keyValues = [NSMutableDictionary dictionary];</span><br><span class="line"> </span><br><span class="line">    @try &#123;</span><br><span class="line"> </span><br><span class="line">        Class aClass = [self class];</span><br><span class="line"> </span><br><span class="line">        NSArray *allowedPropertyNames = [aClass totalAllowedPropertyNames];</span><br><span class="line"> </span><br><span class="line">        NSArray *ignoredPropertyNames = [aClass totalIgnoredPropertyNames];</span><br><span class="line"> </span><br><span class="line">        [aClass enumeratePropertiesWithBlock:^(MJProperty *property, BOOL *stop</span><br><span class="line">            ) &#123;</span><br><span class="line"> </span><br><span class="line">            // 0.检测是否被忽略</span><br><span class="line"> </span><br><span class="line">            if (allowedPropertyNames.count &amp;&amp; ![allowedPropertyNames </span><br><span class="line">                containsObject:property.name]) return;</span><br><span class="line"> </span><br><span class="line">            if ([ignoredPropertyNames containsObject:property.name]) return;</span><br><span class="line"> </span><br><span class="line">            if (keys.count &amp;&amp; ![keys containsObject:property.name]) return;</span><br><span class="line"> </span><br><span class="line">            if ([ignoredKeys containsObject:property.name]) return;</span><br><span class="line"> </span><br><span class="line">            // 1.取出属性值</span><br><span class="line"> </span><br><span class="line">            id value = [property valueFromObject:self];</span><br><span class="line"> </span><br><span class="line">            if (!value) return;</span><br><span class="line"> </span><br><span class="line">            // 2.如果是模型属性</span><br><span class="line"> </span><br><span class="line">            MJType *type = property.type;</span><br><span class="line"> </span><br><span class="line">            Class typeClass = type.typeClass;</span><br><span class="line"> </span><br><span class="line">            Class objectClass = [property objectClassInArrayFromClass:[self class]];</span><br><span class="line"> </span><br><span class="line">            if (!type.isFromFoundation &amp;&amp; typeClass) &#123;</span><br><span class="line"> </span><br><span class="line">                value = [value keyValues];</span><br><span class="line"> </span><br><span class="line">            &#125; else if (objectClass) &#123;</span><br><span class="line"> </span><br><span class="line">                // 3.处理数组里面有模型的情况</span><br><span class="line"> </span><br><span class="line">                value = [objectClass keyValuesArrayWithObjectArray:value];</span><br><span class="line"> </span><br><span class="line">            &#125; else if (typeClass == [NSURL class]) &#123;</span><br><span class="line"> </span><br><span class="line">                value = [value absoluteString];</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            // 4.赋值</span><br><span class="line"> </span><br><span class="line">            NSArray *keys = [property keysFromClass:[self class]];</span><br><span class="line"> </span><br><span class="line">            NSUInteger keyCount = keys.count;</span><br><span class="line"> </span><br><span class="line">            // 创建字典</span><br><span class="line"> </span><br><span class="line">            __block NSMutableDictionary *innerDict = keyValues;</span><br><span class="line">//覆盖对象属性对应字典的一个path的情况</span><br><span class="line">            [keys enumerateObjectsUsingBlock:^(NSString *key, NSUInteger idx, </span><br><span class="line">                BOOL *stop) &#123;</span><br><span class="line"> </span><br><span class="line">                if (idx == keyCount - 1) &#123; // 最后一个属性</span><br><span class="line"> </span><br><span class="line">                    innerDict[key] = value;</span><br><span class="line"> </span><br><span class="line">                &#125; else &#123; // 字典</span><br><span class="line"> </span><br><span class="line">                    NSMutableDictionary *tempDict = innerDict[key];</span><br><span class="line"> </span><br><span class="line">                    if (tempDict == nil) &#123;</span><br><span class="line"> </span><br><span class="line">                        tempDict = [NSMutableDictionary dictionary];</span><br><span class="line"> </span><br><span class="line">                        innerDict[key] = tempDict;</span><br><span class="line"> </span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                    innerDict = tempDict;</span><br><span class="line"> </span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">            &#125;];</span><br><span class="line"> </span><br><span class="line">        &#125;];</span><br><span class="line"> </span><br><span class="line">      </span><br><span class="line">        // 去除系统自动增加的元素</span><br><span class="line"> </span><br><span class="line">        [keyValues removeObjectsForKeys:@[@&quot;superclass&quot;, @&quot;debugDescription&quot;, </span><br><span class="line">        @&quot;description&quot;, @&quot;hash&quot;]];</span><br><span class="line"> </span><br><span class="line">         </span><br><span class="line">        // 转换完毕</span><br><span class="line"> </span><br><span class="line">        if ([self respondsToSelector:@selector(objectDidFinishConvertingToKeyValues)]) &#123;</span><br><span class="line"> </span><br><span class="line">            [self objectDidFinishConvertingToKeyValues];</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125; @catch (NSException *exception) &#123;</span><br><span class="line"> </span><br><span class="line">        MJBuildError(error, exception.reason);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return keyValues;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在来看一下，MJExtension是如何通过属性名称去查找对应在字典中的字段，逻辑主要在NSObject+MJPro<br>perty.m的</p><p>+ (NSString <em>)propertyKey:(NSString </em>)propertyName方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">+ (NSString *)propertyKey:(NSString *)propertyName</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    MJAssertParamNotNil2(propertyName, nil);</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    __block NSString *key = nil;</span><br><span class="line"> </span><br><span class="line">    // 1.查看有没有需要替换的key，这里检查当前类有没有实现replacedKeyFromPropertyName方法，先从这里取</span><br><span class="line"> </span><br><span class="line">    if ([self respondsToSelector:@selector(replacedKeyFromPropertyName)]) &#123;</span><br><span class="line"> </span><br><span class="line">        key = [self replacedKeyFromPropertyName][propertyName];</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    if (!key) &#123;</span><br><span class="line">//2.如果没有从replacedKeyFromPropertyName中得到，再检查有没有通过setupObjectWithBlock指定</span><br><span class="line">        [self enumerateClassesWithBlock:^(__unsafe_unretained Class c, BOOL *</span><br><span class="line">            stop) &#123;</span><br><span class="line"> </span><br><span class="line">            NSDictionary *dict = objc_getAssociatedObject(c, &amp;</span><br><span class="line">                MJReplacedKeyFromPropertyNameKey);</span><br><span class="line"> </span><br><span class="line">            if (dict) &#123;</span><br><span class="line"> </span><br><span class="line">                key = dict[propertyName];</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            if (key) *stop = YES;</span><br><span class="line"> </span><br><span class="line">        &#125;];</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    // 3.以上都没有的情况下，就用属性名作为key，换句话说只有属性名称跟字典中的key名称对应不上的</span><br><span class="line">    //时候才需要用1或者2的方式指定，默认情况就是取属性名称。</span><br><span class="line"> </span><br><span class="line">    if (!key) key = propertyName;</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line">    return key;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>MJEextension中通过runtime的objc_setAssociatedObject函数，实现属性信息的缓存，对于某一个类型只要之前获取了它的属性信息之后再次获取即可从缓存中获取，不需要再次生成属性信息。</p><p>1.在获取一个类的所有属性时候：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">+ (NSArray *)properties</span><br><span class="line">&#123;</span><br><span class="line">    static const char MJCachedPropertiesKey = &apos;\0&apos;;</span><br><span class="line"> </span><br><span class="line">    // 获得成员变量</span><br><span class="line"> </span><br><span class="line">    // 通过关联对象，以及提前定义好的MJCachedPropertiesKey来进行运行时，对所有属性的获取。</span><br><span class="line"> </span><br><span class="line">    //***objc_getAssociatedObject </span><br><span class="line">    //方法用于判断当前是否已经获取过MJCachedPropertiesKey对应的关联对象</span><br><span class="line"> </span><br><span class="line">    //  1&gt; 关联到的类对象</span><br><span class="line"> </span><br><span class="line">    //  2&gt; 关联的属性 key</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//先从类的缓存对象中获取</span><br><span class="line">    NSMutableArray *cachedProperties = objc_getAssociatedObject(self, &amp;</span><br><span class="line">        MJCachedPropertiesKey);</span><br><span class="line"> </span><br><span class="line">    //***</span><br><span class="line"> </span><br><span class="line">    if (cachedProperties == nil) &#123;</span><br><span class="line"> </span><br><span class="line">        cachedProperties = [NSMutableArray array];</span><br><span class="line"> </span><br><span class="line">        /**遍历这个类的父类*/</span><br><span class="line"> </span><br><span class="line">        [self enumerateClassesWithBlock:^(__unsafe_unretained Class c, BOOL *</span><br><span class="line">            stop) &#123;</span><br><span class="line"> </span><br><span class="line">            // 1.获得所有的成员变量</span><br><span class="line"> </span><br><span class="line">            unsigned int outCount = 0;</span><br><span class="line"> </span><br><span class="line">            /**</span><br><span class="line"> </span><br><span class="line">                class_copyIvarList 成员变量，提示有很多第三方框架会使用 Ivar，能够获得更多的信息</span><br><span class="line"> </span><br><span class="line">                但是：在 swift 中，由于语法结构的变化，使用 Ivar 非常不稳定，经常会崩溃！</span><br><span class="line"> </span><br><span class="line">                class_copyPropertyList 属性</span><br><span class="line"> </span><br><span class="line">                class_copyMethodList 方法</span><br><span class="line"> </span><br><span class="line">                class_copyProtocolList 协议</span><br><span class="line"> </span><br><span class="line">                */</span><br><span class="line"> </span><br><span class="line">            objc_property_t *properties = class_copyPropertyList(c, &amp;outCount);</span><br><span class="line">             </span><br><span class="line"> </span><br><span class="line">            // 2.遍历每一个成员变量</span><br><span class="line"> </span><br><span class="line">            for (unsigned int i = 0; i&lt;outCount; i++) &#123;</span><br><span class="line"> </span><br><span class="line">                MJProperty *property = [MJProperty cachedPropertyWithProperty:properties[i]];</span><br><span class="line"> </span><br><span class="line">                property.srcClass = c;</span><br><span class="line"> </span><br><span class="line">                [property setKey:[self propertyKey:property.name] forClass:self];</span><br><span class="line"> </span><br><span class="line">                [property setObjectClassInArray:[self propertyObjectClassInArray:property.name] forClass:self];</span><br><span class="line"> </span><br><span class="line">                [cachedProperties addObject:property];</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            // 3.释放内存</span><br><span class="line"> </span><br><span class="line">            free(properties);</span><br><span class="line"> </span><br><span class="line">        &#125;];</span><br><span class="line"> </span><br><span class="line">        //*** 在此时设置当前这个类为关联对象，这样下次就不会重复获取类的相关属性。</span><br><span class="line"> </span><br><span class="line">        objc_setAssociatedObject(self, &amp;MJCachedPropertiesKey, cachedProperties</span><br><span class="line">            , OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line"> </span><br><span class="line">        //***</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return cachedProperties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.在获取一个runtime属性对应的MJProperty对象的时候：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)cachedPropertyWithProperty:(objc_property_t)property</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    MJProperty *propertyObj = objc_getAssociatedObject(self, property);</span><br><span class="line"> </span><br><span class="line">    if (propertyObj == nil) &#123;</span><br><span class="line"> </span><br><span class="line">        propertyObj = [[self alloc] init];</span><br><span class="line"> </span><br><span class="line">        propertyObj.property = property;</span><br><span class="line"> </span><br><span class="line">        objc_setAssociatedObject(self, property, propertyObj, </span><br><span class="line">            OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return propertyObj;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.在获取一个MJProperty的type的时候：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static NSMutableDictionary *_cachedTypes;</span><br><span class="line">  </span><br><span class="line">+ (instancetype)cachedTypeWithCode:(NSString *)code</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    MJAssertParamNotNil2(code, nil);</span><br><span class="line"> </span><br><span class="line">    MJType *type = _cachedTypes[code];</span><br><span class="line"> </span><br><span class="line">    if (type == nil) &#123;</span><br><span class="line"> </span><br><span class="line">        type = [[self alloc] init];</span><br><span class="line"> </span><br><span class="line">        type.code = code;</span><br><span class="line"> </span><br><span class="line">        _cachedTypes[code] = type;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return type;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;1.KVC，字典转化成对象的时候，需要给对象的属性赋值。MJExtentsion是通过KVC实现的，所以对象都需要继承NSObject。&lt;/p&gt;
&lt;p&gt;2.Runtime&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1)对与某一个类型,通过runtime去查找它自己所有的属性，再根据属性去字典里查找对应的value。

2)通过runtime在运行时给对象增加字段信息，比如记录哪些属性进行转化，哪些属性忽略转化。

3)通过runtime给对应的类增加缓存信息，提高转化效率。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.递归，针对对象中又包含对象，数组包含对象等情况，通过递归实现属性的赋值。&lt;/p&gt;
&lt;p&gt;4.self用在类方法中意思是代表当前类，用在对象方法中代表当前对象。通过一个实例对象的指针调用一个类方法可以这么做：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Class cls = [self class];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[cls classMethod];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;5.instanceType&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (instancetype)objectWithKeyValues:(id)keyValues&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;该方法定义在NSObject中，但在不同的子业务类型中，通过instanceType会返回具体的类型对象。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>AFNetworking-NSOperation</title>
    <link href="http://yoursite.com/2016/01/25/AFNetworking-NSOperation/"/>
    <id>http://yoursite.com/2016/01/25/AFNetworking-NSOperation/</id>
    <published>2016-01-25T08:38:24.000Z</published>
    <updated>2018-08-06T04:03:34.822Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h2><p>本节主要介绍iOS中多线程相关的内容，先简单介绍NSOperation的使用，然后结合GCD实现任务之间的管理，比如每个任务完成之后的处理以及任务与任务之间的依赖，所有任务完成之后的处理等，通过AFNetworking源码分析其具体实现。</p><a id="more"></a> <h2 id="NSoperation"><a href="#NSoperation" class="headerlink" title="NSoperation"></a>NSoperation</h2><p> 通过NSOpeartion去完成某个任务的时候，有3种方式：</p><ul><li>NSInvocationOperation</li><li>NSBlockOperation</li><li>自己继承NSOperation实现具体的任务操作</li></ul><h3 id="NSInvocationOperation"><a href="#NSInvocationOperation" class="headerlink" title="NSInvocationOperation"></a>NSInvocationOperation</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class="line">    <span class="built_in">NSOperationQueue</span> *queue = [<span class="built_in">NSOperationQueue</span> new];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSInvocationOperation</span> *ope = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:</span><br><span class="line">    <span class="keyword">self</span> selector:<span class="keyword">@selector</span>(invocationOperationCall1) object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSInvocationOperation</span> *ope2 = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget</span><br><span class="line">    :<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(invocationOperationCall2) object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    [queue addOperation:ope];</span><br><span class="line"></span><br><span class="line">    [queue addOperation:ope2];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)invocationOperationCall1&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromSelector</span>(_cmd));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)invocationOperationCall2&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromSelector</span>(_cmd));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span><span class="number">-01</span><span class="number">-13</span> <span class="number">14</span>:<span class="number">23</span>:<span class="number">54.791</span> operation+dispatch_group[<span class="number">6032</span>:<span class="number">2162368</span>]</span><br><span class="line">invocationOperationCall1------&lt;NSThread: <span class="number">0x7fb6ad8019a0</span>&gt;&#123;number = <span class="number">3</span>, name = (</span><br><span class="line">    null)&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2016</span><span class="number">-01</span><span class="number">-13</span> <span class="number">14</span>:<span class="number">23</span>:<span class="number">54.791</span> operation+dispatch_group[<span class="number">6032</span>:<span class="number">2162371</span>] </span><br><span class="line">invocationOperationCall2------&lt;NSThread: <span class="number">0x7fb6adaec8f0</span>&gt;&#123;number = <span class="number">2</span>, name = (</span><br><span class="line">    null)&#125;</span><br></pre></td></tr></table></figure><p>从日志中看出任务分别在不同的线程中执行</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSInvocationOperation</span> *ope = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(invocationOperationCall1) object:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSInvocationOperation</span> *ope2 = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:</span><br><span class="line"><span class="keyword">self</span> selector:<span class="keyword">@selector</span>(invocationOperationCall2) object:<span class="literal">nil</span>];</span><br><span class="line">[ope start];</span><br><span class="line">[ope2 start];</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span><span class="number">-01</span><span class="number">-13</span> <span class="number">14</span>:<span class="number">27</span>:<span class="number">38.226</span> operation+dispatch_group[<span class="number">6053</span>:<span class="number">2164444</span>] </span><br><span class="line">invocationOperationCall1------&lt;NSThread: <span class="number">0x7fae69508370</span>&gt;&#123;number = <span class="number">1</span>, name = </span><br><span class="line">    main&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2016</span><span class="number">-01</span><span class="number">-13</span> <span class="number">14</span>:<span class="number">27</span>:<span class="number">38.226</span> operation+dispatch_group[<span class="number">6053</span>:<span class="number">2164444</span>]</span><br><span class="line">invocationOperationCall2------&lt;NSThread: <span class="number">0x7fae69508370</span>&gt;&#123;number = <span class="number">1</span>, name = </span><br><span class="line">    main&#125;</span><br></pre></td></tr></table></figure><p>从日志中看出，如果不添加到queue中，则任务是同步在当前线程中执行的。</p><p>还可以添加NSOperation对象之间的依赖，让每个任务之间按一定的顺序执行</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSOperationQueue</span> *queue = [<span class="built_in">NSOperationQueue</span> new];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSInvocationOperation</span> *ope = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span></span><br><span class="line"> selector:<span class="keyword">@selector</span>(invocationOperationCall1) object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSInvocationOperation</span> *ope2 = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:</span><br><span class="line"><span class="keyword">self</span> selector:<span class="keyword">@selector</span>(invocationOperationCall2) object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">[ope addDependency:ope2];</span><br><span class="line"></span><br><span class="line">[queue addOperation:ope];</span><br><span class="line"></span><br><span class="line">[queue addOperation:ope2];</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span><span class="number">-01</span><span class="number">-13</span> <span class="number">19</span>:<span class="number">27</span>:<span class="number">49.182</span> operation+dispatch_group[<span class="number">13865</span>:<span class="number">2284382</span>] </span><br><span class="line">invocationOperationCall2------&lt;NSThread: <span class="number">0x7fa26300ff40</span>&gt;&#123;number = <span class="number">2</span>, name = (</span><br><span class="line">    null)&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2016</span><span class="number">-01</span><span class="number">-13</span> <span class="number">19</span>:<span class="number">27</span>:<span class="number">49.183</span> operation+dispatch_group[<span class="number">13865</span>:<span class="number">2284382</span>] </span><br><span class="line">invocationOperationCall1------&lt;NSThread: <span class="number">0x7fa26300ff40</span>&gt;&#123;number = <span class="number">2</span>, name = (</span><br><span class="line">    null)&#125;</span><br></pre></td></tr></table></figure><p>虽然ope和ope2之间是并行的，但是添加依赖之后ope会等到ope2执行完毕之后才开始执行。</p><h3 id="NSBlockOperation"><a href="#NSBlockOperation" class="headerlink" title="NSBlockOperation"></a>NSBlockOperation</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSBlockOperation</span> *ope = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task A, %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[ope addExecutionBlock:^&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task B, %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[ope addExecutionBlock:^&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task C, %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[ope start];</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">2016</span><span class="number">-01</span><span class="number">-13</span> <span class="number">14</span>:<span class="number">17</span>:<span class="number">36.594</span> operation+dispatch_group[<span class="number">5990</span>:<span class="number">2158464</span>] </span><br><span class="line">task A, &lt;NSThread: <span class="number">0x7ff1217073d0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2016</span><span class="number">-01</span><span class="number">-13</span> <span class="number">14</span>:<span class="number">17</span>:<span class="number">36.594</span> operation+dispatch_group[<span class="number">5990</span>:<span class="number">2158531</span>]</span><br><span class="line">task B, &lt;NSThread: <span class="number">0x7ff1215029f0</span>&gt;&#123;number = <span class="number">2</span>, name = (null)&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2016</span><span class="number">-01</span><span class="number">-13</span> <span class="number">14</span>:<span class="number">17</span>:<span class="number">36.594</span> operation+dispatch_group[<span class="number">5990</span>:<span class="number">2158532</span>]</span><br><span class="line">task C, &lt;NSThread: <span class="number">0x7ff1217a6af0</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义NSOperation-结合AFNetworking源码"><a href="#自定义NSOperation-结合AFNetworking源码" class="headerlink" title="自定义NSOperation(结合AFNetworking源码)"></a>自定义NSOperation(结合AFNetworking源码)</h3><p>AFNetworking源代码：</p><p><strong>AFURLConnectionOperation.m</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFURLConnectionOperation</span> : <span class="title">NSOperation</span> &lt;<span class="title">NSURLConnectionDelegate</span>, </span></span><br><span class="line"><span class="built_in">NSURLConnectionDataDelegate</span>, <span class="built_in">NSSecureCoding</span>, <span class="built_in">NSCopying</span>&gt;</span><br></pre></td></tr></table></figure><p>AFURLConnectionOperation是继承自NSOperation</p><p><strong>AFURLConnectionOperation.m</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)start &#123;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isCancelled]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(cancelConnection) onThread:[[<span class="keyword">self</span> <span class="keyword">class</span></span><br><span class="line">        ] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span>.</span><br><span class="line">        runLoopModes allObjects]];</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span> isReady]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.state = AFOperationExecutingState;</span><br><span class="line"><span class="comment">//使用AFNetworking网络线程去调用OperationDidStart函数</span></span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(operationDidStart) onThread:[[<span class="keyword">self</span> </span><br><span class="line">        <span class="keyword">class</span>] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[</span><br><span class="line">        <span class="keyword">self</span>.runLoopModes allObjects]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类方法 获取网络线程 全局唯一的</span></span><br><span class="line">+ (<span class="built_in">NSThread</span> *)networkRequestThread &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSThread</span> *_networkRequestThread = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> oncePredicate;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;</span><br><span class="line"></span><br><span class="line">        _networkRequestThread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:</span><br><span class="line">        <span class="keyword">@selector</span>(networkRequestThreadEntryPoint:) object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">        [_networkRequestThread start];</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _networkRequestThread;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化网络线程</span></span><br><span class="line">+ (<span class="keyword">void</span>)networkRequestThreadEntryPoint:(<span class="keyword">id</span>)__unused object &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"></span><br><span class="line">        [[<span class="built_in">NSThread</span> currentThread] setName:<span class="string">@"AFNetworking"</span>];</span><br><span class="line"><span class="comment">//新建网络线程的runloop对象</span></span><br><span class="line">        <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line"><span class="comment">//保证网络线程在没有任何port消息的时候一直处于活跃状态，防止进入休眠，随时处理网络请求或者数据返回。</span></span><br><span class="line">        [runLoop addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line"><span class="comment">//开始运行网络线程的runloop</span></span><br><span class="line">        [runLoop run];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)operationDidStart &#123;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> isCancelled]) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.connection = [[<span class="built_in">NSURLConnection</span> alloc] initWithRequest:<span class="keyword">self</span>.request</span><br><span class="line">         delegate:<span class="keyword">self</span> startImmediately:<span class="literal">NO</span>];</span><br><span class="line">        <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSString</span> *runLoopMode <span class="keyword">in</span> <span class="keyword">self</span>.runLoopModes) &#123;</span><br><span class="line"><span class="comment">//将网络请求相关的事件源添加到网络线程的runloop中，网络回调和数据返回都依赖于网络线程runloop去监听</span></span><br><span class="line">            [<span class="keyword">self</span>.connection scheduleInRunLoop:runLoop forMode:runLoopMode];</span><br><span class="line"><span class="comment">//将流相关的事件源添加到网络线程的runloop中，流的读写都依赖于网络线程runloop去监听</span></span><br><span class="line">            [<span class="keyword">self</span>.outputStream scheduleInRunLoop:runLoop forMode:runLoopMode];</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="keyword">self</span>.outputStream open];</span><br><span class="line"><span class="comment">//开始网络请求</span></span><br><span class="line">        [<span class="keyword">self</span>.connection start];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line"></span><br><span class="line"><span class="comment">//让主线程去触发”已经开始网络请求“这一事件。</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:</span><br><span class="line">        AFNetworkingOperationDidStartNotification object:<span class="keyword">self</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AFURLConnectionOperation自己重写了NSOperation中的start方法，具体指定了需要执行的任务。多个请求同时进行的时候，对网络数据回调的处理都是由AFNetworking的网络线程进行的。</p><h3 id="多个线程任务之间的管理"><a href="#多个线程任务之间的管理" class="headerlink" title="多个线程任务之间的管理"></a>多个线程任务之间的管理</h3><p>有时候，可能需要在所有网络请求完成之后需要做一件事情或者是不同的网络请求直接还有一定的依赖关系或者是顺序关系，这种情况下需要使用GCD的group去处理。</p><h4 id="GCD-group简单介绍："><a href="#GCD-group简单介绍：" class="headerlink" title="GCD group简单介绍："></a>GCD group简单介绍：</h4><p>通过group可以对多个task进行统一管理，比如现在需要在多个任务完成之后再去做最后的处理：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.ConcurrentQueue"</span>, </span><br><span class="line">DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task A"</span>);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task B"</span>);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task LAST"</span>);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"task C"</span>);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span><span class="number">-01</span><span class="number">-13</span> <span class="number">19</span>:<span class="number">18</span>:<span class="number">13.814</span> operation+dispatch_group[<span class="number">13783</span>:<span class="number">2280382</span>] task B</span><br><span class="line"></span><br><span class="line"><span class="number">2016</span><span class="number">-01</span><span class="number">-13</span> <span class="number">19</span>:<span class="number">18</span>:<span class="number">13.814</span> operation+dispatch_group[<span class="number">13783</span>:<span class="number">2280385</span>] task C</span><br><span class="line"></span><br><span class="line"><span class="number">2016</span><span class="number">-01</span><span class="number">-13</span> <span class="number">19</span>:<span class="number">18</span>:<span class="number">13.814</span> operation+dispatch_group[<span class="number">13783</span>:<span class="number">2280383</span>] task A</span><br><span class="line"></span><br><span class="line"><span class="number">2016</span><span class="number">-01</span><span class="number">-13</span> <span class="number">19</span>:<span class="number">18</span>:<span class="number">13.815</span> operation+dispatch_group[<span class="number">13783</span>:<span class="number">2280383</span>] task LAST</span><br></pre></td></tr></table></figure><p>通过group让task LAST等到ABC任务执行完之后最后进行处理。</p><h4 id="AFNetworking中多任务之间的管理实现"><a href="#AFNetworking中多任务之间的管理实现" class="headerlink" title="AFNetworking中多任务之间的管理实现"></a>AFNetworking中多任务之间的管理实现</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ (<span class="built_in">NSArray</span> *)batchOfRequestOperations:(<span class="built_in">NSArray</span> *)operations</span><br><span class="line">                        progressBlock:(<span class="keyword">void</span> (^)(<span class="built_in">NSUInteger</span> </span><br><span class="line">                            numberOfFinishedOperations, <span class="built_in">NSUInteger</span> </span><br><span class="line">                            totalNumberOfOperations))progressBlock</span><br><span class="line"></span><br><span class="line">                      completionBlock:(<span class="keyword">void</span> (^)(<span class="built_in">NSArray</span> *operations))</span><br><span class="line">                      completionBlock</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!operations || [operations count] == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> @[[<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (completionBlock) &#123;</span><br><span class="line"></span><br><span class="line">                    completionBlock(@[]);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;]];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __block dispatch_group_t group = dispatch_group_create();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//等待所有任务都完成之后最后需要处理的任务</span></span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *batchedOperation = [<span class="built_in">NSBlockOperation</span> </span><br><span class="line">    blockOperationWithBlock:^&#123;</span><br><span class="line"><span class="comment">//通过dispatch_group_notify保证completionBlock当前group</span></span><br><span class="line"><span class="comment">//中的主线程队列上所有的originalCompletionBlock任务处理完之后再处理</span></span><br><span class="line">        dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (completionBlock) &#123;</span><br><span class="line"></span><br><span class="line">                completionBlock(operations);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (AFURLConnectionOperation *operation <span class="keyword">in</span> operations) &#123;</span><br><span class="line"></span><br><span class="line">        operation.completionGroup = group;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> (^originalCompletionBlock)(<span class="keyword">void</span>) = [operation.completionBlock <span class="keyword">copy</span>];</span><br><span class="line"></span><br><span class="line">        __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(operation)weakOperation = operation;</span><br><span class="line"><span class="comment">//改变每个Operation的completionBlock，主要是添加了能显示任务完成进度的功能。</span></span><br><span class="line">        operation.completionBlock = ^&#123;</span><br><span class="line"></span><br><span class="line">            __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation)strongOperation = weakOperation;</span><br><span class="line"></span><br><span class="line"><span class="comment">//忽略行级别的编译器警告</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic push</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Wgnu"</span></span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">dispatch_queue_t</span> queue = strongOperation.completionQueue ?: dispatch_get_main_queue();</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma clang diagnostic pop</span></span><br><span class="line"></span><br><span class="line">            dispatch_group_async(group, queue, ^&#123;</span><br><span class="line"><span class="comment">//originalCompletionBlock任务可能会被放到dispatch_main_queue中处理。</span></span><br><span class="line">                <span class="keyword">if</span> (originalCompletionBlock) &#123;</span><br><span class="line"></span><br><span class="line">                    originalCompletionBlock();</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//过滤出已经完成的任务</span></span><br><span class="line">                <span class="built_in">NSUInteger</span> numberOfFinishedOperations = [[operations </span><br><span class="line">                indexesOfObjectsPassingTest:^<span class="built_in">BOOL</span>(<span class="keyword">id</span> op, <span class="built_in">NSUInteger</span> __unused </span><br><span class="line">                    idx,  <span class="built_in">BOOL</span> __unused *stop) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> [op isFinished];</span><br><span class="line"></span><br><span class="line">                &#125;] count];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (progressBlock) &#123;</span><br><span class="line"><span class="comment">//显示任务完成的进度</span></span><br><span class="line">                    progressBlock(numberOfFinishedOperations, [operations count</span><br><span class="line">                        ]);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                dispatch_group_leave(group);</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        dispatch_group_enter(group);</span><br><span class="line"><span class="comment">//添加batchedOperation对所有Operation任务的依赖，保证batchedOperation最后处理。</span></span><br><span class="line">        [batchedOperation addDependency:operation];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [operations arrayByAddingObject:batchedOperation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数是将多个任务进行打包处理，并能显示出完成进度，以及最后等待所有任务完成之后进行最后的处理。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本内容&quot;&gt;&lt;a href=&quot;#基本内容&quot; class=&quot;headerlink&quot; title=&quot;基本内容&quot;&gt;&lt;/a&gt;基本内容&lt;/h2&gt;&lt;p&gt;本节主要介绍iOS中多线程相关的内容，先简单介绍NSOperation的使用，然后结合GCD实现任务之间的管理，比如每个任务完成之后的处理以及任务与任务之间的依赖，所有任务完成之后的处理等，通过AFNetworking源码分析其具体实现。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>MLLeaksFinder</title>
    <link href="http://yoursite.com/2016/01/25/MLLeaksFinder/"/>
    <id>http://yoursite.com/2016/01/25/MLLeaksFinder/</id>
    <published>2016-01-25T08:38:24.000Z</published>
    <updated>2018-08-06T04:03:34.828Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本原理："><a href="#基本原理：" class="headerlink" title="基本原理："></a>基本原理：</h2><p>MlLeaksFinder是app运行的过程中，检测内存泄漏的第三方库，可以帮助在代码调试阶段发现问题。通过method swizzled hook 对象生命周期的方法，在对象结束生命周期的时候，在指定时间之后给对象发送某个消息。如果这个时候对象已经被释放，消息不会被执行，如果没有释放说明发生了内存泄漏，消息就会被执行，从而提醒开发人员。通过递归的方式，会记录下某个视图或者controller的树形节点的位置，能更好的帮助定位到具体哪个对象没有被释放。MLLeaksFinder引入了FBRetainCycleDetector，可以检查循环引用。</p><p>内存泄漏分为2种，第1种是对象没有被任何引用，在内存中没有被释放。第2种是对象发生循环引用，无法被释放。在RAC的场景下，通过是2引起的内存泄漏。</p><a id="more"></a> <h2 id="源码分析："><a href="#源码分析：" class="headerlink" title="源码分析："></a>源码分析：</h2><p>MLeaksFinder.h定义了MLeaksFinder中使用的宏</p><p><strong>MLeaksFinder.h</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#ifdef MEMORY_LEAKS_FINDER_ENABLED</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//_INTERNAL_MLF_ENABLED 宏用来控制 MLLeaksFinder库 </span><br><span class="line">//什么时候开启检测，可以自定义这个时机，默认则是在DEBUG模式下会启动，RELEASE模式下不启动</span><br><span class="line">//它是通过预编译来实现的</span><br><span class="line">#define _INTERNAL_MLF_ENABLED MEMORY_LEAKS_FINDER_ENABLED</span><br><span class="line"> </span><br><span class="line">#else</span><br><span class="line"> </span><br><span class="line">#define _INTERNAL_MLF_ENABLED DEBUG</span><br><span class="line"> </span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">//_INTERNAL_MLF_RC_ENABLED 宏用来控制 是否开启循环引用的检测</span><br><span class="line">#ifdef MEMORY_LEAKS_FINDER_RETAIN_CYCLE_ENABLED</span><br><span class="line"> </span><br><span class="line">#define _INTERNAL_MLF_RC_ENABLED MEMORY_LEAKS_FINDER_RETAIN_CYCLE_ENABLED</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//COCOAPODS 因为MLLeaksFinder引用了第三库用来检查循环引用，所以必须是当前项目中使用了COCOAP</span><br><span class="line">//ODS，才能使用这个功能。</span><br><span class="line">#elif COCOAPODS</span><br><span class="line"> </span><br><span class="line">#define _INTERNAL_MLF_RC_ENABLED COCOAPODS</span><br><span class="line"> </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>MLLeakeObjectProxy用来对泄漏对象检查循环引用</p><p><strong>MLeakedObjectProxy</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">//用来检查当前泄漏对象是否已经添加到泄漏对象集合中，如果是，就不再添加也不再提示开发者</span><br><span class="line">+ (BOOL)isAnyObjectLeakedAtPtrs:(NSSet *)ptrs</span><br><span class="line">&#123;</span><br><span class="line">    NSAssert([NSThread isMainThread], @&quot;Must be in main thread.&quot;);</span><br><span class="line">  </span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">//全局用于保存泄漏对象的集合</span><br><span class="line">        leakedObjectPtrs = [[NSMutableSet alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    if (!ptrs.count) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">//NSSet求交集</span><br><span class="line">    if ([leakedObjectPtrs intersectsSet:ptrs]) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">+ (void)addLeakedObject:(id)object &#123;</span><br><span class="line"> </span><br><span class="line">    NSAssert([NSThread isMainThread], @&quot;Must be in main thread.&quot;);</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line">//创建用于检查循环引用的objectProxy对象</span><br><span class="line">    MLeakedObjectProxy *proxy = [[MLeakedObjectProxy alloc] init];</span><br><span class="line"> </span><br><span class="line">    proxy.object = object;</span><br><span class="line"> </span><br><span class="line">    proxy.objectPtr = @((uintptr_t)object);</span><br><span class="line"> </span><br><span class="line">    proxy.viewStack = [object viewStack];</span><br><span class="line"> </span><br><span class="line">    static const void *const kLeakedObjectProxyKey = &amp;kLeakedObjectProxyKey;</span><br><span class="line"> </span><br><span class="line">    objc_setAssociatedObject(object, kLeakedObjectProxyKey, proxy, </span><br><span class="line">        OBJC_ASSOCIATION_RETAIN);</span><br><span class="line"> </span><br><span class="line">    [leakedObjectPtrs addObject:proxy.objectPtr];</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">#if _INTERNAL_MLF_RC_ENABLED</span><br><span class="line">//带有循环引用检查功能的提示框</span><br><span class="line">    [MLeaksMessenger alertWithTitle:@&quot;Memory Leak&quot;</span><br><span class="line"> </span><br><span class="line">                            message:[NSString stringWithFormat:@&quot;%@&quot;, proxy.</span><br><span class="line">                            viewStack]</span><br><span class="line"> </span><br><span class="line">                           delegate:proxy</span><br><span class="line"> </span><br><span class="line">              additionalButtonTitle:@&quot;Retain Cycle&quot;];</span><br><span class="line"> </span><br><span class="line">#else</span><br><span class="line">//普通提示框</span><br><span class="line">    [MLeaksMessenger alertWithTitle:@&quot;Memory Leak&quot;</span><br><span class="line"> </span><br><span class="line">                            message:[NSString stringWithFormat:@&quot;%@&quot;, proxy.</span><br><span class="line">                            viewStack]];</span><br><span class="line"> </span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)</span><br><span class="line">buttonIndex &#123;</span><br><span class="line"> </span><br><span class="line">#if _INTERNAL_MLF_RC_ENABLED</span><br><span class="line"> </span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line"> </span><br><span class="line">        FBRetainCycleDetector *detector = [FBRetainCycleDetector new];</span><br><span class="line"> </span><br><span class="line">        [detector addCandidate:self.object];</span><br><span class="line"> </span><br><span class="line">        NSSet *retainCycles = [detector findRetainCyclesWithMaxCycleLength:20];</span><br><span class="line"> </span><br><span class="line">        BOOL hasFound = NO;</span><br><span class="line"> </span><br><span class="line">//retainCycles中是找到的所有循环引用的链</span><br><span class="line">        for (NSArray *retainCycle in retainCycles) &#123;</span><br><span class="line"> </span><br><span class="line">            NSInteger index = 0;</span><br><span class="line"> </span><br><span class="line">            for (FBObjectiveCGraphElement *element in retainCycle) &#123;</span><br><span class="line">//找到当前内存泄漏对象所在的循环引用的链</span><br><span class="line">                if (element.object == object) &#123;</span><br><span class="line">//把当前对象调整到第一个的位置，方便查看</span><br><span class="line">                    NSArray *shiftedRetainCycle = [self shiftArray:retainCycle </span><br><span class="line">                    toIndex:index];</span><br><span class="line">                   </span><br><span class="line">                    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line"> </span><br><span class="line">                        [MLeaksMessenger alertWithTitle:@&quot;Retain Cycle&quot;</span><br><span class="line"> </span><br><span class="line">                                                message:[NSString </span><br><span class="line">                                                stringWithFormat:@&quot;%@&quot;, </span><br><span class="line">                                                shiftedRetainCycle]];</span><br><span class="line"> </span><br><span class="line">                    &#125;);</span><br><span class="line"> </span><br><span class="line">                    hasFound = YES;</span><br><span class="line"> </span><br><span class="line">                    break;</span><br><span class="line"> </span><br><span class="line">                &#125;</span><br><span class="line">                ++index;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            if (hasFound) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        if (!hasFound) &#123;</span><br><span class="line"> </span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line"> </span><br><span class="line">                [MLeaksMessenger alertWithTitle:@&quot;Retain Cycle&quot;</span><br><span class="line"> </span><br><span class="line">                                        message:@&quot;Fail to find a retain cycle&quot;];</span><br><span class="line"> </span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  </span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NSObject+MemoryLeak主要功能存储对象的父子节点的树形结构，method swizzle逻辑 ，白名单以及判断对象是否发生内存泄漏</p><p><strong>NSObject+MemoryLeak</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)willDealloc &#123;</span><br><span class="line"> </span><br><span class="line">    NSString *className = NSStringFromClass([self class]);</span><br><span class="line">//通过白名单可以配置哪些对象不纳入检查，例如一些单例</span><br><span class="line">    if ([[NSObject classNamesInWhiteList] containsObject:className])</span><br><span class="line"> </span><br><span class="line">        return NO;</span><br><span class="line"> </span><br><span class="line">    NSNumber *senderPtr = objc_getAssociatedObject([UIApplication sharedApplication], kLatestSenderKey);</span><br><span class="line"> </span><br><span class="line">    if ([senderPtr isEqualToNumber:@((uintptr_t)self)])</span><br><span class="line"> </span><br><span class="line">        return NO;</span><br><span class="line"> </span><br><span class="line">    __weak id weakSelf = self;</span><br><span class="line">//在特定时间检查对象是否已经发生内存泄漏</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)</span><br><span class="line">    ), dispatch_get_main_queue(), ^&#123;</span><br><span class="line"> </span><br><span class="line">        __strong id strongSelf = weakSelf;</span><br><span class="line">//如果对象已经被释放，strongSelf为nil 调用该方法什么也不发生</span><br><span class="line">        [strongSelf assertNotDealloc];</span><br><span class="line"> </span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    return YES;</span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line">//改方法被调用说明改对象已经发生内存泄漏</span><br><span class="line">- (void)assertNotDealloc &#123;</span><br><span class="line">//检查是否已经记录，如果是，不再提示用户</span><br><span class="line">    if ([MLeakedObjectProxy isAnyObjectLeakedAtPtrs:[self parentPtrs]]) &#123;</span><br><span class="line"> </span><br><span class="line">        return;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    [MLeakedObjectProxy addLeakedObject:self];</span><br><span class="line"> </span><br><span class="line">    NSString *className = NSStringFromClass([self class]);</span><br><span class="line"> </span><br><span class="line">    NSLog(@&quot;Possibly Memory Leak.\nIn case that %@ should not be dealloced, </span><br><span class="line">    override -willDealloc in %@ by returning NO.\nView-ViewController stack: %@</span><br><span class="line">    &quot;, className, className, [self viewStack]);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//主要通过递归来记录每个节点在树形结构中的位置，以及父子节点的指针</span><br><span class="line">- (void)willReleaseChildren:(NSArray *)children &#123;</span><br><span class="line"> </span><br><span class="line">    NSArray *viewStack = [self viewStack];</span><br><span class="line"> </span><br><span class="line">    NSSet *parentPtrs = [self parentPtrs];</span><br><span class="line"> </span><br><span class="line">    for (id child in children) &#123;</span><br><span class="line"> </span><br><span class="line">        NSString *className = NSStringFromClass([child class]);</span><br><span class="line"> </span><br><span class="line">        [child setViewStack:[viewStack arrayByAddingObject:className]];</span><br><span class="line"> </span><br><span class="line">        [child setParentPtrs:[parentPtrs setByAddingObject:@((uintptr_t)child)]];</span><br><span class="line"> </span><br><span class="line">        [child willDealloc];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">+ (void)swizzleSEL:(SEL)originalSEL withSEL:(SEL)swizzledSEL &#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//通过预编译控制是否hook方法</span><br><span class="line">#if _INTERNAL_MLF_ENABLED</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line">//通过预编译控制是否检查循环引用</span><br><span class="line">#if _INTERNAL_MLF_RC_ENABLED</span><br><span class="line"> </span><br><span class="line">    // Just find a place to set up FBRetainCycleDetector.</span><br><span class="line"> </span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line"> </span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line"> </span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line"> </span><br><span class="line">            [FBAssociationManager hook];</span><br><span class="line"> </span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    Class class = [self class];</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    Method originalMethod = class_getInstanceMethod(class, originalSEL);</span><br><span class="line"> </span><br><span class="line">    Method swizzledMethod = class_getInstanceMethod(class, swizzledSEL);</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    BOOL didAddMethod =</span><br><span class="line">//class_addMethod主要是用来给某个类添加一个方法，originalSEL相当于是方法名称,method_getIm</span><br><span class="line">//plementtation是方法实现, 它返回一个BOOL类型的值</span><br><span class="line">//在当前class中没有叫originalSEL的方法(</span><br><span class="line">//具体不是看interface里没有没有声明，而是看implementaion文件里有没有方法实现)，</span><br><span class="line">// 并且有swizzledMethod方法的实现</span><br><span class="line">//这个时候该函数会返回true，其他情况均返回false</span><br><span class="line">    class_addMethod(class,</span><br><span class="line"> </span><br><span class="line">                    originalSEL,</span><br><span class="line"> </span><br><span class="line">                    method_getImplementation(swizzledMethod),</span><br><span class="line"> </span><br><span class="line">                    method_getTypeEncoding(swizzledMethod));</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    if (didAddMethod) &#123;</span><br><span class="line">//didAddMethod为true 说明swizzledMethod之前不存在，通过class_addMethod函数添加了一个名字叫origninalSEL，实现是swizzledMoethod函数。</span><br><span class="line">        class_replaceMethod(class,</span><br><span class="line"> </span><br><span class="line">                            swizzledSEL,</span><br><span class="line"> </span><br><span class="line">                            method_getImplementation(originalMethod),</span><br><span class="line"> </span><br><span class="line">                            method_getTypeEncoding(originalMethod));</span><br><span class="line"> </span><br><span class="line">    &#125; else &#123;</span><br><span class="line">//didAddMethod为false 说明swizzledMethod方法已经存在，直接交换二者实现</span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UINavigationController + MemoryLeak 主要是通过UINavigationController的方法去检测子UIViewController页面的生命周期，UIViewController的生命周期由UINavigationController的方法和UIViewController自身的一些方法共同决定的。</p><p><strong>UINavigationController + MemoryLeak</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">//现在在具体的类型中添加方法hook，加载load中并且调用dspatch_once来保证只初始化一次，load是必然会调用的，并且category的load方法调用和类自身的load方法调用是分开的，互不干扰。</span><br><span class="line">+ (void)load &#123;</span><br><span class="line"> </span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line"> </span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line"> </span><br><span class="line">        [self swizzleSEL:@selector(pushViewController:animated:) withSEL:@</span><br><span class="line">        selector(swizzled_pushViewController:animated:)];</span><br><span class="line"> </span><br><span class="line">        [self swizzleSEL:@selector(popViewControllerAnimated:) withSEL:@</span><br><span class="line">        selector(swizzled_popViewControllerAnimated:)];</span><br><span class="line"> </span><br><span class="line">        [self swizzleSEL:@selector(popToViewController:animated:) withSEL:@</span><br><span class="line">        selector(swizzled_popToViewController:animated:)];</span><br><span class="line"> </span><br><span class="line">        [self swizzleSEL:@selector(popToRootViewControllerAnimated:) withSEL:@</span><br><span class="line">        selector(swizzled_popToRootViewControllerAnimated:)];</span><br><span class="line"> </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">- (void)swizzled_pushViewController:(UIViewController *)viewController</span><br><span class="line"> animated:(BOOL)animated &#123;</span><br><span class="line"> </span><br><span class="line">    if (self.splitViewController) &#123;</span><br><span class="line">//这里主要是考虑到app中有使用splitViewController的情况的时候，下一个根页面push之后，</span><br><span class="line">//之前被pop的根页面才会回收</span><br><span class="line">        id detailViewController = objc_getAssociatedObject(self, </span><br><span class="line">            kPoppedDetailVCKey);</span><br><span class="line"> </span><br><span class="line">        if ([detailViewController isKindOfClass:[UIViewController class]]) &#123;</span><br><span class="line">//回收之前被pop的根页面</span><br><span class="line">            [detailViewController willDealloc];</span><br><span class="line"> </span><br><span class="line">            objc_setAssociatedObject(self, kPoppedDetailVCKey, nil, </span><br><span class="line">                OBJC_ASSOCIATION_RETAIN);</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    [self swizzled_pushViewController:viewController animated:animated];</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">- (UIViewController *)swizzled_popViewControllerAnimated:(BOOL)animated &#123;</span><br><span class="line"> </span><br><span class="line">    UIViewController *poppedViewController = [self swizzled_popViewControllerAnimated:animated];</span><br><span class="line"> </span><br><span class="line">    if (!poppedViewController) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    //当前页面是spliteViewController根页面</span><br><span class="line">    if (self.splitViewController &amp;&amp;</span><br><span class="line"> </span><br><span class="line">        self.splitViewController.viewControllers.firstObject == self &amp;&amp;</span><br><span class="line"> </span><br><span class="line">        self.splitViewController == poppedViewController.splitViewController) &#123;</span><br><span class="line"> </span><br><span class="line">        objc_setAssociatedObject(self, kPoppedDetailVCKey, poppedViewController</span><br><span class="line">            , OBJC_ASSOCIATION_RETAIN);</span><br><span class="line"> </span><br><span class="line">        return poppedViewController;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    // VC is not dealloced until disappear when popped using a left-edge swipe gesture</span><br><span class="line"> </span><br><span class="line">    extern const void *const kHasBeenPoppedKey;</span><br><span class="line"> </span><br><span class="line">    objc_setAssociatedObject(poppedViewController, kHasBeenPoppedKey, @(YES), </span><br><span class="line">    OBJC_ASSOCIATION_RETAIN);</span><br><span class="line"> </span><br><span class="line">    return poppedViewController;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">- (NSArray&lt;UIViewController *&gt; *)swizzled_popToViewController:(</span><br><span class="line">    UIViewController *)viewController animated:(BOOL)animated &#123;</span><br><span class="line"> </span><br><span class="line">    NSArray&lt;UIViewController *&gt; *poppedViewControllers = [self </span><br><span class="line">    swizzled_popToViewController:viewController animated:animated];</span><br><span class="line">     </span><br><span class="line">//一次性pop多个页面的时候，这些页面的viewDidDisappear估计都没有被调用，直接回收了</span><br><span class="line">    for (UIViewController *viewController in poppedViewControllers) &#123;</span><br><span class="line"> </span><br><span class="line">        [viewController willDealloc];</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return poppedViewControllers;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UIViewController + MemoryLeak</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (void)swizzled_viewDidDisappear:(BOOL)animated &#123;</span><br><span class="line">    [self swizzled_viewDidDisappear:animated];</span><br><span class="line">//仅仅当是pop引起viewDidDisappear的时候才释放(当被挡住之后也会调用ViewDidDisappear)</span><br><span class="line">    if ([objc_getAssociatedObject(self, kHasBeenPoppedKey) boolValue]) &#123;</span><br><span class="line"> </span><br><span class="line">        [self willDealloc];</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">- (void)swizzled_dismissViewControllerAnimated:(BOOL)flag </span><br><span class="line">completion:(void (^)(void))completion &#123;</span><br><span class="line"> </span><br><span class="line">    [self swizzled_dismissViewControllerAnimated:flag completion:completion];</span><br><span class="line"> </span><br><span class="line"> //dismiss掉presentedViewController，释放它 (但是什么时候当前viewController被释放呢)</span><br><span class="line">    UIViewController *dismissedViewController = self.presentedViewController;</span><br><span class="line"> </span><br><span class="line">    if (!dismissedViewController &amp;&amp; self.presentingViewController) &#123;</span><br><span class="line">//释放自己</span><br><span class="line">        dismissedViewController = self;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (!dismissedViewController) return;</span><br><span class="line">//以present出来的viewcontroller，不通过DidDisappear去判断是否释放了</span><br><span class="line">    [dismissedViewController willDealloc];</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本原理：&quot;&gt;&lt;a href=&quot;#基本原理：&quot; class=&quot;headerlink&quot; title=&quot;基本原理：&quot;&gt;&lt;/a&gt;基本原理：&lt;/h2&gt;&lt;p&gt;MlLeaksFinder是app运行的过程中，检测内存泄漏的第三方库，可以帮助在代码调试阶段发现问题。通过method swizzled hook 对象生命周期的方法，在对象结束生命周期的时候，在指定时间之后给对象发送某个消息。如果这个时候对象已经被释放，消息不会被执行，如果没有释放说明发生了内存泄漏，消息就会被执行，从而提醒开发人员。通过递归的方式，会记录下某个视图或者controller的树形节点的位置，能更好的帮助定位到具体哪个对象没有被释放。MLLeaksFinder引入了FBRetainCycleDetector，可以检查循环引用。&lt;/p&gt;
&lt;p&gt;内存泄漏分为2种，第1种是对象没有被任何引用，在内存中没有被释放。第2种是对象发生循环引用，无法被释放。在RAC的场景下，通过是2引起的内存泄漏。&lt;/p&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
</feed>
