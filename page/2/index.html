<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta name="description" content="车到山前必有路">
<meta property="og:type" content="website">
<meta property="og:title" content="郑智文">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="郑智文">
<meta property="og:description" content="车到山前必有路">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="郑智文">
<meta name="twitter:description" content="车到山前必有路">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/page/2/"/>


  <title> 郑智文 </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-CN">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">郑智文</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">iOS dev</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首頁
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            歸檔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            標籤
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/25/AFNetworking源码解析1/" itemprop="url">
                  AFNetworking源码解析1
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-01-25T16:38:24+08:00" content="2016-01-25">
              2016-01-25
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/01/25/AFNetworking源码解析1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/25/AFNetworking源码解析1/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="u57FA_u672C_u5185_u5BB9"><a href="#u57FA_u672C_u5185_u5BB9" class="headerlink" title="基本内容"></a>基本内容</h2><p>本节主要介绍iOS中多线程相关的内容，先简单介绍NSOperation的使用，然后结合GCD实现任务之间的管理，比如每个任务完成之后的处理以及任务与任务之间的依赖，所有任务完成之后的处理等，通过AFNetworking源码分析其具体实现。</p>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/01/25/AFNetworking源码解析1/#more" rel="contents">
              閱讀全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/25/ReactiveCocoa2/" itemprop="url">
                  ReactiveCocoa2
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-01-25T16:38:24+08:00" content="2016-01-25">
              2016-01-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分類於</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/郑智文/" itemprop="url" rel="index">
                    <span itemprop="name">郑智文</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/01/25/ReactiveCocoa2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/25/ReactiveCocoa2/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="RACCommand"><a href="#RACCommand" class="headerlink" title="RACCommand"></a>RACCommand</h2><p>理解：个人觉得是对RACSignal的封装，侧重于对事件的信号的封装。有了RACComand，就可以把动作通过它很方便的放到ViewModel中，类似于以下这种方式:</p>
<p>1.在ViewModel中定义RACCommand</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface SubscribeViewModel : NSObject&#10;@property(nonatomic, strong) RACCommand *subscribeCommand;&#10; &#10;@end</span><br></pre></td></tr></table></figure>
<p>2.在ViewModel中处理具体的RACCommand封装的动作信号</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> - (RACCommand *)subscribeCommand &#123;&#10;  if (!_subscribeCommand) &#123;&#10;      NSString *email = self.email;&#10;      _subscribeCommand = [[RACCommand alloc] initWithEnabled:self.emailValidSignal signalBlock:^RACSignal *(id input) &#123;&#10;          return [SubscribeViewModel postEmail:email];&#10;      &#125;];&#10;  &#125;&#10;  return _subscribeCommand;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>input参数是在command调用excute方法的时候传进来的。</p>
<p>3.在ViewController中将ViewModel的RACCommand绑定到控件的事件信号上</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.subscribeButton.rac_command = self.viewModel.subscribeCommand;</span><br></pre></td></tr></table></figure>
<p>如果要对某个行为进行单元测试也非常方便，直接对ViewModel层进行测试就可以了，并且没有任务Uiew层的显示逻辑，纯业务逻辑测起来很方便。如果没有RACCommand，直接通过signal去处理，可能类似这种方式：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[self.button rac_signalForControlEvents:UIControlEventTouchUpInside]subscribeNext:^(id x) &#123;&#10;&#125;];</span><br></pre></td></tr></table></figure>
<p>直接在ViewController中定义了动作的逻辑，没有很好的分离。</p>
<h3 id="u521D_u59CB_u5316"><a href="#u521D_u59CB_u5316" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_subscribeCommand = [[RACCommand alloc] initWithEnabled:self.emailValidSignal signalBlock:^RACSignal *(id input) &#123;&#10;      return [SubscribeViewModel postEmail:email];&#10;&#125;];</span><br></pre></td></tr></table></figure>
<p>signalBlock必须要返回一个信号，不能传nil，如果不想传递信号，则可以创建空的信号</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[RACSignal empty]</span><br></pre></td></tr></table></figure>
<p>RAC</p>
<p>emailValidSignal用来指定创建的命令是否能够执行，self.emailValidSignal定义如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_emailValidSignal = [RACObserve(self, email) map:^id(NSString *email) &#123;&#10;         return @([email isValidEmail]);&#10;     &#125;];</span><br></pre></td></tr></table></figure>
<p>当self.emailValidSignal信号返回数据为yes的时候，_subscribeCommand才能够响应行为</p>
<p>signalBlock是当_subscribeCommand执行的时候会被调用的逻辑，该block返回的是一个包含了命令执行之后结果的signal。</p>
<h3 id="u5C5E_u6027"><a href="#u5C5E_u6027" class="headerlink" title="属性"></a>属性</h3><p>allowsConcurrentExecution代表当该命令正在执行的时候，是否能够再次触发改命令。</p>
<p>RACCommand内部是如何通过它去控制当前命令能不能够被执行以及能不能并发的执行:</p>
<p>以UIButton举例：</p>
<p><strong>UIButton+RACCommandSupport.m</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//UIButton&#30340;enabel&#21644;command&#30340;enabel&#32465;&#23450;&#36215;&#26469;&#20102;&#65292;&#20063;&#23601;&#26159;&#22914;&#26524;command&#30340;enabel&#35774;&#32622;&#26410;false&#65292;&#37027;&#20040;button&#21017;&#19981;&#21487;&#29992;&#12290;&#10; disposable = [command.enabled setKeyPath:@keypath(self.enabled) onObject:self];</span><br></pre></td></tr></table></figure>
<p>以下是RACCommand中有关allowsConcurrentExecution的源码:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (enabledSignal == nil) &#123;&#10;       enabledSignal = [RACSignal return:@YES];&#10;   &#125; else &#123;&#10;       enabledSignal = [[[enabledSignal&#10;           startWith:@YES]&#10;           takeUntil:self.rac_willDeallocSignal]&#10;           replayLast];&#10;   &#125;&#10;   _immediateEnabled = [[RACSignal&#10;       combineLatest:@[ enabledSignal, moreExecutionsAllowed ]]&#10;       and];&#10; &#10;   _enabled = [[[[[self.immediateEnabled&#10;       take:1]&#10;       concat:[[self.immediateEnabled skip:1] deliverOn:RACScheduler.mainThreadScheduler]]&#10;       distinctUntilChanged]&#10;       replayLast]&#10;       setNameWithFormat:@&#34;%@ -enabled&#34;, self];</span><br></pre></td></tr></table></figure>
<p>整个command是否可用，是由immeditateEnable来决定的，而imediateEnabled是取enableSignal和moreExecutionsAllowed的与操作。</p>
<p>enableSignal是command初始化方法传进来的第一个参数。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *immediateExecuting = [RACObserve(self, activeExecutionSignals) map:^(NSArray *activeSignals) &#123;&#10;        return @(activeSignals.count &#62; 0);&#10;    &#125;];&#10; &#10;    RACSignal *moreExecutionsAllowed = [RACSignal&#10;        if:RACObserve(self, allowsConcurrentExecution)&#10;        then:[RACSignal return:@YES]&#10;        else:[immediateExecuting not]];</span><br></pre></td></tr></table></figure>
<p>imediateExecuting是当前正在执行未完成的命令数量的信号，如果command的allowsConcurrentExecution设置的yes，则moreExcutionsAllowed返回yes，反之则取决于有没有正在执行的信号，如果有就返回false，没有返回yes。一个信号是否执行完，根据signal有没有发出complete事件来判断的。</p>
<h3 id="u65B9_u6CD5"><a href="#u65B9_u6CD5" class="headerlink" title="方法"></a>方法</h3><h4 id="excute"><a href="#excute" class="headerlink" title="excute"></a>excute</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal =[command execute:@2];</span><br></pre></td></tr></table></figure>
<p>在command的初始化方法中，有一个signalBlock参数，该block有一个input参数，在command执行excute方法的时候传入的参数被当作signalBlock的input参数传到signalBlock中。比如通常将一个网络请求的封装成一个Command，此时网络请求的参数就可以通过调用excute的时候传入。</p>
<p>这种情况下，获取command执行之后返回的数据可以通过:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal =[command execute:@2];&#10;// &#22312;&#36825;&#37324;&#23601;&#21487;&#20197;&#35746;&#38405;&#20449;&#21495;&#20102; &#10;[signal subscribeNext:^(id x) &#123; &#10;    NSLog(@&#34;%@&#34;,x); &#10;&#125;];</span><br></pre></td></tr></table></figure>
<p><strong>订阅命令完成的信号</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[self.viewModel.subscribeCommand execute:nil] subscribeCompleted:^&#123;&#10;  NSLog(@&#34;The command executed&#34;);&#10;&#125;];</span><br></pre></td></tr></table></figure>
<h4 id="executionSignals"><a href="#executionSignals" class="headerlink" title="executionSignals"></a>executionSignals</h4><p>属于信号中的信号，在subscribeNext中返回的是信号x，再次订阅信号x才能获取具体数据</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[command.executionSignals subscribeNext:^(RACSignal *x) &#123; &#10;       [x subscribeNext:^(id x) &#123; &#10;           NSLog(@&#34;%@&#34;, x); &#10;       &#125;];</span><br></pre></td></tr></table></figure>
<p>也可以直接使用excutionSignals.switchToLatest subscribeNext:获取到数据</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> // &#30417;&#21548;&#30331;&#24405;&#20135;&#29983;&#30340;&#25968;&#25454;&#10;[_LoginCommand.executionSignals.switchToLatest subscribeNext:^(id x) &#123;&#10; &#10;    if ([x isEqualToString:@&#34;&#30331;&#24405;&#25104;&#21151;&#34;]) &#123;&#10;        NSLog(@&#34;&#30331;&#24405;&#25104;&#21151;&#34;);&#10;    &#125;&#10;&#125;];</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/25/ReactiveCocoa1/" itemprop="url">
                  ReactiveCocoa1
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-01-25T16:38:24+08:00" content="2016-01-25">
              2016-01-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分類於</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/郑智文/" itemprop="url" rel="index">
                    <span itemprop="name">郑智文</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/01/25/ReactiveCocoa1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/25/ReactiveCocoa1/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="RACSignal"><a href="#RACSignal" class="headerlink" title="RACSignal"></a>RACSignal</h2><p>RAC中统一的数据接口，控件的事件，包括KVO，timer都可以转化成RACSignal。</p>
<pre><code>创建：

  1.RAC未控件的一部分原来的事件都通过Category的方式定义了event对应的signal，只需要直接拿来使用就好了。

  2.自己创建
</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)createSignal:(RACDisposable * (^)(id&#60;RACSubscriber&#62; subscriber))didSubscribe;</span><br></pre></td></tr></table></figure>
<p>​     3.订阅</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.usernameTextField.rac_textSignal subscribeNext:^(id x) &#123;&#10;  NSLog(@&#34;%@&#34;, x);&#10;&#125;];</span><br></pre></td></tr></table></figure>
<p> 在信号创建的时候，需要传入一个didSubscribe的block，在有其他订阅者订阅这个信号的时候，didSubscribe就会被调用，然后将数据通过subscribeNext的block传入。</p>
<h2 id="u4FE1_u53F7_u4E8B_u4EF6_u7684_u79CD_u7C7B"><a href="#u4FE1_u53F7_u4E8B_u4EF6_u7684_u79CD_u7C7B" class="headerlink" title="信号事件的种类"></a>信号事件的种类</h2><p>1.next，一般情况下，信号处理业务逻辑正常返回的时候，会调用订阅者的sendNext方法将数据传入订阅者，订阅者可以通过过subscribeNext获取数据。</p>
<p>2.error，有时候业务逻辑产生异常的时候，会调用订阅者的sendError方法来告知订阅者产生了异常，订阅者在subscribeNext:erro:中处理异常错误。</p>
<p>3.completed，该事件表示订阅者从信号中移除，之后不再收到消息了，信号生命周期结束。</p>
<p><strong>创建一个请求账号权限的信号</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)requestAccessToTwitterSignal &#123;&#10;  &#10;  // 1 - define an error&#10;  NSError *accessError = [NSError errorWithDomain:RWTwitterInstantDomain&#10;                                             code:RWTwitterInstantErrorAccessDenied&#10;                                         userInfo:nil];&#10;  &#10;  // 2 - create the signal&#10;  @weakify(self)&#10;  return [RACSignal createSignal:^RACDisposable *(id&#60;RACSubscriber&#62; subscriber) &#123;&#10;    // 3 - request access to twitter&#10;    @strongify(self)&#10;    [self.accountStore&#10;       requestAccessToAccountsWithType:self.twitterAccountType&#10;         options:nil&#10;      completion:^(BOOL granted, NSError *error) &#123;&#10;          // 4 - handle the response&#10;          if (!granted) &#123;&#10;            [subscriber sendError:accessError];&#10;          &#125; else &#123;&#10;            [subscriber sendNext:nil];&#10;            [subscriber sendCompleted];&#10;          &#125;&#10;        &#125;];&#10;    return nil;&#10;  &#125;];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>处理请求账号权限的信号</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[self requestAccessToTwitterSignal]&#10;  subscribeNext:^(id x) &#123;&#10;    NSLog(@&#34;Access granted&#34;);&#10;  &#125; error:^(NSError *error) &#123;&#10;    NSLog(@&#34;An error occurred: %@&#34;, error);&#10;  &#125;];</span><br></pre></td></tr></table></figure>
<h2 id="u4FE1_u53F7_u7684_u51E0_u79CD_u64CD_u4F5C"><a href="#u4FE1_u53F7_u7684_u51E0_u79CD_u64CD_u4F5C" class="headerlink" title="信号的几种操作"></a>信号的几种操作</h2><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>将信号过滤，只保留满足block中条件的信号</p>
<p><strong>只保留输入字符串长度大于3的信号</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[self.usernameTextField.rac_textSignal&#10;  filter:^BOOL(id value) &#123;&#10;    NSString *text = value;&#10;    return text.length &#62; 3;&#10;  &#125;]&#10;  subscribeNext:^(id x) &#123;&#10;//&#36825;&#37324;&#21482;&#20250;&#26174;&#31034;&#38271;&#24230;&#22823;&#20110;3&#30340;&#23383;&#31526;&#20018;&#10;    NSLog(@&#34;%@&#34;, x);&#10;  &#125;];</span><br></pre></td></tr></table></figure>
<p>这里的信号先经过filter过滤了一次，再由subscribeNext得到过滤的信号进行处理，其数据流如下图所示：</p>
<p><img src="http://7xqgnx.com1.z0.glb.clouddn.com/RAC1.png" alt=""></p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>把源信号的值映射成一个新的值</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[[self.usernameTextField.rac_textSignal&#10;  map:^id(NSString *text) &#123;&#10;    return @(text.length);&#10;  &#125;]&#10;  filter:^BOOL(NSNumber *length) &#123;&#10;    return [length integerValue] &#62; 3;&#10;  &#125;]&#10;  subscribeNext:^(id x) &#123;&#10;    NSLog(@&#34;%@&#34;, x);&#10;  &#125;];</span><br></pre></td></tr></table></figure>
<p>信号先经过map映射将字符串转化成功了字符串长度的数据，再通过filter过滤掉了字符串长度等于3的信号，最后通过subscribeNext获得最后符合条件的信号，整个过程包含了不同数据类型的变化，过程如下图：</p>
<p><a href="http://7xqgnx.com1.z0.glb.clouddn.com/RAC2.png" target="_blank" rel="external">http://7xqgnx.com1.z0.glb.clouddn.com/RAC2.png</a></p>
<h3 id="combineLatest"><a href="#combineLatest" class="headerlink" title="combineLatest"></a>combineLatest</h3><p>将多个信号合并起来，每一个被合并的信号必须调用过一次sendNext，才能触发合并的信号，最后以元组的形式发出。</p>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>当信号发出的内容是元组时，可以使用它将元组聚合成一个值。</p>
<p>将对姓名和密码的验证结果的两种信合合并成一个信号，再通过reduce返回最终是否验证通过的信号。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signUpActiveSignal =&#10;  [RACSignal combineLatest:@[validUsernameSignal, validPasswordSignal]&#10;                    reduce:^id(NSNumber *usernameValid, NSNumber *passwordValid) &#123;&#10;                      return @([usernameValid boolValue] &#38;&#38; [passwordValid boolValue]);&#10;                    &#125;];</span><br></pre></td></tr></table></figure>
<p>数据流的状态：</p>
<p><img src="http://7xqgnx.com1.z0.glb.clouddn.com/RAC3.png" alt=""></p>
<h3 id="doNext"><a href="#doNext" class="headerlink" title="doNext"></a>doNext</h3><p>在每次信号执行订阅者的Next方法之前，会调用这个方法，它对信号本身不会产生影响。</p>
<p>在按钮点击之后，会有一系列验证的过程，在这期间，按钮不能被再次点击，等待验证结果出来之后，在恢复按钮未正常使用的状态。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[[[self.signInButton&#10;  rac_signalForControlEvents:UIControlEventTouchUpInside]&#10;  doNext:^(id x) &#123;&#10;    self.signInButton.enabled = NO;&#10;    self.signInFailureText.hidden = YES;&#10;  &#125;]&#10;  flattenMap:^id(id x) &#123;&#10;    return [self signInSignal];&#10;  &#125;]&#10;  subscribeNext:^(NSNumber *signedIn) &#123;&#10;    self.signInButton.enabled = YES;&#10;    BOOL success = [signedIn boolValue];&#10;    self.signInFailureText.hidden = success;&#10;    if (success) &#123;&#10;      [self performSegueWithIdentifier:@&#34;signInSuccess&#34; sender:self];&#10;    &#125;&#10;  &#125;];</span><br></pre></td></tr></table></figure>
<p>数据流的状态：</p>
<p><img src="http://7xqgnx.com1.z0.glb.clouddn.com/RAC4.png" alt=""></p>
<h3 id="then"><a href="#then" class="headerlink" title="then"></a>then</h3><p>用于连接两个信号，当第一个信号完成之后(前一个信号调用sendCompleted)，才会连接then返回的信号，then之前的信号会被忽略</p>
<p>在得到否有权限获得账户信息之后，通过then获取搜索文本的信号，再验证搜索文本的有效性，最后获取有效的搜索文本。如果获取账号信息这一步出现错误，直接调用最后的error的block。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[[[self requestAccessToTwitterSignal]&#10;  then:^RACSignal *&#123;&#10;    @strongify(self)&#10;    return self.searchText.rac_textSignal;&#10;  &#125;]&#10;  filter:^BOOL(NSString *text) &#123;&#10;    @strongify(self)&#10;    return [self isValidSearchText:text];&#10;  &#125;]&#10;  subscribeNext:^(id x) &#123;&#10;    NSLog(@&#34;%@&#34;, x);&#10;  &#125; error:^(NSError *error) &#123;&#10;    NSLog(@&#34;An error occurred: %@&#34;, error);&#10;  &#125;];</span><br></pre></td></tr></table></figure>
<p>数据流如下图：</p>
<p><img src="http://7xqgnx.com1.z0.glb.clouddn.com/RAC5.png" alt=""></p>
<h3 id="deliverOn"><a href="#deliverOn" class="headerlink" title="deliverOn"></a>deliverOn</h3><p>信号传递切换到指定线程中</p>
<p>现在创建一个信号在后台线程下载一个图片，可以考虑使用<strong>SDWebImage</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(RACSignal *)signalForLoadingImage:(NSString *)imageUrl &#123;&#10;  &#10;  RACScheduler *scheduler = [RACScheduler&#10;                         schedulerWithPriority:RACSchedulerPriorityBackground];&#10;  &#10;  return [[RACSignal createSignal:^RACDisposable *(id&#60;RACSubscriber&#62; subscriber) &#123;&#10;    NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:imageUrl]];&#10;    UIImage *image = [UIImage imageWithData:data];&#10;    [subscriber sendNext:image];&#10;    [subscriber sendCompleted];&#10;    return nil;&#10;  &#125;] subscribeOn:scheduler];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>图片下载完成之后切换到主线程，设置图片的显示</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cell.twitterAvatarView.image = nil;&#10;  &#10;[[[self signalForLoadingImage:tweet.profileImageUrl]&#10;  deliverOn:[RACScheduler mainThreadScheduler]]&#10;  subscribeNext:^(UIImage *image) &#123;&#10;   cell.twitterAvatarView.image = image;&#10;  &#125;];</span><br></pre></td></tr></table></figure>
<h3 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h3><p>节流，可以设置某一段时间内不发送信号，等过了这段时间，将最新的信号发出</p>
<p>在用户输入搜索文字的时候，每一次textChange都会触发搜索结果的网络请求。请求次数过于频繁且没有必要，因为有时候可能是用户还没有输完而已。并且结果频繁的显示清空体验也不好。现在通过throttle处理每经过0.5秒处理一次搜索请求。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[[[[[[self requestAccessToTwitterSignal]&#10;  then:^RACSignal *&#123;&#10;    @strongify(self)&#10;    return self.searchText.rac_textSignal;&#10;  &#125;]&#10;  filter:^BOOL(NSString *text) &#123;&#10;    @strongify(self)&#10;    return [self isValidSearchText:text];&#10;  &#125;]&#10;  throttle:0.5]&#10;  flattenMap:^RACStream *(NSString *text) &#123;&#10;    @strongify(self)&#10;    return [self signalForSearchWithText:text];&#10;  &#125;]&#10;  deliverOn:[RACScheduler mainThreadScheduler]]&#10;  subscribeNext:^(NSDictionary *jsonSearchResult) &#123;&#10;    NSArray *statuses = jsonSearchResult[@&#34;statuses&#34;];&#10;    NSArray *tweets = [statuses linq_select:^id(id tweet) &#123;&#10;      return [RWTweet tweetWithStatus:tweet];&#10;    &#125;];&#10;    [self.resultsViewController displayTweets:tweets];&#10;  &#125; error:^(NSError *error) &#123;&#10;    NSLog(@&#34;An error occurred: %@&#34;, error);&#10;  &#125;];</span><br></pre></td></tr></table></figure>
<p>经过最后的处理，数据流如下图所示：</p>
<p><img src="http://7xqgnx.com1.z0.glb.clouddn.com/RAC6.png" alt=""></p>
<p>在requestAccessToTwitterSignal和signalForSearchWithText都有可能产生error，最后都会直接调用subscribleNext:error方法。</p>
<h3 id="takeUnitl"><a href="#takeUnitl" class="headerlink" title="takeUnitl"></a>takeUnitl</h3><p>(RACSignal *) 获取信号直到某个信号执行完成</p>
<p>比如，监听某个文本框的文本改变直到当前对象被销毁</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[_textField.rac_textSignal takeUntil:self.rac_willDeallocSignal];</span><br></pre></td></tr></table></figure>
<h3 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h3><p>(NSUInteger) 跳过几个信号，选择忽略不处理</p>
<p>第一次输入不被监听</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[_textField.rac_textSignal skip:1] subscribeNext:^(id x) &#123;&#10; &#10;   NSLog(@&#34;%@&#34;,x);&#10;&#125;];</span><br></pre></td></tr></table></figure>
<h2 id="u5E38_u89C1_u7684_u5B8F"><a href="#u5E38_u89C1_u7684_u5B8F" class="headerlink" title="常见的宏"></a>常见的宏</h2><h3 id="RAC_28object_2C_property_29"><a href="#RAC_28object_2C_property_29" class="headerlink" title="RAC(object, property)"></a>RAC(object, property)</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAC(_titleLabel, text) = [viewModel.titleSignal takeUntil:self.rac_prepareForReuseSignal];</span><br></pre></td></tr></table></figure>
<p>表示将一个对象的属性和一个signal进行绑定，signal每产生一个value，都会自动执行如下代码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[TARGET setValue:value ?: NIL_VALUE forKeyPath:KEYPATH];</span><br></pre></td></tr></table></figure>
<h3 id="RACObserve_28TARGET_2C_KEYPATH_29"><a href="#RACObserve_28TARGET_2C_KEYPATH_29" class="headerlink" title="RACObserve(TARGET, KEYPATH)"></a>RACObserve(TARGET, KEYPATH)</h3><p>返回一个signal，检测target的keypath属性</p>
<p>RAC和RACObserve用在一起实现双向绑定</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAC(self.outputLabel, text) = RACObserve(self.model, name);</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/25/ReactCocoa源码分析1/" itemprop="url">
                  ReactCocoa源码分析1
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-01-25T16:38:24+08:00" content="2016-01-25">
              2016-01-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分類於</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/郑智文/" itemprop="url" rel="index">
                    <span itemprop="name">郑智文</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/01/25/ReactCocoa源码分析1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/25/ReactCocoa源码分析1/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="u95EE_u98981"><a href="#u95EE_u98981" class="headerlink" title="问题1"></a>问题1</h2><p>在看代码的时候，发现代码中使用到了</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidload&#10;&#123;&#10;    [super viewDidload];&#10;    [self bindData];&#10;&#125;&#10;  &#10;- (void)bindData&#10;&#123;&#10;    [[RACObserve(self, propertyA) ignore:nil] subscribeNext:^(NSArray *dataA) &#123;&#10;        NSLog(@&#34;use dataA&#34;);&#10;    &#125;];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>但是在这个类的propertyA是在init之后去设置的，在viewDidload之前。也就是在使用RAC订阅属性变化信号之前，但是use dataA打印出来了。猜测RACObserve宏生成信号在调用subscribeNext中，直接就调用了dataA的block的逻辑。但是感觉比较奇怪，不应该是propertyA变化的时候才会调用dataA的block的逻辑吗。</p>
<p>现在具体看一下，一个信号的创建和订阅的源码：</p>
<h3 id="u4FE1_u53F7_u521B_u5EFA_uFF1A"><a href="#u4FE1_u53F7_u521B_u5EFA_uFF1A" class="headerlink" title="信号创建："></a>信号创建：</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)createSignal:(RACDisposable * (^)(id&#60;RACSubscriber&#62; subscriber))didSubscribe &#123;&#10; &#10;    return [RACDynamicSignal createSignal:didSubscribe];&#10; &#10;&#125;&#10;+ (RACSignal *)createSignal:(RACDisposable * (^)(id&#60;RACSubscriber&#62; subscriber))didSubscribe &#123;&#10; &#10;    RACDynamicSignal *signal = [[self alloc] init];&#10; &#10;    signal-&#62;_didSubscribe = [didSubscribe copy];&#10; &#10;    return [signal setNameWithFormat:@&#34;+createSignal:&#34;];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在创建一个信号的时候，会传进来一个叫didSubscribe的block，该信号会把它存下来。</p>
<h3 id="u4FE1_u53F7_u8BA2_u9605"><a href="#u4FE1_u53F7_u8BA2_u9605" class="headerlink" title="信号订阅"></a>信号订阅</h3><p>RACSignal的subscribeNext方法:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock &#123;&#10;    NSCParameterAssert(nextBlock != NULL);&#10;    RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:NULL completed:NULL];&#10;    return [self subscribe:o];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在singal的subscribeNext中，生成了一个subscriber。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)subscriberWithNext:(void (^)(id x))next error:(void (^)(NSError *error))error completed:(void (^)(void))completed &#123;&#10; &#10;    RACSubscriber *subscriber = [[self alloc] init];&#10; &#10; &#10;    subscriber-&#62;_next = [next copy];&#10; &#10;    subscriber-&#62;_error = [error copy];&#10; &#10;    subscriber-&#62;_completed = [completed copy];&#10; &#10;    return subscriber;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>subscriber保存了nextBlock，errorBlock，completedBlock等数据信息</p>
<p>接着看signal的subscribe方法，改方法的参数是subscribeNext方法中生成的subscriber对象</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribe:(id&#60;RACSubscriber&#62;)subscriber &#123;&#10; &#10;    NSCParameterAssert(subscriber != nil);&#10; &#10;    RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];&#10; &#10;    subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable];&#10; &#10; &#10;    if (self.didSubscribe != NULL) &#123;&#10; &#10;        RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123;&#10; &#10;            RACDisposable *innerDisposable = self.didSubscribe(subscriber);&#10; &#10;            [disposable addDisposable:innerDisposable];&#10; &#10;        &#125;];&#10; &#10; &#10;        [disposable addDisposable:schedulingDisposable];&#10; &#10;    &#125;&#10; &#10;    return disposable;&#10; &#10;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)schedule:(void (^)(void))block &#123;&#10;    NSCParameterAssert(block != NULL);&#10; &#10;    if (RACScheduler.currentScheduler == nil) return [self.backgroundScheduler schedule:block];&#10; &#10;    block();&#10; &#10;    return nil;&#10; &#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在signal的subscribe方法中，调用了RACScheduler.subscriptionScheduler schedule 方法，直接就将传入的block调用了，最终调用了signal的didSubscribe block，将subscriber传入。</p>
<p>再看一下RACObserve在生成一个signal的时候，传入的didSubscribe block逻辑的怎样的，以下是RACObserve相关源码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define RACObserve(TARGET, KEYPATH) \&#10; &#10;    (&#123; \&#10; &#10;        _Pragma(&#34;clang diagnostic push&#34;) \&#10; &#10;        _Pragma(&#34;clang diagnostic ignored \&#34;-Wreceiver-is-weak\&#34;&#34;) \&#10; &#10;        __weak id target_ = (TARGET); \&#10; &#10;        [target_ rac_valuesForKeyPath:@keypath(TARGET, KEYPATH) observer:self]; \&#10; &#10;        _Pragma(&#34;clang diagnostic pop&#34;) \&#10; &#10;    &#125;)</span><br></pre></td></tr></table></figure>
<p>在NSObject的RACPropertySubscribing分类中定义rac_valuesForKeyPath:observer:self:方法</p>
<p>继续：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)rac_valuesForKeyPath:(NSString *)keyPath observer:(__weak NSObject *)observer &#123;&#10; &#10;    return [[[self&#10; &#10;        rac_valuesAndChangesForKeyPath:keyPath options:NSKeyValueObservingOptionInitial observer:observer]&#10; &#10;        map:^(RACTuple *value) &#123;&#10; &#10;            // -map: because it doesn&#39;t require the block trampoline that -reduceEach: uses&#10; &#10;            return value[0];&#10; &#10;        &#125;]&#10; &#10;        setNameWithFormat:@&#34;RACObserve(%@, %@)&#34;, self.rac_description, keyPath];&#10; &#10;&#125;</span><br></pre></td></tr></table></figure>
<p>继续：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)rac_valuesAndChangesForKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options observer:(__weak NSObject *)weakObserver &#123;&#10; &#10;    NSObject *strongObserver = weakObserver;&#10; &#10;    keyPath = [keyPath copy];&#10; &#10;    NSRecursiveLock *objectLock = [[NSRecursiveLock alloc] init];&#10; &#10;    objectLock.name = @&#34;org.reactivecocoa.ReactiveCocoa.NSObjectRACPropertySubscribing&#34;;&#10; &#10;    __weak NSObject *weakSelf = self;&#10; &#10;    RACSignal *deallocSignal = [[RACSignal&#10; &#10;        zip:@[&#10; &#10;            self.rac_willDeallocSignal,&#10; &#10;            strongObserver.rac_willDeallocSignal ?: [RACSignal never]&#10; &#10;        ]]&#10; &#10;        doCompleted:^&#123;&#10; &#10;            // Forces deallocation to wait if the object variables are currently&#10; &#10;            // being read on another thread.&#10; &#10;            [objectLock lock];&#10; &#10;            @onExit &#123;&#10; &#10;                [objectLock unlock];&#10; &#10;            &#125;;&#10; &#10;        &#125;];&#10; &#10;//&#37325;&#28857;&#20851;&#27880;&#36825;&#37324;&#65292;createSignal&#20043;&#21518;&#30340;&#21442;&#25968;&#23601;&#26159;&#35813;&#20449;&#21495;&#30340;didSubscribe block&#36923;&#36753;&#20102;&#12290;&#10;    return [[[RACSignal&#10; &#10;        createSignal:^ RACDisposable * (id&#60;RACSubscriber&#62; subscriber) &#123;&#10; &#10;            // Hold onto the lock the whole time we&#39;re setting up the KVO&#10; &#10;            // observation, because any resurrection that might be caused by our&#10; &#10;            // retaining below must be balanced out by the time -dealloc returns&#10; &#10;            // (if another thread is waiting on the lock above).&#10; &#10;            [objectLock lock];&#10; &#10;            @onExit &#123;&#10; &#10;                [objectLock unlock];&#10; &#10;            &#125;;&#10; &#10;            __strong NSObject *observer __attribute__((objc_precise_lifetime)) = weakObserver;&#10; &#10;            __strong NSObject *self __attribute__((objc_precise_lifetime)) = weakSelf;&#10; &#10;            if (self == nil) &#123;&#10; &#10;                [subscriber sendCompleted];&#10; &#10;                return nil;&#10; &#10;            &#125;&#10; &#10; &#10;            return [self rac_observeKeyPath:keyPath options:options observer:observer block:^(id value, NSDictionary *change, BOOL causedByDealloc, BOOL affectedOnlyLastComponent) &#123;&#10; &#10;                [subscriber sendNext:RACTuplePack(value, change)];&#10; &#10;            &#125;];&#10; &#10;        &#125;]&#10; &#10;        takeUntil:deallocSignal]&#10; &#10;        setNameWithFormat:@&#34;%@ -rac_valueAndChangesForKeyPath: %@ options: %lu observer: %@&#34;, self.rac_description, keyPath, (unsigned long)options, strongObserver.rac_description];&#10; &#10;&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在RACObserver宏定义的signal的didSubscriber block中又调用了rac_observeKeyPath:keyPath options: observer: block</p>
<p>继续(太长了只贴重点)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)rac_observeKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options observer:(__weak NSObject *)weakObserver block:(void (^)(id, NSDictionary *, BOOL, BOOL))block &#123;&#10; &#10;    NSCParameterAssert(block != nil);&#10; &#10;    NSCParameterAssert(keyPath.rac_keyPathComponents.count &#62; 0);&#10; &#10;    //&#30465;&#30053;&#25968;&#21313;&#34892;&#10;    // Call the block with the initial value if needed.&#10; &#10;    if ((options &#38; NSKeyValueObservingOptionInitial) != 0) &#123;&#10; &#10;        id initialValue = [self valueForKeyPath:keyPath];&#10; &#10;        NSDictionary *initialChange = @&#123;&#10; &#10;            NSKeyValueChangeKindKey: @(NSKeyValueChangeSetting),&#10; &#10;            NSKeyValueChangeNewKey: initialValue ?: NSNull.null,&#10; &#10;        &#125;;&#10; &#10;        block(initialValue, initialChange, NO, keyPathHasOneComponent);&#10; &#10;    &#125;&#10;     &#10;    //&#30465;&#30053;&#25968;&#21313;&#34892;&#10; &#10;&#125;</span><br></pre></td></tr></table></figure>
<p>说明一下，options是NSKeyValueObservingOptions属于NS_OPTIONS</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, NSKeyValueObservingOptions) &#123;&#10; &#10;    NSKeyValueObservingOptionNew = 0x01,&#10; &#10;    NSKeyValueObservingOptionOld = 0x02,&#10; &#10;    NSKeyValueObservingOptionInitial NS_ENUM_AVAILABLE(10_5, 2_0) = 0x04,&#10; &#10;    NSKeyValueObservingOptionPrior NS_ENUM_AVAILABLE(10_5, 2_0) = 0x08&#10;&#125;;</span><br></pre></td></tr></table></figure>
<p>在以上方法中，它判断了，传入的options是否是NSKeyValueObservingOptionInitial类型，而在调用rac_observeKeyPath: options: observer: block:的时候，option就是传的NSKeyValueObservingOptionInitial，所以会直接调用传进来的block，在rac_valuesAndChangesForKeyPath: options: observer:中调用rac_observeKeyPath: options: observer: block:的时候传入block里面的逻辑是这样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[subscriber sendNext:RACTuplePack(value, change)];</span><br></pre></td></tr></table></figure>
<p>综上所述，RACObserver生成的signal在调用subscribeNext方法订阅该信号的时候，会直接调用一次订阅信号之后next block的逻辑，所以即便是属性变化之后订阅属性变化信号，它也会默认先调用一次next block的逻辑。</p>
<p>正常kvo检测转化成信号的逻辑：</p>
<p>在RACObserver初始化的过程中，</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)rac_observeKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options observer:(__weak NSObject *)weakObserver block:(void (^)(id, NSDictionary *, BOOL, BOOL))block &#123;&#10; &#10;    NSCParameterAssert(block != nil);&#10; &#10;    NSCParameterAssert(keyPath.rac_keyPathComponents.count &#62; 0);&#10; &#10;    //&#30465;&#30053;&#25968;&#21313;&#34892;&#10; &#10;    NSKeyValueObservingOptions trampolineOptions = (options | NSKeyValueObservingOptionPrior) &#38; ~NSKeyValueObservingOptionInitial;&#10; &#10;    RACKVOTrampoline *trampoline = [[RACKVOTrampoline alloc] initWithTarget:self observer:strongObserver keyPath:keyPathHead options:trampolineOptions block:^(id trampolineTarget, id trampolineObserver, NSDictionary *change) &#123;&#10; &#10;        // If this is a prior notification, clean up all the callbacks added to the&#10; &#10;        // previous value and call the callback block. Everything else is deferred&#10; &#10;        // until after we get the notification after the change.&#10; &#10;        if ([change[NSKeyValueChangeNotificationIsPriorKey] boolValue]) &#123;&#10; &#10;            [firstComponentDisposable() dispose];&#10; &#10;            if ((options &#38; NSKeyValueObservingOptionPrior) != 0) &#123;&#10; &#10;                block([trampolineTarget valueForKeyPath:keyPath], change, NO, keyPathHasOneComponent);&#10; &#10;            &#125;&#10;            return;&#10; &#10;        &#125;&#10; &#10;        // From here the notification is not prior.&#10; &#10;        NSObject *value = [trampolineTarget valueForKey:keyPathHead];&#10; &#10; &#10;        // If the value has changed but is nil, there is no need to add callbacks to&#10; &#10;        // it, just call the callback block.&#10; &#10;        if (value == nil) &#123;&#10;            block(nil, change, NO, keyPathHasOneComponent);&#10; &#10;            return;&#10;        &#125;&#10; &#10;        // From here the notification is not prior and the value is not nil.&#10; &#10; &#10;        // Create a new firstComponentDisposable while getting rid of the old one at&#10; &#10;        // the same time, in case this is being called concurrently.&#10; &#10;        RACDisposable *oldFirstComponentDisposable = [firstComponentSerialDisposable swapInDisposable:[RACCompoundDisposable compoundDisposable]];&#10; &#10;        [oldFirstComponentDisposable dispose];&#10; &#10;        addDeallocObserverToPropertyValue(value);&#10; &#10; &#10;        // If there are no further key path components, there is no need to add the&#10; &#10;        // other callbacks, just call the callback block with the value itself.&#10; &#10;        if (keyPathHasOneComponent) &#123;&#10; &#10;            block(value, change, NO, keyPathHasOneComponent);&#10; &#10;            return;&#10; &#10;        &#125;&#10; &#10;        // The value has changed, is not nil, and there are more key path components&#10; &#10;        // to consider. Add the callbacks to the value for the remaining key path&#10; &#10;        // components and call the callback block with the current value of the full&#10; &#10;        // key path.&#10; &#10;        addObserverToValue(value);&#10; &#10;        block([value valueForKeyPath:keyPathTail], change, NO, keyPathHasOneComponent);&#10; &#10;    &#125;];&#10; &#10;    // Stop the KVO observation when this one is disposed of.&#10; &#10;    [disposable addDisposable:trampoline];&#10;  &#10;    //&#30465;&#30053;&#25968;&#21313;&#34892;&#10; &#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在该方法中生成了一个RACKVOTrampoline中间对象，看它的源码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)initWithTarget:(__weak NSObject *)target observer:(__weak NSObject *)observer keyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options block:(RACKVOBlock)block &#123;&#10; &#10;    NSCParameterAssert(keyPath != nil);&#10; &#10;    NSCParameterAssert(block != nil);&#10; &#10;    NSObject *strongTarget = target;&#10; &#10;    if (strongTarget == nil) return nil;&#10; &#10;    self = [super init];&#10; &#10;    if (self == nil) return nil;&#10;    _keyPath = [keyPath copy];&#10; &#10;    _block = [block copy];&#10; &#10;    _weakTarget = target;&#10; &#10;    _unsafeTarget = strongTarget;&#10; &#10;    _observer = observer;&#10; &#10;    [RACKVOProxy.sharedProxy addObserver:self forContext:(__bridge void *)self];&#10; &#10;    [strongTarget addObserver:RACKVOProxy.sharedProxy forKeyPath:self.keyPath options:options context:(__bridge void *)self];&#10; &#10;    [strongTarget.rac_deallocDisposable addDisposable:self];&#10; &#10;    [self.observer.rac_deallocDisposable addDisposable:self];&#10;    return self;&#10;&#125;&#10; &#10;- (void)dealloc &#123;&#10; &#10;    [self dispose];&#10; &#10;&#125;&#10; &#10;#pragma mark Observation&#10; &#10;- (void)dispose &#123;&#10; &#10;    NSObject *target;&#10; &#10;    NSObject *observer;&#10; &#10;    @synchronized (self) &#123;&#10; &#10;        _block = nil;&#10; &#10; &#10;        // The target should still exist at this point, because we still need to&#10; &#10;        // tear down its KVO observation. Therefore, we can use the unsafe&#10; &#10;        // reference (and need to, because the weak one will have been zeroed by&#10; &#10;        // now).&#10; &#10;        target = self.unsafeTarget;&#10; &#10;        observer = self.observer;&#10; &#10; &#10; &#10; &#10;        _unsafeTarget = nil;&#10; &#10;        _observer = nil;&#10; &#10;    &#125;&#10; &#10;    [target.rac_deallocDisposable removeDisposable:self];&#10; &#10;    [observer.rac_deallocDisposable removeDisposable:self];&#10; &#10;    [target removeObserver:RACKVOProxy.sharedProxy forKeyPath:self.keyPath context:(__bridge void *)self];&#10; &#10;    [RACKVOProxy.sharedProxy removeObserver:self forContext:(__bridge void *)self];&#10;&#125;&#10; &#10; &#10;//&#31995;&#32479;&#30340;&#20195;&#29702;&#26041;&#27861;&#65292;&#20854;&#23454;&#26159;&#30001;RACKVOProxy.sharedProxy&#23545;&#35937;&#36716;&#21457;&#30340;&#65292;RACKVOProxy.sharedProxy&#25165;&#26159;&#30495;&#27491;&#22788;&#29702;&#31995;&#32479;&#28040;&#24687;&#30340;&#23545;&#35937;&#12290;&#10;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context &#123;&#10; &#10;    if (context != (__bridge void *)self) &#123;&#10; &#10;        [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];&#10; &#10;        return;&#10; &#10;    &#125;&#10; &#10;    RACKVOBlock block;&#10; &#10;    id observer;&#10; &#10;    id target;&#10; &#10;    @synchronized (self) &#123;&#10; &#10;        block = self.block;&#10; &#10;        observer = self.observer;&#10; &#10;        target = self.weakTarget;&#10; &#10;    &#125;&#10; &#10;    if (block == nil || target == nil) return;&#10; &#10;    block(target, observer, change);&#10; &#10;&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到RACKVOTrampoline对象替代原来使用KVO的对象，作为系统的代理，实现了代理方法。实际上，真正调用系统KVO注册的方法的时候，是往一个叫RACKVOProxy.sharedProxy的全局单例对象注册的。RACKVOTrampoline是具体处理KVO消息的对象，在RACKVOPorxy.shareProxy对象中注册了所有使用RAC KVO的系统消息，再由它转发给具体的RACKVOTrampoline进行处理，而在RACKVOTrampoline处理的时候，调用了RACKVOtrampoline初始化的时候传进来的block。之后在RACKVOTrampoline参数block调用过程中就会调用sendNext方法了，往外面发信号数据。</p>
<p>以下是RACKVOProxy.sharedProxy</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface RACKVOProxy()&#10; &#10;@property (strong, nonatomic, readonly) NSMapTable *trampolines;&#10; &#10;@property (strong, nonatomic, readonly) dispatch_queue_t queue;&#10; &#10; &#10;@end&#10; &#10;@implementation RACKVOProxy&#10; &#10; &#10;+ (instancetype)sharedProxy &#123;&#10; &#10;    static RACKVOProxy *proxy;&#10; &#10;    static dispatch_once_t onceToken;&#10; &#10; &#10; &#10; &#10;    dispatch_once(&#38;onceToken, ^&#123;&#10; &#10;        proxy = [[self alloc] init];&#10; &#10;    &#125;);&#10; &#10; &#10; &#10; &#10;    return proxy;&#10; &#10;&#125;&#10; &#10;- (instancetype)init &#123;&#10; &#10;    self = [super init];&#10; &#10;    if (self == nil) return nil;&#10; &#10; &#10; &#10; &#10;    _queue = dispatch_queue_create(&#34;org.reactivecocoa.ReactiveCocoa.RACKVOProxy&#34;, DISPATCH_QUEUE_SERIAL);&#10; &#10;    _trampolines = [NSMapTable strongToWeakObjectsMapTable];&#10; &#10; &#10; &#10; &#10;    return self;&#10; &#10;&#125;&#10; &#10;- (void)addObserver:(__weak NSObject *)observer forContext:(void *)context &#123;&#10; &#10;    NSValue *valueContext = [NSValue valueWithPointer:context];&#10; &#10; &#10; &#10; &#10;    dispatch_sync(self.queue, ^&#123;&#10; &#10;        [self.trampolines setObject:observer forKey:valueContext];&#10; &#10;    &#125;);&#10; &#10;&#125;&#10; &#10;- (void)removeObserver:(NSObject *)observer forContext:(void *)context &#123;&#10; &#10;    NSValue *valueContext = [NSValue valueWithPointer:context];&#10; &#10; &#10; &#10; &#10;    dispatch_sync(self.queue, ^&#123;&#10; &#10;        [self.trampolines removeObjectForKey:valueContext];&#10; &#10;    &#125;);&#10; &#10;&#125;&#10; &#10;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context &#123;&#10; &#10;    NSValue *valueContext = [NSValue valueWithPointer:context];&#10; &#10;    __block NSObject *trueObserver;&#10; &#10; &#10; &#10; &#10;    dispatch_sync(self.queue, ^&#123;&#10; &#10;        trueObserver = [self.trampolines objectForKey:valueContext];&#10; &#10;    &#125;);&#10; &#10; &#10; &#10;    if (trueObserver != nil) &#123;&#10; &#10;        [trueObserver observeValueForKeyPath:keyPath ofObject:object change:change context:context];&#10; &#10;    &#125;&#10; &#10;&#125;</span><br></pre></td></tr></table></figure>
<p>RACKVOProxy.sharedProxy管理了整个RAC 中KVO的处理系统KVO消息的中间对象和系统KVO消息的转发。</p>
<p>综合上面的代码可以看出，正是由于各种中间对象替用户实现了代理方法起了代理对象的作用，用户才能把代码写的更加紧凑清晰。</p>
<h2 id="u95EE_u98982"><a href="#u95EE_u98982" class="headerlink" title="问题2"></a>问题2</h2><p>看以下代码，假设combineLatest之后得到的信号是A</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RACSignal combineLatest:@[[RACObserve(self, propertyA) ignore:nil], [RACObserve(self, propertyB) ignore:nil]]] subscribeNext:^(RACTuple *tuple) &#123;&#10; &#10; &#10;&#125;];</span><br></pre></td></tr></table></figure>
<p>1.使用combineLatest的时候，第一次订阅会不会触发subscribeNext后面的block</p>
<p>2.combineLatest中的信号，是同时调用了sendNext之后会触发A调用sendNext，还是只需要其中有一个信号调用了sendNext会触发A调用sendNext</p>
<p>看一下combineLatest源码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)combineLatest:(id&#60;NSFastEnumeration&#62;)signals &#123;&#10; &#10;    return [[self join:signals block:^(RACSignal *left, RACSignal *right) &#123;&#10; &#10;        return [left combineLatestWith:right];&#10; &#10;    &#125;] setNameWithFormat:@&#34;+combineLatest: %@&#34;, signals];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>继续 join: block:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)join:(id&#60;NSFastEnumeration&#62;)streams block:(RACStream * (^)(id, id))block &#123;&#10; &#10; &#10;//&#31532;&#19968;&#27573;&#10;    RACStream *current = nil;&#10;    // Creates streams of successively larger tuples by combining the input&#10; &#10;    // streams one-by-one.&#10; &#10;    for (RACStream *stream in streams) &#123;&#10; &#10;        // For the first stream, just wrap its values in a RACTuple. That way,&#10; &#10;        // if only one stream is given, the result is still a stream of tuples.&#10; &#10;        if (current == nil) &#123;&#10; &#10;            current = [stream map:^(id x) &#123;&#10; &#10;                return RACTuplePack(x);&#10; &#10;            &#125;];&#10;            continue;&#10;        &#125;&#10; &#10;        current = block(current, stream);&#10; &#10;    &#125;&#10;    if (current == nil) return [self empty];&#10;//&#31532;&#20108;&#27573;&#10;    return [current map:^(RACTuple *xs) &#123;&#10; &#10;        // Right now, each value is contained in its own tuple, sorta like:&#10; &#10;        //&#10; &#10;        // (((1), 2), 3)&#10; &#10;        //&#10; &#10;        // We need to unwrap all the layers and create a tuple out of the result.&#10; &#10;        NSMutableArray *values = [[NSMutableArray alloc] init];&#10; &#10;        while (xs != nil) &#123;&#10;            [values insertObject:xs.last ?: RACTupleNil.tupleNil atIndex:0];&#10; &#10;            xs = (xs.count &#62; 1 ? xs.first : nil);&#10;        &#125;&#10; &#10;        return [RACTuple tupleWithObjectsFromArray:values];&#10;    &#125;];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这部分代码分2段，第一段是将两个信号合并的逻辑，具体的合并逻辑是由外面传进来的block确定的。第二段是通过map将信号的值重新做了处理，第一段得到的信号属于signal of signals的类型，第二段将它打平。</p>
<p>再看一下combineLatestWith:方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)combineLatestWith:(RACSignal *)signal &#123;&#10;    NSCParameterAssert(signal != nil);&#10; &#10;    return [[RACSignal createSignal:^(id&#60;RACSubscriber&#62; subscriber) &#123;&#10; &#10;        RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];&#10; &#10;        __block id lastSelfValue = nil;&#10; &#10;        __block BOOL selfCompleted = NO;&#10; &#10;        __block id lastOtherValue = nil;&#10; &#10;        __block BOOL otherCompleted = NO;&#10; &#10;        void (^sendNext)(void) = ^&#123;&#10; &#10;            @synchronized (disposable) &#123;&#10; &#10;                if (lastSelfValue == nil || lastOtherValue == nil) return;&#10; &#10;                [subscriber sendNext:RACTuplePack(lastSelfValue, lastOtherValue)];&#10; &#10;            &#125;&#10; &#10;        &#125;;&#10; &#10;        RACDisposable *selfDisposable = [self subscribeNext:^(id x) &#123;&#10; &#10;            @synchronized (disposable) &#123;&#10; &#10;                lastSelfValue = x ?: RACTupleNil.tupleNil;&#10; &#10;                sendNext();&#10; &#10;            &#125;&#10; &#10;        &#125; error:^(NSError *error) &#123;&#10; &#10;            [subscriber sendError:error];&#10; &#10;        &#125; completed:^&#123;&#10; &#10;            @synchronized (disposable) &#123;&#10; &#10;                selfCompleted = YES;&#10; &#10;                if (otherCompleted) [subscriber sendCompleted];&#10; &#10;            &#125;&#10; &#10;        &#125;];&#10; &#10;        [disposable addDisposable:selfDisposable];&#10; &#10;        RACDisposable *otherDisposable = [signal subscribeNext:^(id x) &#123;&#10; &#10;            @synchronized (disposable) &#123;&#10; &#10;                lastOtherValue = x ?: RACTupleNil.tupleNil;&#10; &#10;                sendNext();&#10; &#10;            &#125;&#10; &#10;        &#125; error:^(NSError *error) &#123;&#10; &#10;            [subscriber sendError:error];&#10; &#10;        &#125; completed:^&#123;&#10; &#10;            @synchronized (disposable) &#123;&#10; &#10;                otherCompleted = YES;&#10; &#10;                if (selfCompleted) [subscriber sendCompleted];&#10; &#10;            &#125;&#10; &#10;        &#125;];&#10; &#10;        [disposable addDisposable:otherDisposable];&#10;        return disposable;&#10; &#10;    &#125;] setNameWithFormat:@&#34;[%@] -combineLatestWith: %@&#34;, self.name, signal];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在以上代码中，调用了当前信号的subscribeNext方法，同时也调用了需要合并的信号的subscribeNext方法。subscribeNext方法block中调用了sendNext block，这个block是在combineLatestWith中定义，判断两个信号是否已经调用过sendNext，如果都同时掉用过sendNext就会触发combineLatest信号调用didSubscribe block，最终触发订阅combineLatest信号的传入的subscribeNext后的block。</p>
<p>综合上面的分析，类似于以下的使用方式</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RACSignal combineLatest:@[[RACObserve(self, propertyA) ignore:nil], [RACObserve(self, propertyB) ignore:nil]]] subscribeNext:^(RACTuple *tuple) &#123;&#10; &#10;&#125;];</span><br></pre></td></tr></table></figure>
<p>第一次订阅就会触发subscribeNext之后的block逻辑，并且是RACObserve这种类型的combineLatest才会，最上面已经分析了RACObserver生成的信号在第一次订阅调用的时候信号就会调用sendNext。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/25/MLLeaksFinder源码分析/" itemprop="url">
                  MLLeaksFinder源码分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-01-25T16:38:24+08:00" content="2016-01-25">
              2016-01-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分類於</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/郑智文/" itemprop="url" rel="index">
                    <span itemprop="name">郑智文</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/01/25/MLLeaksFinder源码分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/25/MLLeaksFinder源码分析/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="u57FA_u672C_u539F_u7406_uFF1A"><a href="#u57FA_u672C_u539F_u7406_uFF1A" class="headerlink" title="基本原理："></a>基本原理：</h2><p>MlLeaksFinder是app运行的过程中，检测内存泄漏的第三方库，可以帮助在代码调试阶段发现问题。通过method swizzled hook 对象生命周期的方法，在对象结束生命周期的时候，在指定时间之后给对象发送某个消息。如果这个时候对象已经被释放，消息不会被执行，如果没有释放说明发生了内存泄漏，消息就会被执行，从而提醒开发人员。通过递归的方式，会记录下某个视图或者controller的树形节点的位置，能更好的帮助定位到具体哪个对象没有被释放。MLLeaksFinder引入了FBRetainCycleDetector，可以检查循环引用。</p>
<p>内存泄漏分为2种，第1种是对象没有被任何引用，在内存中没有被释放。第2种是对象发生循环引用，无法被释放。在RAC的场景下，通过是2引起的内存泄漏。</p>
<h2 id="u6E90_u7801_u5206_u6790_uFF1A"><a href="#u6E90_u7801_u5206_u6790_uFF1A" class="headerlink" title="源码分析："></a>源码分析：</h2><p>MLeaksFinder.h定义了MLeaksFinder中使用的宏</p>
<p><strong>MLeaksFinder.h</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#ifdef MEMORY_LEAKS_FINDER_ENABLED&#10; &#10; &#10;//_INTERNAL_MLF_ENABLED &#23439;&#29992;&#26469;&#25511;&#21046; MLLeaksFinder&#24211; &#20160;&#20040;&#26102;&#20505;&#24320;&#21551;&#26816;&#27979;&#65292;&#21487;&#20197;&#33258;&#23450;&#20041;&#36825;&#20010;&#26102;&#26426;&#65292;&#40664;&#35748;&#21017;&#26159;&#22312;DEBUG&#27169;&#24335;&#19979;&#20250;&#21551;&#21160;&#65292;RELEASE&#27169;&#24335;&#19979;&#19981;&#21551;&#21160;&#10;//&#23427;&#26159;&#36890;&#36807;&#39044;&#32534;&#35793;&#26469;&#23454;&#29616;&#30340;&#10;#define _INTERNAL_MLF_ENABLED MEMORY_LEAKS_FINDER_ENABLED&#10; &#10;#else&#10; &#10;#define _INTERNAL_MLF_ENABLED DEBUG&#10; &#10;#endif&#10; &#10;//_INTERNAL_MLF_RC_ENABLED &#23439;&#29992;&#26469;&#25511;&#21046; &#26159;&#21542;&#24320;&#21551;&#24490;&#29615;&#24341;&#29992;&#30340;&#26816;&#27979;&#10;#ifdef MEMORY_LEAKS_FINDER_RETAIN_CYCLE_ENABLED&#10; &#10;#define _INTERNAL_MLF_RC_ENABLED MEMORY_LEAKS_FINDER_RETAIN_CYCLE_ENABLED&#10; &#10; &#10;//COCOAPODS &#22240;&#20026;MLLeaksFinder&#24341;&#29992;&#20102;&#31532;&#19977;&#24211;&#29992;&#26469;&#26816;&#26597;&#24490;&#29615;&#24341;&#29992;&#65292;&#25152;&#20197;&#24517;&#39035;&#26159;&#24403;&#21069;&#39033;&#30446;&#20013;&#20351;&#29992;&#20102;COCOAPODS&#65292;&#25165;&#33021;&#20351;&#29992;&#36825;&#20010;&#21151;&#33021;&#12290;&#10;#elif COCOAPODS&#10; &#10;#define _INTERNAL_MLF_RC_ENABLED COCOAPODS&#10; &#10;#endif</span><br></pre></td></tr></table></figure>
<p>MLLeakeObjectProxy用来对泄漏对象检查循环引用</p>
<p><strong>MLeakedObjectProxy</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//&#29992;&#26469;&#26816;&#26597;&#24403;&#21069;&#27844;&#28431;&#23545;&#35937;&#26159;&#21542;&#24050;&#32463;&#28155;&#21152;&#21040;&#27844;&#28431;&#23545;&#35937;&#38598;&#21512;&#20013;&#65292;&#22914;&#26524;&#26159;&#65292;&#23601;&#19981;&#20877;&#28155;&#21152;&#20063;&#19981;&#20877;&#25552;&#31034;&#24320;&#21457;&#32773;&#10;+ (BOOL)isAnyObjectLeakedAtPtrs:(NSSet *)ptrs&#10;&#123;&#10;    NSAssert([NSThread isMainThread], @&#34;Must be in main thread.&#34;);&#10;  &#10;    static dispatch_once_t onceToken;&#10;    dispatch_once(&#38;onceToken, ^&#123;&#10;//&#20840;&#23616;&#29992;&#20110;&#20445;&#23384;&#27844;&#28431;&#23545;&#35937;&#30340;&#38598;&#21512;&#10;        leakedObjectPtrs = [[NSMutableSet alloc] init];&#10;    &#125;);&#10; &#10;    if (!ptrs.count) &#123;&#10;        return NO;&#10;    &#125;&#10;//NSSet&#27714;&#20132;&#38598;&#10;    if ([leakedObjectPtrs intersectsSet:ptrs]) &#123;&#10;        return YES;&#10;    &#125; else &#123;&#10;        return NO;&#10;    &#125;&#10;&#125;&#10;+ (void)addLeakedObject:(id)object &#123;&#10; &#10;    NSAssert([NSThread isMainThread], @&#34;Must be in main thread.&#34;);&#10; &#10;     &#10;//&#21019;&#24314;&#29992;&#20110;&#26816;&#26597;&#24490;&#29615;&#24341;&#29992;&#30340;objectProxy&#23545;&#35937;&#10;    MLeakedObjectProxy *proxy = [[MLeakedObjectProxy alloc] init];&#10; &#10;    proxy.object = object;&#10; &#10;    proxy.objectPtr = @((uintptr_t)object);&#10; &#10;    proxy.viewStack = [object viewStack];&#10; &#10;    static const void *const kLeakedObjectProxyKey = &#38;kLeakedObjectProxyKey;&#10; &#10;    objc_setAssociatedObject(object, kLeakedObjectProxyKey, proxy, OBJC_ASSOCIATION_RETAIN);&#10; &#10;    [leakedObjectPtrs addObject:proxy.objectPtr];&#10; &#10;     &#10; &#10;#if _INTERNAL_MLF_RC_ENABLED&#10;//&#24102;&#26377;&#24490;&#29615;&#24341;&#29992;&#26816;&#26597;&#21151;&#33021;&#30340;&#25552;&#31034;&#26694;&#10;    [MLeaksMessenger alertWithTitle:@&#34;Memory Leak&#34;&#10; &#10;                            message:[NSString stringWithFormat:@&#34;%@&#34;, proxy.viewStack]&#10; &#10;                           delegate:proxy&#10; &#10;              additionalButtonTitle:@&#34;Retain Cycle&#34;];&#10; &#10;#else&#10;//&#26222;&#36890;&#25552;&#31034;&#26694;&#10;    [MLeaksMessenger alertWithTitle:@&#34;Memory Leak&#34;&#10; &#10;                            message:[NSString stringWithFormat:@&#34;%@&#34;, proxy.viewStack]];&#10; &#10;#endif&#10; &#10;&#125;&#10;- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex &#123;&#10; &#10;#if _INTERNAL_MLF_RC_ENABLED&#10; &#10;    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;&#10; &#10;        FBRetainCycleDetector *detector = [FBRetainCycleDetector new];&#10; &#10;        [detector addCandidate:self.object];&#10; &#10;        NSSet *retainCycles = [detector findRetainCyclesWithMaxCycleLength:20];&#10; &#10;        BOOL hasFound = NO;&#10; &#10;//retainCycles&#20013;&#26159;&#25214;&#21040;&#30340;&#25152;&#26377;&#24490;&#29615;&#24341;&#29992;&#30340;&#38142;&#10;        for (NSArray *retainCycle in retainCycles) &#123;&#10; &#10;            NSInteger index = 0;&#10; &#10;            for (FBObjectiveCGraphElement *element in retainCycle) &#123;&#10;//&#25214;&#21040;&#24403;&#21069;&#20869;&#23384;&#27844;&#28431;&#23545;&#35937;&#25152;&#22312;&#30340;&#24490;&#29615;&#24341;&#29992;&#30340;&#38142;&#10;                if (element.object == object) &#123;&#10;//&#25226;&#24403;&#21069;&#23545;&#35937;&#35843;&#25972;&#21040;&#31532;&#19968;&#20010;&#30340;&#20301;&#32622;&#65292;&#26041;&#20415;&#26597;&#30475;&#10;                    NSArray *shiftedRetainCycle = [self shiftArray:retainCycle toIndex:index];&#10;                   &#10;                    dispatch_async(dispatch_get_main_queue(), ^&#123;&#10; &#10;                        [MLeaksMessenger alertWithTitle:@&#34;Retain Cycle&#34;&#10; &#10;                                                message:[NSString stringWithFormat:@&#34;%@&#34;, shiftedRetainCycle]];&#10; &#10;                    &#125;);&#10; &#10;                    hasFound = YES;&#10; &#10;                    break;&#10; &#10;                &#125;&#10;                ++index;&#10;            &#125;&#10; &#10;            if (hasFound) &#123;&#10;                break;&#10;            &#125;&#10;        &#125;&#10; &#10;        if (!hasFound) &#123;&#10; &#10;            dispatch_async(dispatch_get_main_queue(), ^&#123;&#10; &#10;                [MLeaksMessenger alertWithTitle:@&#34;Retain Cycle&#34;&#10; &#10;                                        message:@&#34;Fail to find a retain cycle&#34;];&#10; &#10;            &#125;);&#10;        &#125;&#10;    &#125;);&#10;  &#10;#endif&#10; &#10;&#125;</span><br></pre></td></tr></table></figure>
<p>NSObject+MemoryLeak主要功能存储对象的父子节点的树形结构，method swizzle逻辑 ，白名单以及判断对象是否发生内存泄漏</p>
<p><strong>NSObject+MemoryLeak</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)willDealloc &#123;&#10; &#10;    NSString *className = NSStringFromClass([self class]);&#10;//&#36890;&#36807;&#30333;&#21517;&#21333;&#21487;&#20197;&#37197;&#32622;&#21738;&#20123;&#23545;&#35937;&#19981;&#32435;&#20837;&#26816;&#26597;&#65292;&#20363;&#22914;&#19968;&#20123;&#21333;&#20363;&#10;    if ([[NSObject classNamesInWhiteList] containsObject:className])&#10; &#10;        return NO;&#10; &#10;    NSNumber *senderPtr = objc_getAssociatedObject([UIApplication sharedApplication], kLatestSenderKey);&#10; &#10;    if ([senderPtr isEqualToNumber:@((uintptr_t)self)])&#10; &#10;        return NO;&#10; &#10;    __weak id weakSelf = self;&#10;//&#22312;&#29305;&#23450;&#26102;&#38388;&#26816;&#26597;&#23545;&#35937;&#26159;&#21542;&#24050;&#32463;&#21457;&#29983;&#20869;&#23384;&#27844;&#28431;&#10;    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;&#10; &#10;        __strong id strongSelf = weakSelf;&#10;//&#22914;&#26524;&#23545;&#35937;&#24050;&#32463;&#34987;&#37322;&#25918;&#65292;strongSelf&#20026;nil &#35843;&#29992;&#35813;&#26041;&#27861;&#20160;&#20040;&#20063;&#19981;&#21457;&#29983;&#10;        [strongSelf assertNotDealloc];&#10; &#10;    &#125;);&#10; &#10;    return YES;&#10;&#125; &#10;  &#10;//&#25913;&#26041;&#27861;&#34987;&#35843;&#29992;&#35828;&#26126;&#25913;&#23545;&#35937;&#24050;&#32463;&#21457;&#29983;&#20869;&#23384;&#27844;&#28431;&#10;- (void)assertNotDealloc &#123;&#10;//&#26816;&#26597;&#26159;&#21542;&#24050;&#32463;&#35760;&#24405;&#65292;&#22914;&#26524;&#26159;&#65292;&#19981;&#20877;&#25552;&#31034;&#29992;&#25143;&#10;    if ([MLeakedObjectProxy isAnyObjectLeakedAtPtrs:[self parentPtrs]]) &#123;&#10; &#10;        return;&#10; &#10;    &#125;&#10; &#10;    [MLeakedObjectProxy addLeakedObject:self];&#10; &#10;    NSString *className = NSStringFromClass([self class]);&#10; &#10;    NSLog(@&#34;Possibly Memory Leak.\nIn case that %@ should not be dealloced, override -willDealloc in %@ by returning NO.\nView-ViewController stack: %@&#34;, className, className, [self viewStack]);&#10; &#10;&#125;&#10;  &#10;//&#20027;&#35201;&#36890;&#36807;&#36882;&#24402;&#26469;&#35760;&#24405;&#27599;&#20010;&#33410;&#28857;&#22312;&#26641;&#24418;&#32467;&#26500;&#20013;&#30340;&#20301;&#32622;&#65292;&#20197;&#21450;&#29238;&#23376;&#33410;&#28857;&#30340;&#25351;&#38024;&#10;- (void)willReleaseChildren:(NSArray *)children &#123;&#10; &#10;    NSArray *viewStack = [self viewStack];&#10; &#10;    NSSet *parentPtrs = [self parentPtrs];&#10; &#10;    for (id child in children) &#123;&#10; &#10;        NSString *className = NSStringFromClass([child class]);&#10; &#10;        [child setViewStack:[viewStack arrayByAddingObject:className]];&#10; &#10;        [child setParentPtrs:[parentPtrs setByAddingObject:@((uintptr_t)child)]];&#10; &#10;        [child willDealloc];&#10;    &#125;&#10;&#125;&#10;+ (void)swizzleSEL:(SEL)originalSEL withSEL:(SEL)swizzledSEL &#123;&#10; &#10; &#10;//&#36890;&#36807;&#39044;&#32534;&#35793;&#25511;&#21046;&#26159;&#21542;hook&#26041;&#27861;&#10;#if _INTERNAL_MLF_ENABLED&#10; &#10;     &#10;//&#36890;&#36807;&#39044;&#32534;&#35793;&#25511;&#21046;&#26159;&#21542;&#26816;&#26597;&#24490;&#29615;&#24341;&#29992;&#10;#if _INTERNAL_MLF_RC_ENABLED&#10; &#10;    // Just find a place to set up FBRetainCycleDetector.&#10; &#10;    static dispatch_once_t onceToken;&#10; &#10;    dispatch_once(&#38;onceToken, ^&#123;&#10; &#10;        dispatch_async(dispatch_get_main_queue(), ^&#123;&#10; &#10;            [FBAssociationManager hook];&#10; &#10;        &#125;);&#10; &#10;    &#125;);&#10; &#10;#endif&#10; &#10;     &#10; &#10;    Class class = [self class];&#10; &#10;     &#10; &#10;    Method originalMethod = class_getInstanceMethod(class, originalSEL);&#10; &#10;    Method swizzledMethod = class_getInstanceMethod(class, swizzledSEL);&#10; &#10;     &#10; &#10;    BOOL didAddMethod =&#10;//class_addMethod&#20027;&#35201;&#26159;&#29992;&#26469;&#32473;&#26576;&#20010;&#31867;&#28155;&#21152;&#19968;&#20010;&#26041;&#27861;&#65292;originalSEL&#30456;&#24403;&#20110;&#26159;&#26041;&#27861;&#21517;&#31216;,method_getImplementtation&#26159;&#26041;&#27861;&#23454;&#29616;, &#23427;&#36820;&#22238;&#19968;&#20010;BOOL&#31867;&#22411;&#30340;&#20540;&#10;//&#22312;&#24403;&#21069;class&#20013;&#27809;&#26377;&#21483;originalSEL&#30340;&#26041;&#27861;(&#20855;&#20307;&#19981;&#26159;&#30475;interface&#37324;&#27809;&#26377;&#27809;&#26377;&#22768;&#26126;&#65292;&#32780;&#26159;&#30475;implementaion&#25991;&#20214;&#37324;&#26377;&#27809;&#26377;&#26041;&#27861;&#23454;&#29616;)&#65292; &#24182;&#19988;&#26377;swizzledMethod&#26041;&#27861;&#30340;&#23454;&#29616;&#10;//&#36825;&#20010;&#26102;&#20505;&#35813;&#20989;&#25968;&#20250;&#36820;&#22238;true&#65292;&#20854;&#20182;&#24773;&#20917;&#22343;&#36820;&#22238;false&#10;    class_addMethod(class,&#10; &#10;                    originalSEL,&#10; &#10;                    method_getImplementation(swizzledMethod),&#10; &#10;                    method_getTypeEncoding(swizzledMethod));&#10; &#10;     &#10; &#10;    if (didAddMethod) &#123;&#10;//didAddMethod&#20026;true &#35828;&#26126;swizzledMethod&#20043;&#21069;&#19981;&#23384;&#22312;&#65292;&#36890;&#36807;class_addMethod&#20989;&#25968;&#28155;&#21152;&#20102;&#19968;&#20010;&#21517;&#23383;&#21483;origninalSEL&#65292;&#23454;&#29616;&#26159;swizzledMoethod&#20989;&#25968;&#12290;&#10;//&#36825;&#31181;&#24773;&#20917;&#21487;&#20197;&#23454;&#29616;&#20132;&#25442;&#20004;&#20010;&#26041;&#27861;&#30340;&#21516;&#26102;&#28155;&#21152;&#19968;&#20010;&#19981;&#21516;&#21517;&#23383;&#30340;&#26041;&#27861;&#12290;&#10;        class_replaceMethod(class,&#10; &#10;                            swizzledSEL,&#10; &#10;                            method_getImplementation(originalMethod),&#10; &#10;                            method_getTypeEncoding(originalMethod));&#10; &#10;    &#125; else &#123;&#10;//didAddMethod&#20026;false &#35828;&#26126;swizzledMethod&#26041;&#27861;&#24050;&#32463;&#23384;&#22312;&#65292;&#30452;&#25509;&#20132;&#25442;&#20108;&#32773;&#23454;&#29616;&#10;        method_exchangeImplementations(originalMethod, swizzledMethod);&#10; &#10;    &#125;&#10; &#10;#endif&#10; &#10;&#125;</span><br></pre></td></tr></table></figure>
<p>UINavigationController + MemoryLeak 主要是通过UINavigationController的方法去检测子UIViewController页面的生命周期，UIViewController的生命周期由UINavigationController的方法和UIViewController自身的一些方法共同决定的。</p>
<p><strong>UINavigationController + MemoryLeak</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//&#29616;&#22312;&#22312;&#20855;&#20307;&#30340;&#31867;&#22411;&#20013;&#28155;&#21152;&#26041;&#27861;hook&#65292;&#21152;&#36733;load&#20013;&#24182;&#19988;&#35843;&#29992;dspatch_once&#26469;&#20445;&#35777;&#21482;&#21021;&#22987;&#21270;&#19968;&#27425;&#65292;load&#26159;&#24517;&#28982;&#20250;&#35843;&#29992;&#30340;&#65292;&#24182;&#19988;category&#30340;load&#26041;&#27861;&#35843;&#29992;&#21644;&#31867;&#33258;&#36523;&#30340;load&#26041;&#27861;&#35843;&#29992;&#26159;&#20998;&#24320;&#30340;&#65292;&#20114;&#19981;&#24178;&#25200;&#12290;&#10;+ (void)load &#123;&#10; &#10;    static dispatch_once_t onceToken;&#10; &#10;    dispatch_once(&#38;onceToken, ^&#123;&#10; &#10;        [self swizzleSEL:@selector(pushViewController:animated:) withSEL:@selector(swizzled_pushViewController:animated:)];&#10; &#10;        [self swizzleSEL:@selector(popViewControllerAnimated:) withSEL:@selector(swizzled_popViewControllerAnimated:)];&#10; &#10;        [self swizzleSEL:@selector(popToViewController:animated:) withSEL:@selector(swizzled_popToViewController:animated:)];&#10; &#10;        [self swizzleSEL:@selector(popToRootViewControllerAnimated:) withSEL:@selector(swizzled_popToRootViewControllerAnimated:)];&#10; &#10;    &#125;);&#10;&#125;&#10;  &#10;- (void)swizzled_pushViewController:(UIViewController *)viewController animated:(BOOL)animated &#123;&#10; &#10;    if (self.splitViewController) &#123;&#10;//&#36825;&#37324;&#20027;&#35201;&#26159;&#32771;&#34385;&#21040;app&#20013;&#26377;&#20351;&#29992;splitViewController&#30340;&#24773;&#20917;&#30340;&#26102;&#20505;&#65292;&#19979;&#19968;&#20010;&#26681;&#39029;&#38754;push&#20043;&#21518;&#65292;&#20043;&#21069;&#34987;pop&#30340;&#26681;&#39029;&#38754;&#25165;&#20250;&#22238;&#25910;&#10;        id detailViewController = objc_getAssociatedObject(self, kPoppedDetailVCKey);&#10; &#10;        if ([detailViewController isKindOfClass:[UIViewController class]]) &#123;&#10;//&#22238;&#25910;&#20043;&#21069;&#34987;pop&#30340;&#26681;&#39029;&#38754;&#10;            [detailViewController willDealloc];&#10; &#10;            objc_setAssociatedObject(self, kPoppedDetailVCKey, nil, OBJC_ASSOCIATION_RETAIN);&#10; &#10;        &#125;&#10; &#10;    &#125;&#10;    [self swizzled_pushViewController:viewController animated:animated];&#10; &#10;&#125;&#10;- (UIViewController *)swizzled_popViewControllerAnimated:(BOOL)animated &#123;&#10; &#10;    UIViewController *poppedViewController = [self swizzled_popViewControllerAnimated:animated];&#10; &#10;    if (!poppedViewController) &#123;&#10;        return nil;&#10;    &#125;&#10;     &#10;    //&#24403;&#21069;&#39029;&#38754;&#26159;spliteViewController&#26681;&#39029;&#38754;&#10;    if (self.splitViewController &#38;&#38;&#10; &#10;        self.splitViewController.viewControllers.firstObject == self &#38;&#38;&#10; &#10;        self.splitViewController == poppedViewController.splitViewController) &#123;&#10; &#10;        objc_setAssociatedObject(self, kPoppedDetailVCKey, poppedViewController, OBJC_ASSOCIATION_RETAIN);&#10; &#10;        return poppedViewController;&#10;    &#125;&#10;     &#10; &#10;    // VC is not dealloced until disappear when popped using a left-edge swipe gesture&#10; &#10;    extern const void *const kHasBeenPoppedKey;&#10; &#10;    objc_setAssociatedObject(poppedViewController, kHasBeenPoppedKey, @(YES), OBJC_ASSOCIATION_RETAIN);&#10; &#10;    return poppedViewController;&#10; &#10;&#125;&#10;  &#10;- (NSArray&#60;UIViewController *&#62; *)swizzled_popToViewController:(UIViewController *)viewController animated:(BOOL)animated &#123;&#10; &#10;    NSArray&#60;UIViewController *&#62; *poppedViewControllers = [self swizzled_popToViewController:viewController animated:animated];&#10;     &#10;//&#19968;&#27425;&#24615;pop&#22810;&#20010;&#39029;&#38754;&#30340;&#26102;&#20505;&#65292;&#36825;&#20123;&#39029;&#38754;&#30340;viewDidDisappear&#20272;&#35745;&#37117;&#27809;&#26377;&#34987;&#35843;&#29992;&#65292;&#30452;&#25509;&#22238;&#25910;&#20102;&#10;    for (UIViewController *viewController in poppedViewControllers) &#123;&#10; &#10;        [viewController willDealloc];&#10; &#10;    &#125;&#10; &#10;    return poppedViewControllers;&#10; &#10;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>UIViewController + MemoryLeak</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)swizzled_viewDidDisappear:(BOOL)animated &#123;&#10;    [self swizzled_viewDidDisappear:animated];&#10;//&#20165;&#20165;&#24403;&#26159;pop&#24341;&#36215;viewDidDisappear&#30340;&#26102;&#20505;&#25165;&#37322;&#25918;(&#24403;&#34987;&#25377;&#20303;&#20043;&#21518;&#20063;&#20250;&#35843;&#29992;ViewDidDisappear)&#10;    if ([objc_getAssociatedObject(self, kHasBeenPoppedKey) boolValue]) &#123;&#10; &#10;        [self willDealloc];&#10; &#10;    &#125;&#10; &#10;&#125;&#10;  &#10;- (void)swizzled_dismissViewControllerAnimated:(BOOL)flag completion:(void (^)(void))completion &#123;&#10; &#10;    [self swizzled_dismissViewControllerAnimated:flag completion:completion];&#10; &#10; //dismiss&#25481;presentedViewController&#65292;&#37322;&#25918;&#23427; (&#20294;&#26159;&#20160;&#20040;&#26102;&#20505;&#24403;&#21069;viewController&#34987;&#37322;&#25918;&#21602;)&#10;    UIViewController *dismissedViewController = self.presentedViewController;&#10; &#10;    if (!dismissedViewController &#38;&#38; self.presentingViewController) &#123;&#10;//&#37322;&#25918;&#33258;&#24049;&#10;        dismissedViewController = self;&#10;    &#125;&#10; &#10;    if (!dismissedViewController) return;&#10;//&#20197;present&#20986;&#26469;&#30340;viewcontroller&#65292;&#19981;&#36890;&#36807;DidDisappear&#21435;&#21028;&#26029;&#26159;&#21542;&#37322;&#25918;&#20102;&#10;    [dismissedViewController willDealloc];&#10; &#10;&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/25/MJRefresh源码分析/" itemprop="url">
                  MJRefresh源码分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-01-25T16:38:24+08:00" content="2016-01-25">
              2016-01-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分類於</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/郑智文/" itemprop="url" rel="index">
                    <span itemprop="name">郑智文</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/01/25/MJRefresh源码分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/25/MJRefresh源码分析/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="u57FA_u672C_u539F_u7406_uFF1A"><a href="#u57FA_u672C_u539F_u7406_uFF1A" class="headerlink" title="基本原理："></a>基本原理：</h2><p>通过header view和 foot view 添加对scrollview contentOffset属性 kvo 实现动态刷新。在runtime对scrollview添加header的时候，在view的willMoveToSuperView生命周期方法中进行注册。</p>
<h2 id="u9700_u8981_u8BB0_u5FC6_u7406_u89E3_u7684_u5730_u65B9_uFF1A"><a href="#u9700_u8981_u8BB0_u5FC6_u7406_u89E3_u7684_u5730_u65B9_uFF1A" class="headerlink" title="需要记忆理解的地方："></a>需要记忆理解的地方：</h2><p>1.scrollview往上滑动的时候，contentOffsize的y是正数。scrollview往下滑动的时候，contentOffsize的y是负数。</p>
<p>2.header和footer的位置和大小是在view的layoutSubviews生命周期方法里设置的。</p>
<p>3.通过设置header或者footer的状态的时候控制其行为</p>
<p>小技巧：</p>
<p>1.在子类中调用了父类的方法，如果要求子类在其实现中必须调用父类的方法，可以在方法声明的时候添加 NS_REQUIRES_SUPER 宏，编译器在编译过程可进行检查。</p>
<h2 id="u4EE3_u7801_uFF1A"><a href="#u4EE3_u7801_uFF1A" class="headerlink" title="代码："></a>代码：</h2><p>1.MJRefreshNormalHeader</p>
<p>在初始化的时候,会调用init方法，在Init方法里，系统默认调用了initWithFrame方法，frame传的CGRectZero.在MJRefreshNormalHeader的父类</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithFrame:(CGRect)frame&#10;&#123;&#10;    if (self = [super initWithFrame:frame]) &#123;&#10; &#10;        // &#20934;&#22791;&#24037;&#20316;&#10; &#10;        [self prepare];&#10; &#10;        // &#40664;&#35748;&#26159;&#26222;&#36890;&#29366;&#24577;&#10; &#10;        self.state = MJRefreshStateIdle;&#10;    &#125;&#10;    return self;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>prepare方法设置了header的宽高和x的位置：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)prepare&#10;&#123;&#10;    [super prepare];  &#10; &#10;    // &#35774;&#32622;key&#10; &#10;    self.lastUpdatedTimeKey = MJRefreshHeaderLastUpdatedTimeKey;&#10; &#10;    // &#35774;&#32622;&#39640;&#24230;&#10; &#10;    self.mj_h = MJRefreshHeaderHeight;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>设置state属性方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setState:(MJRefreshState)state&#10;&#123;&#10;//&#36825;&#20010;&#23439;&#20027;&#35201;&#26159;&#26469;&#20197;&#19979;&#30340;&#36923;&#36753;&#21482;&#26377;&#26159;&#22312;&#29366;&#24577;&#21457;&#29983;&#21464;&#21270;&#30340;&#26102;&#20505;&#25165;&#25191;&#34892;&#65292;&#36991;&#20813;&#37325;&#22797;&#30340;&#36923;&#36753;&#12290;&#10;    MJRefreshCheckState&#10;    // &#26681;&#25454;&#29366;&#24577;&#20570;&#20107;&#24773;&#10; &#10; &#10;//&#20174;&#20854;&#20182;&#29366;&#24577;&#21464;&#25104;&#21021;&#22987;&#38745;&#27490;&#30340;&#29366;&#24577;&#10;    if (state == MJRefreshStateIdle) &#123;&#10; &#10;     //&#36825;&#37324;&#30456;&#24403;&#20110;&#20165;&#29992;&#20110;&#22788;&#29702;&#20174;&#21047;&#26032;&#20013;&#30340;&#29366;&#24577;&#36716;&#21270;&#25104;&#38745;&#27490;&#29366;&#24577;&#10;        if (oldState != MJRefreshStateRefreshing) return;&#10;        // &#20445;&#23384;&#21047;&#26032;&#26102;&#38388;&#10; &#10;        [[NSUserDefaults standardUserDefaults] setObject:[NSDate date] forKey:self.lastUpdatedTimeKey];&#10; &#10;        [[NSUserDefaults standardUserDefaults] synchronize];&#10; &#10;        // &#24674;&#22797;inset&#21644;offset&#10; &#10;        [UIView animateWithDuration:MJRefreshSlowAnimationDuration animations:^&#123;&#10; &#10;            self.scrollView.mj_insetT += self.insetTDelta;&#10; &#10;            // &#33258;&#21160;&#35843;&#25972;&#36879;&#26126;&#24230;&#10; &#10;            if (self.isAutomaticallyChangeAlpha) self.alpha = 0.0;&#10; &#10;        &#125; completion:^(BOOL finished) &#123;&#10;//&#36825;&#20010;&#23646;&#24615;&#20027;&#35201;&#26159;&#29992;&#26469;&#25511;&#21046;&#38543;&#30528;&#19979;&#25289;&#30340;&#36317;&#31163;&#26469;&#21453;&#24212;&#21040;header&#30340;&#36879;&#26126;&#24230;&#10;            self.pullingPercent = 0.0;&#10; &#10;        &#125;];&#10; &#10;    &#125; else if (state == MJRefreshStateRefreshing) &#123;&#10; &#10;        [UIView animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123;&#10; &#10;            // &#22686;&#21152;&#28378;&#21160;&#21306;&#22495;&#10; &#10;            CGFloat top = self.scrollViewOriginalInset.top + self.mj_h;&#10; &#10;            self.scrollView.mj_insetT = top;&#10; &#10;             &#10;            // &#35774;&#32622;&#28378;&#21160;&#20301;&#32622;&#10; &#10;            self.scrollView.mj_offsetY = - top;&#10; &#10;        &#125; completion:^(BOOL finished) &#123;&#10;//&#19994;&#21153;&#36923;&#36753;&#23618;&#30340;&#21047;&#26032;&#25968;&#25454;&#10;            [self executeRefreshingCallback];&#10; &#10;        &#125;];&#10; &#10;    &#125;&#10; &#10;&#125;</span><br></pre></td></tr></table></figure>
<p>根据拖拽进度设置透明度:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setPullingPercent:(CGFloat)pullingPercent&#10; &#10;&#123;&#10;    _pullingPercent = pullingPercent;&#10; &#10;    if (self.isRefreshing) return;&#10; &#10;    if (self.isAutomaticallyChangeAlpha) &#123;&#10; &#10;        self.alpha = pullingPercent;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在UIScrollVIEW+MJRefresh中的setMj_header方法，给UIScrollView动态的添加了一个header，并将它加到了ScrollView上。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setMj_header:(MJRefreshHeader *)mj_header&#10;&#123;&#10;    if (mj_header != self.mj_header) &#123;&#10; &#10;        // &#21024;&#38500;&#26087;&#30340;&#65292;&#28155;&#21152;&#26032;&#30340;&#10; &#10;        [self.mj_header removeFromSuperview];&#10; &#10;        [self insertSubview:mj_header atIndex:0];&#10;        // &#23384;&#20648;&#26032;&#30340;&#10; &#10;        [self willChangeValueForKey:@&#34;mj_header&#34;]; // KVO&#10; &#10;        objc_setAssociatedObject(self, &#38;MJRefreshHeaderKey,&#10; &#10;                                 mj_header, OBJC_ASSOCIATION_ASSIGN);&#10; &#10;        [self didChangeValueForKey:@&#34;mj_header&#34;]; // KVO&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>将header加到ScrollView上的时候，系统会调用willMoveToSuperview方法，将header从ScrollView删除的时候也会调用这个方法，区别是删除的时候参数传的nil，添加的时候参数为当前scrollView.在这个方法中设置了header的x位置以及header的宽度，并且添加了对scrollview的监听</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)willMoveToSuperview:(UIView *)newSuperview&#10;&#123;&#10;    [super willMoveToSuperview:newSuperview];&#10;    // &#22914;&#26524;&#19981;&#26159;UIScrollView&#65292;&#19981;&#20570;&#20219;&#20309;&#20107;&#24773;&#10;    if (newSuperview &#38;&#38; ![newSuperview isKindOfClass:[UIScrollView class]]) return;&#10; &#10;    // &#26087;&#30340;&#29238;&#25511;&#20214;&#31227;&#38500;&#30417;&#21548;&#10;    [self removeObservers];&#10;    if (newSuperview) &#123; // &#26032;&#30340;&#29238;&#25511;&#20214;&#10;        // &#35774;&#32622;&#23485;&#24230;&#10;        self.mj_w = newSuperview.mj_w;&#10; &#10;        // &#35774;&#32622;&#20301;&#32622;&#10;        self.mj_x = 0;&#10;        // &#35760;&#24405;UIScrollView&#10;        _scrollView = (UIScrollView *)newSuperview;&#10; &#10;        // &#35774;&#32622;&#27704;&#36828;&#25903;&#25345;&#22402;&#30452;&#24377;&#31783;&#25928;&#26524;&#10;        _scrollView.alwaysBounceVertical = YES;&#10; &#10;        // &#35760;&#24405;UIScrollView&#26368;&#24320;&#22987;&#30340;contentInset&#10;        _scrollViewOriginalInset = _scrollView.contentInset;&#10; &#10;        // &#28155;&#21152;&#30417;&#21548;&#10;        [self addObservers];&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>添加监听的方法:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)addObservers&#10;&#123;&#10;    NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;&#10; &#10; &#10;//&#30417;&#27979;&#28369;&#21160;&#36317;&#31163;&#65292;&#21028;&#26029;&#26159;&#21542;&#21040;&#36798;&#38656;&#35201;&#21047;&#26032;&#30340;&#31243;&#24230;&#10;    [self.scrollView addObserver:self forKeyPath:MJRefreshKeyPathContentOffset options:options context:nil];&#10;//&#26816;&#27979;contentSize&#21464;&#21270;&#65292;&#27604;&#22914;&#19978;&#25289;&#21152;&#36733;&#26356;&#22810;&#65292;&#21160;&#24577;&#25913;&#21464;footer&#30340;&#20301;&#32622;&#10;    [self.scrollView addObserver:self forKeyPath:MJRefreshKeyPathContentSize options:options context:nil];&#10;//&#26816;&#27979;&#24179;&#31227;&#30340;&#25163;&#21183;&#10;    self.pan = self.scrollView.panGestureRecognizer;&#10;    [self.pan addObserver:self forKeyPath:MJRefreshKeyPathPanState options:options context:nil];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，系统会开始调用layoutSubViews方法：在MJRefreshComponent中重写了这个方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)layoutSubviews&#10;&#123;&#10;    [super layoutSubviews];&#10;    [self placeSubviews];&#10;&#125;&#10;  &#10;//placeSubviews&#26041;&#27861;&#26159;&#22312;&#21508;&#20010;MJRefreshComponent&#30340;&#23376;&#31867;&#20013;&#23454;&#29616;&#30340;&#65292;&#10;//&#32487;&#25215;&#38142;:MJRefreshNormalHeader -&#62; MJRefreshStateHeader -&#62; MJRefreshHeader -&#62; MJRefreshComponent&#10;  &#10;//&#20197;&#19979;&#26159;MJRefreshHeader&#20013;&#30340;&#23454;&#29616;,&#35774;&#32622;&#20102;header&#30340;y&#30340;&#20301;&#32622;&#10;- (void)placeSubviews&#10;&#123;&#10;    [super placeSubviews];&#10;    // &#35774;&#32622;y&#20540;(&#24403;&#33258;&#24049;&#30340;&#39640;&#24230;&#21457;&#29983;&#25913;&#21464;&#20102;&#65292;&#32943;&#23450;&#35201;&#37325;&#26032;&#35843;&#25972;Y&#20540;&#65292;&#25152;&#20197;&#25918;&#21040;placeSubviews&#26041;&#27861;&#20013;&#35774;&#32622;y&#20540;)&#10;    self.mj_y = - self.mj_h - self.ignoredScrollViewContentInsetTop;&#10;&#125;&#10;  &#10;//&#20197;&#19979;&#26159;MJRefreshStateHeader&#20013;&#30340;&#23454;&#29616;,&#28155;&#21152;&#21047;&#26032;&#29366;&#20307;&#21644;&#26356;&#26032;&#26102;&#38388;&#10;- (void)placeSubviews&#10;&#123;&#10;    [super placeSubviews];&#10;    if (self.stateLabel.hidden) return;&#10; &#10;    BOOL noConstrainsOnStatusLabel = self.stateLabel.constraints.count == 0;&#10; &#10;    if (self.lastUpdatedTimeLabel.hidden) &#123;&#10; &#10;        // &#29366;&#24577;&#10; &#10;        if (noConstrainsOnStatusLabel) self.stateLabel.frame = self.bounds;&#10; &#10;    &#125; else &#123;&#10; &#10;        CGFloat stateLabelH = self.mj_h * 0.5;&#10; &#10;        // &#29366;&#24577;&#10; &#10;        if (noConstrainsOnStatusLabel) &#123;&#10; &#10;            self.stateLabel.mj_x = 0;&#10; &#10;            self.stateLabel.mj_y = 0;&#10; &#10;            self.stateLabel.mj_w = self.mj_w;&#10; &#10;            self.stateLabel.mj_h = stateLabelH;&#10;        &#125;&#10; &#10;        // &#26356;&#26032;&#26102;&#38388;&#10;        if (self.lastUpdatedTimeLabel.constraints.count == 0) &#123;&#10; &#10;            self.lastUpdatedTimeLabel.mj_x = 0;&#10; &#10;            self.lastUpdatedTimeLabel.mj_y = stateLabelH;&#10; &#10;            self.lastUpdatedTimeLabel.mj_w = self.mj_w;&#10; &#10;            self.lastUpdatedTimeLabel.mj_h = self.mj_h - self.lastUpdatedTimeLabel.mj_y;&#10;        &#125;&#10;    &#125;&#10;&#125;&#10;  &#10;//&#20197;&#19979;&#26159;MJRefreshNormalHeader&#20013;&#30340;&#23454;&#29616;&#65292;&#28155;&#21152;&#21098;&#22836;&#21644;loadingview&#10;- (void)placeSubviews&#10;&#123;&#10;    [super placeSubviews];&#10;    // &#31661;&#22836;&#30340;&#20013;&#24515;&#28857;&#10; &#10;    CGFloat arrowCenterX = self.mj_w * 0.5;&#10; &#10;    if (!self.stateLabel.hidden) &#123;&#10;        arrowCenterX -= 100;&#10;    &#125;&#10; &#10;    CGFloat arrowCenterY = self.mj_h * 0.5;&#10; &#10;    CGPoint arrowCenter = CGPointMake(arrowCenterX, arrowCenterY);&#10; &#10;    // &#31661;&#22836;&#10;    if (self.arrowView.constraints.count == 0) &#123;&#10;        self.arrowView.mj_size = self.arrowView.image.size;&#10;        self.arrowView.center = arrowCenter;&#10;    &#125;&#10; &#10;    // &#22280;&#22280;&#10;    if (self.loadingView.constraints.count == 0) &#123;&#10;        self.loadingView.center = arrowCenter;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>header中监控下拉距离的方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)scrollViewContentOffsetDidChange:(NSDictionary *)change&#10;&#123;&#10;    [super scrollViewContentOffsetDidChange:change];&#10; &#10;    // &#22312;&#21047;&#26032;&#30340;refreshing&#29366;&#24577;&#10; &#10;    if (self.state == MJRefreshStateRefreshing) &#123;&#10;        if (self.window == nil) return;&#10;        // sectionheader&#20572;&#30041;&#35299;&#20915;&#10;        CGFloat insetT = - self.scrollView.mj_offsetY &#62; _scrollViewOriginalInset.top ? - self.scrollView.mj_offsetY : _scrollViewOriginalInset.top;&#10;        insetT = insetT &#62; self.mj_h + _scrollViewOriginalInset.top ? self.mj_h + _scrollViewOriginalInset.top : insetT;&#10;        self.scrollView.mj_insetT = insetT;&#10;        self.insetTDelta = _scrollViewOriginalInset.top - insetT;&#10;        return;&#10;    &#125;&#10; &#10;    // &#36339;&#36716;&#21040;&#19979;&#19968;&#20010;&#25511;&#21046;&#22120;&#26102;&#65292;contentInset&#21487;&#33021;&#20250;&#21464;&#10;     _scrollViewOriginalInset = self.scrollView.contentInset;&#10; &#10;    // &#24403;&#21069;&#30340;contentOffset&#10;    CGFloat offsetY = self.scrollView.mj_offsetY;&#10; &#10;    // &#22836;&#37096;&#25511;&#20214;&#21018;&#22909;&#20986;&#29616;&#30340;offsetY&#10;    CGFloat happenOffsetY = - self.scrollViewOriginalInset.top;&#10;    // &#22914;&#26524;&#26159;&#21521;&#19978;&#28378;&#21160;&#21040;&#30475;&#19981;&#35265;&#22836;&#37096;&#25511;&#20214;&#65292;&#30452;&#25509;&#36820;&#22238;&#10;    if (offsetY &#62; happenOffsetY) return;&#10; &#10;    // &#26222;&#36890; &#21644; &#21363;&#23558;&#21047;&#26032; &#30340;&#20020;&#30028;&#28857;, self.mj_h&#26159;&#24403;&#21069;header&#30340;&#39640;&#24230;&#10;    CGFloat normal2pullingOffsetY = happenOffsetY - self.mj_h;&#10;    CGFloat pullingPercent = (happenOffsetY - offsetY) / self.mj_h;&#10; &#10;    if (self.scrollView.isDragging) &#123; // &#22914;&#26524;&#27491;&#22312;&#25302;&#25341;&#10;        self.pullingPercent = pullingPercent;&#10;//header&#27491;&#22909;&#23436;&#20840;&#38706;&#20986;&#26469;&#65292;&#24320;&#22987;&#36716;&#20026;&#21047;&#26032;&#29366;&#24577;&#10;        if (self.state == MJRefreshStateIdle &#38;&#38; offsetY &#60; normal2pullingOffsetY) &#123;&#10;            // &#36716;&#20026;&#21363;&#23558;&#21047;&#26032;&#29366;&#24577;&#10;            self.state = MJRefreshStatePulling;&#10;        &#125; else if (self.state == MJRefreshStatePulling &#38;&#38; offsetY &#62;= normal2pullingOffsetY) &#123;&#10;            // &#36716;&#20026;&#26222;&#36890;&#29366;&#24577;&#10;            self.state = MJRefreshStateIdle;&#10;        &#125;&#10;    &#125; else if (self.state == MJRefreshStatePulling) &#123;// &#21363;&#23558;&#21047;&#26032; &#38;&#38; &#25163;&#26494;&#24320;&#10;        // &#24320;&#22987;&#21047;&#26032;&#10;        [self beginRefreshing];&#10;    &#125; else if (pullingPercent &#60; 1) &#123;&#10;        self.pullingPercent = pullingPercent;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>footer同header一样都继承自MJFfreshComponent，都自动检测scrollview的行为，各自实现具体的被通知的逻辑</p>
<p>MJRefreshAutoFooter的实现：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)scrollViewContentOffsetDidChange:(NSDictionary *)change&#10;&#123;&#10;    [super scrollViewContentOffsetDidChange:change];&#10;    if (self.state != MJRefreshStateIdle || !self.automaticallyRefresh || self.mj_y == 0) return;&#10; &#10;  &#10;    if (_scrollView.mj_insetT + _scrollView.mj_contentH &#62; _scrollView.mj_h) &#123; // &#20869;&#23481;&#36229;&#36807;&#19968;&#20010;&#23631;&#24149;&#10; &#10;        // &#36825;&#37324;&#30340;_scrollView.mj_contentH&#26367;&#25442;&#25481;self.mj_y&#26356;&#20026;&#21512;&#29702;&#10; &#10;        if (_scrollView.mj_offsetY &#62;= _scrollView.mj_contentH - _scrollView.mj_h + self.mj_h * self.triggerAutomaticallyRefreshPercent + _scrollView.mj_insetB - self.mj_h) &#123;&#10; &#10;            // &#38450;&#27490;&#25163;&#26494;&#24320;&#26102;&#36830;&#32493;&#35843;&#29992;&#10; &#10;            CGPoint old = [change[@&#34;old&#34;] CGPointValue];&#10; &#10;            CGPoint new = [change[@&#34;new&#34;] CGPointValue];&#10; &#10;            if (new.y &#60;= old.y) return;&#10; &#10;            // &#24403;&#24213;&#37096;&#21047;&#26032;&#25511;&#20214;&#23436;&#20840;&#20986;&#29616;&#26102;&#65292;&#25165;&#21047;&#26032;&#10; &#10;            [self beginRefreshing];&#10;        &#125;&#10;    &#125;&#10;&#125;&#10; &#10;- (void)scrollViewPanStateDidChange:(NSDictionary *)change&#10;&#123;&#10;    [super scrollViewPanStateDidChange:change];&#10; &#10;    if (self.state != MJRefreshStateIdle) return;&#10; &#10;    if (_scrollView.panGestureRecognizer.state == UIGestureRecognizerStateEnded) &#123;// &#25163;&#26494;&#24320;&#10;        if (_scrollView.mj_insetT + _scrollView.mj_contentH &#60;= _scrollView.mj_h) &#123;  // &#19981;&#22815;&#19968;&#20010;&#23631;&#24149;&#10;            if (_scrollView.mj_offsetY &#62;= - _scrollView.mj_insetT) &#123; // &#21521;&#19978;&#25341;&#10;                [self beginRefreshing];&#10;            &#125;&#10;        &#125; else &#123; // &#36229;&#20986;&#19968;&#20010;&#23631;&#24149;&#10;            if (_scrollView.mj_offsetY &#62;= _scrollView.mj_contentH + _scrollView.mj_insetB - _scrollView.mj_h) &#123;&#10;                [self beginRefreshing];&#10;            &#125;&#10;        &#125;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/25/MJExtension源码分析/" itemprop="url">
                  MJExtension源码分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-01-25T16:38:24+08:00" content="2016-01-25">
              2016-01-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分類於</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/郑智文/" itemprop="url" rel="index">
                    <span itemprop="name">郑智文</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/01/25/MJExtension源码分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/25/MJExtension源码分析/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>1.KVC，字典转化成对象的时候，需要给对象的属性赋值。MJExtentsion是通过KVC实现的，所以对象都需要继承NSObject。</p>
<p>2.Runtime</p>
<pre><code>1)对与某一个类型,通过runtime去查找它自己所有的属性，再根据属性去字典里查找对应的value。

2)通过runtime在运行时给对象增加字段信息，比如记录哪些属性进行转化，哪些属性忽略转化。

3)通过runtime给对应的类增加缓存信息，提高转化效率。
</code></pre><p>3.递归，针对对象中又包含对象，数组包含对象等情况，通过递归实现属性的赋值。</p>
<p>4.self用在类方法中意思是代表当前类，用在对象方法中代表当前对象。通过一个实例对象的指针调用一个类方法可以这么做：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = [self class];&#10;[cls classMethod];</span><br></pre></td></tr></table></figure>
<p>5.instanceType</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)objectWithKeyValues:(id)keyValues</span><br></pre></td></tr></table></figure>
<p>该方法定义在NSObject中，但在不同的子业务类型中，通过instanceType会返回具体的类型对象。</p>
<h2 id="u9700_u8981_u6CE8_u610F_u7684_u5730_u65B9"><a href="#u9700_u8981_u6CE8_u610F_u7684_u5730_u65B9" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h2><p>1.字典转对象的时候，如果某个属性是NULL，会被过滤，也就是该对象的这个属性的值是默认值。整型是0,对象类型是nil。</p>
<p>2.在对象转字典的时候，如果对象本身的属性包含了superClass,debugDescription,description,hash这四种中的一种，会被MJExtension过滤掉。因为它认为是系统自动增加的元素，所以当前情况下，需要把这些属性手动增加上去。</p>
<p>3.在对象转字典的时候，如果对象某个字段为nil，生成的结果字典里就不会存在这个键值对。</p>
<p>4.在对象中的属性与字典的字段不匹配的时候，需要手动指定。指定的方式是自己实现一个replacedKeyFromPropertyName方法，这个方法是手写的，写错一个字母转化就会有问题。不过也有别的方式，可以通过setupObjectWithBlock去指定，但是key必须传MJReplacedKeyFromPropertyNameKey，因为它取的时候是按这个key去取的。</p>
<h2 id="u6838_u5FC3_u5B9E_u73B0"><a href="#u6838_u5FC3_u5B9E_u73B0" class="headerlink" title="核心实现"></a>核心实现</h2><p>MJExtension中最核心的两个函数分别是</p>
<p>- (instancetype)setKeyValues:(id)keyValues context:(NSManagedObjectContext <em>)context error:(NSError *</em>)error;</p>
<p>- (NSDictionary <em>)keyValuesWithKeys:(NSArray </em>)keys ignoredKeys:(NSArray <em>)ignoredKeys error:(NSError </em>__autoreleasing*)error</p>
<p>其他的函数都是最终调用这两个函数，只是封装了一下参数</p>
<p>1.字典转对象：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)setKeyValues:(id)keyValues context:(NSManagedObjectContext *)context error:(NSError *__autoreleasing *)error&#10; &#10;&#123;&#10; &#10;    // &#22914;&#26524;&#26159;JSON&#23383;&#31526;&#20018;&#10; &#10;    if ([keyValues isKindOfClass:[NSString class]]) &#123;&#10;  &#10;    //json&#26684;&#24335;&#23383;&#31526;&#20018;&#36716;&#23383;&#20856;,&#36890;&#36807;NSJONSerializaton &#20808;&#23383;&#31526;&#20018;&#36716;nsdata &#20877;&#21453;&#24207;&#21015;&#21270;&#25104;nsdictionary&#10;        keyValues = [((NSString *)keyValues) JSONObject];&#10;    &#125;&#10;     &#10;    MJAssertError([keyValues isKindOfClass:[NSDictionary class]], self, error, @&#34;keyValues&#21442;&#25968;&#19981;&#26159;&#19968;&#20010;&#23383;&#20856;&#34;);&#10; &#10;    @try &#123;&#10; &#10;        Class aClass = [self class];&#10;//&#21738;&#20123;&#23646;&#24615;&#38656;&#35201;&#34987;&#36716;&#21270;&#10;        NSArray *allowedPropertyNames = [aClass totalAllowedPropertyNames];&#10;//&#21738;&#20123;&#23646;&#24615;&#19981;&#38656;&#35201;&#36716;&#21270;&#10;        NSArray *ignoredPropertyNames = [aClass totalIgnoredPropertyNames];&#10; &#10;         &#10; &#10;        //&#36890;&#36807;&#23553;&#35013;&#30340;&#26041;&#27861;&#22238;&#35843;&#19968;&#20010;&#36890;&#36807;&#36816;&#34892;&#26102;&#32534;&#20889;&#30340;&#65292;&#29992;&#20110;&#36820;&#22238;&#23646;&#24615;&#21015;&#34920;&#30340;&#26041;&#27861;&#12290;&#10; &#10;        [aClass enumeratePropertiesWithBlock:^(MJProperty *property, BOOL *stop) &#123;&#10; &#10;            // 0.&#26816;&#27979;&#26159;&#21542;&#34987;&#24573;&#30053;&#10; &#10;            if (allowedPropertyNames.count &#38;&#38; ![allowedPropertyNames containsObject:property.name]) return;&#10; &#10;            if ([ignoredPropertyNames containsObject:property.name]) return;&#10; &#10;             &#10; &#10;            // 1.&#21462;&#20986;&#23646;&#24615;&#20540;&#10; &#10;            id value = keyValues ;&#10;//&#24471;&#21040;&#24403;&#21069;&#23646;&#24615;&#23545;&#24212;&#21040;&#23383;&#20856;&#20013;&#30340;&#23383;&#27573;&#21517;&#31216;&#25110;&#32773;&#36335;&#24452;&#10;            NSArray *keys = [property keysFromClass:[self class]];&#10;//&#36825;&#20010;&#24490;&#29615;&#35206;&#30422;&#21040;&#20102;&#26576;&#20010;&#23646;&#24615;&#23545;&#24212;&#30340;&#26159;&#23383;&#20856;&#20013;&#26576;&#20010;path&#30340;&#24773;&#20917;&#65292;&#20363;&#22914;&#23545;&#35937;&#30340;oldName&#23646;&#24615;&#23545;&#24212;&#21040;&#23383;&#20856;&#20013;&#26159;name.oldName&#30340;&#24773;&#20917;&#10;            for (NSString *key in keys) &#123;&#10; &#10;                if (![value isKindOfClass:[NSDictionary class]]) continue;&#10;                value = value[key];&#10; &#10;            &#125;&#10; &#10;            if (!value || value == [NSNull null]) return;&#10; &#10;             &#10; &#10;            // 2.&#22914;&#26524;&#26159;&#27169;&#22411;&#23646;&#24615;&#10; &#10;            MJType *type = property.type;&#10; &#10;            Class typeClass = type.typeClass;&#10;//&#24403;&#21069;&#23646;&#24615;&#26159;&#19968;&#20010;&#25968;&#32452;&#65292;&#24471;&#21040;&#25968;&#32452;&#20013;&#30340;&#23545;&#35937;&#31867;&#22411;&#10;            Class objectClass = [property objectClassInArrayFromClass:[self class]];&#10; &#10;            if (!type.isFromFoundation &#38;&#38; typeClass) &#123;&#10;//&#24403;&#21069;&#23646;&#24615;&#26159;&#19968;&#20010;&#19994;&#21153;&#23545;&#35937;&#65292;&#36882;&#24402;&#10;                value = [typeClass objectWithKeyValues:value context:context error:error];&#10; &#10;            &#125; else if (objectClass) &#123;&#10; &#10;                // 3.&#23383;&#20856;&#25968;&#32452;--&#62;&#27169;&#22411;&#25968;&#32452;&#10; &#10;                value = [objectClass objectArrayWithKeyValuesArray:value context:context error:error];&#10;//&#20197;&#19979;&#20027;&#35201;&#26159;&#22788;&#29702;&#23646;&#24615;&#21644;&#23383;&#20856;&#20013;&#30340;&#25968;&#25454;&#31867;&#22411;&#19981;&#21305;&#37197;&#30340;&#38382;&#39064;&#65292;&#36827;&#34892;&#25968;&#25454;&#31867;&#22411;&#30340;&#36716;&#25442;&#10;            &#125; else if (typeClass == [NSString class]) &#123;&#10; &#10;                if ([value isKindOfClass:[NSNumber class]]) &#123;&#10; &#10;                    // NSNumber -&#62; NSString&#10; &#10;                    value = [value description];&#10; &#10;                &#125; else if ([value isKindOfClass:[NSURL class]]) &#123;&#10; &#10;                    // NSURL -&#62; NSString&#10; &#10;                    value = [value absoluteString];&#10; &#10;                &#125;&#10; &#10;            &#125; else if ([value isKindOfClass:[NSString class]]) &#123;&#10; &#10;                if (typeClass == [NSURL class]) &#123;&#10; &#10;                    // NSString -&#62; NSURL&#10; &#10;                    value = [NSURL URLWithString:value];&#10; &#10;                &#125; else if (type.isNumberType) &#123;&#10; &#10;                    NSString *oldValue = value;&#10; &#10;                     &#10; &#10;                    // NSString -&#62; NSNumber&#10; &#10;                    value = [_numberFormatter numberFromString:oldValue];&#10; &#10;                     &#10; &#10;                    // &#22914;&#26524;&#26159;BOOL&#10; &#10;                    if ([type.code isEqualToString:MJTypeBOOL]) &#123;&#10; &#10;                        // &#23383;&#31526;&#20018;&#36716;BOOL&#65288;&#23383;&#31526;&#20018;&#27809;&#26377;charValue&#26041;&#27861;&#65289;&#10; &#10;                        // &#31995;&#32479;&#20250;&#35843;&#29992;&#23383;&#31526;&#20018;&#30340;charValue&#36716;&#20026;BOOL&#31867;&#22411;&#10; &#10;                        NSString *lower = [oldValue lowercaseString];&#10; &#10;                        if ([lower isEqualToString:@&#34;yes&#34;] || [lower isEqualToString:@&#34;true&#34;]) &#123;&#10; &#10;                            value = @YES;&#10; &#10;                        &#125; else if ([lower isEqualToString:@&#34;no&#34;] || [lower isEqualToString:@&#34;false&#34;]) &#123;&#10; &#10;                            value = @NO;&#10; &#10;                        &#125;&#10; &#10;                    &#125;&#10; &#10;                &#125;&#10; &#10;            &#125;&#10; &#10;             &#10; &#10;            // 4.&#36171;&#20540;&#10; &#10;            [property setValue:value forObject:self];&#10; &#10;        &#125;];&#10; &#10;         &#10; &#10;        // &#36716;&#25442;&#23436;&#27605;&#10; &#10;        if ([self respondsToSelector:@selector(keyValuesDidFinishConvertingToObject)]) &#123;&#10; &#10;            [self keyValuesDidFinishConvertingToObject];&#10; &#10;        &#125;&#10; &#10;    &#125; @catch (NSException *exception) &#123;&#10; &#10;        MJBuildError(error, exception.reason);&#10; &#10;    &#125;&#10; &#10;    return self;&#10; &#10;&#125;</span><br></pre></td></tr></table></figure>
<p>2.对象转字典</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (NSDictionary *)keyValuesWithKeys:(NSArray *)keys ignoredKeys:(NSArray *)ignoredKeys error:(NSError *__autoreleasing *)error&#10; &#10;&#123;  &#10;    // &#22914;&#26524;&#33258;&#24049;&#19981;&#26159;&#27169;&#22411;&#31867;&#10;    if ([MJFoundation isClassFromFoundation:[self class]]) return (NSDictionary *)self;&#10; &#10;    __block NSMutableDictionary *keyValues = [NSMutableDictionary dictionary];&#10; &#10;    @try &#123;&#10; &#10;        Class aClass = [self class];&#10; &#10;        NSArray *allowedPropertyNames = [aClass totalAllowedPropertyNames];&#10; &#10;        NSArray *ignoredPropertyNames = [aClass totalIgnoredPropertyNames];&#10; &#10;        [aClass enumeratePropertiesWithBlock:^(MJProperty *property, BOOL *stop) &#123;&#10; &#10;            // 0.&#26816;&#27979;&#26159;&#21542;&#34987;&#24573;&#30053;&#10; &#10;            if (allowedPropertyNames.count &#38;&#38; ![allowedPropertyNames containsObject:property.name]) return;&#10; &#10;            if ([ignoredPropertyNames containsObject:property.name]) return;&#10; &#10;            if (keys.count &#38;&#38; ![keys containsObject:property.name]) return;&#10; &#10;            if ([ignoredKeys containsObject:property.name]) return;&#10; &#10;            // 1.&#21462;&#20986;&#23646;&#24615;&#20540;&#10; &#10;            id value = [property valueFromObject:self];&#10; &#10;            if (!value) return;&#10; &#10;            // 2.&#22914;&#26524;&#26159;&#27169;&#22411;&#23646;&#24615;&#10; &#10;            MJType *type = property.type;&#10; &#10;            Class typeClass = type.typeClass;&#10; &#10;            Class objectClass = [property objectClassInArrayFromClass:[self class]];&#10; &#10;            if (!type.isFromFoundation &#38;&#38; typeClass) &#123;&#10; &#10;                value = [value keyValues];&#10; &#10;            &#125; else if (objectClass) &#123;&#10; &#10;                // 3.&#22788;&#29702;&#25968;&#32452;&#37324;&#38754;&#26377;&#27169;&#22411;&#30340;&#24773;&#20917;&#10; &#10;                value = [objectClass keyValuesArrayWithObjectArray:value];&#10; &#10;            &#125; else if (typeClass == [NSURL class]) &#123;&#10; &#10;                value = [value absoluteString];&#10; &#10;            &#125;&#10; &#10;            // 4.&#36171;&#20540;&#10; &#10;            NSArray *keys = [property keysFromClass:[self class]];&#10; &#10;            NSUInteger keyCount = keys.count;&#10; &#10;            // &#21019;&#24314;&#23383;&#20856;&#10; &#10;            __block NSMutableDictionary *innerDict = keyValues;&#10;//&#35206;&#30422;&#23545;&#35937;&#23646;&#24615;&#23545;&#24212;&#23383;&#20856;&#30340;&#19968;&#20010;path&#30340;&#24773;&#20917;&#10;            [keys enumerateObjectsUsingBlock:^(NSString *key, NSUInteger idx, BOOL *stop) &#123;&#10; &#10;                if (idx == keyCount - 1) &#123; // &#26368;&#21518;&#19968;&#20010;&#23646;&#24615;&#10; &#10;                    innerDict[key] = value;&#10; &#10;                &#125; else &#123; // &#23383;&#20856;&#10; &#10;                    NSMutableDictionary *tempDict = innerDict[key];&#10; &#10;                    if (tempDict == nil) &#123;&#10; &#10;                        tempDict = [NSMutableDictionary dictionary];&#10; &#10;                        innerDict[key] = tempDict;&#10; &#10;                    &#125;&#10; &#10;                    innerDict = tempDict;&#10; &#10;                &#125;&#10; &#10;            &#125;];&#10; &#10;        &#125;];&#10; &#10;      &#10;        // &#21435;&#38500;&#31995;&#32479;&#33258;&#21160;&#22686;&#21152;&#30340;&#20803;&#32032;&#10; &#10;        [keyValues removeObjectsForKeys:@[@&#34;superclass&#34;, @&#34;debugDescription&#34;, @&#34;description&#34;, @&#34;hash&#34;]];&#10; &#10;         &#10;        // &#36716;&#25442;&#23436;&#27605;&#10; &#10;        if ([self respondsToSelector:@selector(objectDidFinishConvertingToKeyValues)]) &#123;&#10; &#10;            [self objectDidFinishConvertingToKeyValues];&#10; &#10;        &#125;&#10; &#10;    &#125; @catch (NSException *exception) &#123;&#10; &#10;        MJBuildError(error, exception.reason);&#10; &#10;    &#125;&#10; &#10;    return keyValues;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>现在来看一下，MJExtension是如何通过属性名称去查找对应在字典中的字段，逻辑主要在NSObject+MJProperty.m的</p>
<p>+ (NSString <em>)propertyKey:(NSString </em>)propertyName方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (NSString *)propertyKey:(NSString *)propertyName&#10; &#10;&#123;&#10; &#10;    MJAssertParamNotNil2(propertyName, nil);&#10; &#10;     &#10; &#10;    __block NSString *key = nil;&#10; &#10;    // 1.&#26597;&#30475;&#26377;&#27809;&#26377;&#38656;&#35201;&#26367;&#25442;&#30340;key&#65292;&#36825;&#37324;&#26816;&#26597;&#24403;&#21069;&#31867;&#26377;&#27809;&#26377;&#23454;&#29616;replacedKeyFromPropertyName&#26041;&#27861;&#65292;&#20808;&#20174;&#36825;&#37324;&#21462;&#10; &#10;    if ([self respondsToSelector:@selector(replacedKeyFromPropertyName)]) &#123;&#10; &#10;        key = [self replacedKeyFromPropertyName][propertyName];&#10; &#10;    &#125;&#10; &#10;     &#10; &#10;    if (!key) &#123;&#10;//2.&#22914;&#26524;&#27809;&#26377;&#20174;replacedKeyFromPropertyName&#20013;&#24471;&#21040;&#65292;&#20877;&#26816;&#26597;&#26377;&#27809;&#26377;&#36890;&#36807;setupObjectWithBlock&#25351;&#23450;&#10;        [self enumerateClassesWithBlock:^(__unsafe_unretained Class c, BOOL *stop) &#123;&#10; &#10;            NSDictionary *dict = objc_getAssociatedObject(c, &#38;MJReplacedKeyFromPropertyNameKey);&#10; &#10;            if (dict) &#123;&#10; &#10;                key = dict[propertyName];&#10; &#10;            &#125;&#10; &#10;            if (key) *stop = YES;&#10; &#10;        &#125;];&#10; &#10;    &#125;&#10; &#10;     &#10; &#10;    // 3.&#20197;&#19978;&#37117;&#27809;&#26377;&#30340;&#24773;&#20917;&#19979;&#65292;&#23601;&#29992;&#23646;&#24615;&#21517;&#20316;&#20026;key&#65292;&#25442;&#21477;&#35805;&#35828;&#21482;&#26377;&#23646;&#24615;&#21517;&#31216;&#36319;&#23383;&#20856;&#20013;&#30340;key&#21517;&#31216;&#23545;&#24212;&#19981;&#19978;&#30340;&#26102;&#20505;&#25165;&#38656;&#35201;&#29992;1&#25110;&#32773;2&#30340;&#26041;&#24335;&#25351;&#23450;&#65292;&#40664;&#35748;&#24773;&#20917;&#23601;&#26159;&#21462;&#23646;&#24615;&#21517;&#31216;&#12290;&#10; &#10;    if (!key) key = propertyName;&#10; &#10;     &#10;    return key;&#10; &#10;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u7F13_u5B58"><a href="#u7F13_u5B58" class="headerlink" title="缓存"></a>缓存</h2><p>MJEextension中通过runtime的objc_setAssociatedObject函数，实现属性信息的缓存，对于某一个类型只要之前获取了它的属性信息之后再次获取即可从缓存中获取，不需要再次生成属性信息。</p>
<p>1.在获取一个类的所有属性时候：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (NSArray *)properties&#10;&#123;&#10;    static const char MJCachedPropertiesKey = &#39;\0&#39;;&#10; &#10;    // &#33719;&#24471;&#25104;&#21592;&#21464;&#37327;&#10; &#10;    // &#36890;&#36807;&#20851;&#32852;&#23545;&#35937;&#65292;&#20197;&#21450;&#25552;&#21069;&#23450;&#20041;&#22909;&#30340;MJCachedPropertiesKey&#26469;&#36827;&#34892;&#36816;&#34892;&#26102;&#65292;&#23545;&#25152;&#26377;&#23646;&#24615;&#30340;&#33719;&#21462;&#12290;&#10; &#10;    //***objc_getAssociatedObject &#26041;&#27861;&#29992;&#20110;&#21028;&#26029;&#24403;&#21069;&#26159;&#21542;&#24050;&#32463;&#33719;&#21462;&#36807;MJCachedPropertiesKey&#23545;&#24212;&#30340;&#20851;&#32852;&#23545;&#35937;&#10; &#10;    //  1&#62; &#20851;&#32852;&#21040;&#30340;&#31867;&#23545;&#35937;&#10; &#10;    //  2&#62; &#20851;&#32852;&#30340;&#23646;&#24615; key&#10; &#10; &#10;//&#20808;&#20174;&#31867;&#30340;&#32531;&#23384;&#23545;&#35937;&#20013;&#33719;&#21462;&#10;    NSMutableArray *cachedProperties = objc_getAssociatedObject(self, &#38;MJCachedPropertiesKey);&#10; &#10;    //***&#10; &#10;    if (cachedProperties == nil) &#123;&#10; &#10;        cachedProperties = [NSMutableArray array];&#10; &#10;        /**&#36941;&#21382;&#36825;&#20010;&#31867;&#30340;&#29238;&#31867;*/&#10; &#10;        [self enumerateClassesWithBlock:^(__unsafe_unretained Class c, BOOL *stop) &#123;&#10; &#10;            // 1.&#33719;&#24471;&#25152;&#26377;&#30340;&#25104;&#21592;&#21464;&#37327;&#10; &#10;            unsigned int outCount = 0;&#10; &#10;            /**&#10; &#10;                class_copyIvarList &#25104;&#21592;&#21464;&#37327;&#65292;&#25552;&#31034;&#26377;&#24456;&#22810;&#31532;&#19977;&#26041;&#26694;&#26550;&#20250;&#20351;&#29992; Ivar&#65292;&#33021;&#22815;&#33719;&#24471;&#26356;&#22810;&#30340;&#20449;&#24687;&#10; &#10;                &#20294;&#26159;&#65306;&#22312; swift &#20013;&#65292;&#30001;&#20110;&#35821;&#27861;&#32467;&#26500;&#30340;&#21464;&#21270;&#65292;&#20351;&#29992; Ivar &#38750;&#24120;&#19981;&#31283;&#23450;&#65292;&#32463;&#24120;&#20250;&#23849;&#28291;&#65281;&#10; &#10;                class_copyPropertyList &#23646;&#24615;&#10; &#10;                class_copyMethodList &#26041;&#27861;&#10; &#10;                class_copyProtocolList &#21327;&#35758;&#10; &#10;                */&#10; &#10;            objc_property_t *properties = class_copyPropertyList(c, &#38;outCount);&#10;             &#10; &#10;            // 2.&#36941;&#21382;&#27599;&#19968;&#20010;&#25104;&#21592;&#21464;&#37327;&#10; &#10;            for (unsigned int i = 0; i&#60;outCount; i++) &#123;&#10; &#10;                MJProperty *property = [MJProperty cachedPropertyWithProperty:properties[i]];&#10; &#10;                property.srcClass = c;&#10; &#10;                [property setKey:[self propertyKey:property.name] forClass:self];&#10; &#10;                [property setObjectClassInArray:[self propertyObjectClassInArray:property.name] forClass:self];&#10; &#10;                [cachedProperties addObject:property];&#10; &#10;            &#125;&#10; &#10;            // 3.&#37322;&#25918;&#20869;&#23384;&#10; &#10;            free(properties);&#10; &#10;        &#125;];&#10; &#10;        //*** &#22312;&#27492;&#26102;&#35774;&#32622;&#24403;&#21069;&#36825;&#20010;&#31867;&#20026;&#20851;&#32852;&#23545;&#35937;&#65292;&#36825;&#26679;&#19979;&#27425;&#23601;&#19981;&#20250;&#37325;&#22797;&#33719;&#21462;&#31867;&#30340;&#30456;&#20851;&#23646;&#24615;&#12290;&#10; &#10;        objc_setAssociatedObject(self, &#38;MJCachedPropertiesKey, cachedProperties, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#10; &#10;        //***&#10;    &#125;&#10; &#10;    return cachedProperties;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>2.在获取一个runtime属性对应的MJProperty对象的时候：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)cachedPropertyWithProperty:(objc_property_t)property&#10;&#123;&#10; &#10;    MJProperty *propertyObj = objc_getAssociatedObject(self, property);&#10; &#10;    if (propertyObj == nil) &#123;&#10; &#10;        propertyObj = [[self alloc] init];&#10; &#10;        propertyObj.property = property;&#10; &#10;        objc_setAssociatedObject(self, property, propertyObj, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#10; &#10;    &#125;&#10; &#10;    return propertyObj;&#10; &#10;&#125;</span><br></pre></td></tr></table></figure>
<p>3.在获取一个MJProperty的type的时候：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static NSMutableDictionary *_cachedTypes;&#10;  &#10;+ (instancetype)cachedTypeWithCode:(NSString *)code&#10;&#123;&#10; &#10;    MJAssertParamNotNil2(code, nil);&#10; &#10;    MJType *type = _cachedTypes[code];&#10; &#10;    if (type == nil) &#123;&#10; &#10;        type = [[self alloc] init];&#10; &#10;        type.code = code;&#10; &#10;        _cachedTypes[code] = type;&#10; &#10;    &#125;&#10; &#10;    return type;&#10; &#10;&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/25/KVC集合操作符/" itemprop="url">
                  KVC集合操作符
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-01-25T16:38:24+08:00" content="2016-01-25">
              2016-01-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分類於</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/郑智文/" itemprop="url" rel="index">
                    <span itemprop="name">郑智文</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/01/25/KVC集合操作符/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/25/KVC集合操作符/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>第一次遇到是在阅读AFNetworking中NSURLSession部分代码的时候：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (NSArray *)tasksForKeyPath:(NSString *)keyPath &#123;&#10; &#10;    __block NSArray *tasks = nil;&#10; &#10;    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);&#10; &#10;    [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) &#123;&#10; &#10;        if ([keyPath isEqualToString:NSStringFromSelector(@selector(dataTasks))]) &#123;&#10; &#10;            tasks = dataTasks;&#10; &#10;        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(uploadTasks))]) &#123;&#10; &#10;            tasks = uploadTasks;&#10; &#10;        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(downloadTasks))]) &#123;&#10; &#10;            tasks = downloadTasks;&#10; &#10;        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(tasks))]) &#123;&#10;             &#10;            //dataTasks, uploadTasks, downloadTasks &#37117;&#26159;&#25968;&#32452;&#65292;&#30456;&#24403;&#20110;&#25171;&#24179;&#25968;&#32452;&#65292;&#36820;&#22238;&#19968;&#20010;&#21253;&#21547;&#23376;&#25968;&#32452;&#21508;&#20803;&#32032;&#30340;&#25968;&#32452;&#12290;&#10;            tasks = [@[dataTasks, uploadTasks, downloadTasks] valueForKeyPath:@&#34;@unionOfArrays.self&#34;];&#10;        &#125;&#10;        dispatch_semaphore_signal(semaphore);&#10;    &#125;];&#10;    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);&#10;    return tasks;&#10; &#10;&#125;</span><br></pre></td></tr></table></figure>
<p>KVC集合运算符允许以key path符号在一个集合中执行方法，以@开头表示一个特定的集合方法。键值编码会在必要的时候把基本数据类型进行装箱或者拆箱</p>
<p>它主要分为3类：1.简单集合操作符 2.对象操作符 3.数组和集合操作符</p>
<h2 id="u7B80_u5355_u96C6_u5408_u64CD_u4F5C_u7B26"><a href="#u7B80_u5355_u96C6_u5408_u64CD_u4F5C_u7B26" class="headerlink" title="简单集合操作符"></a>简单集合操作符</h2><p>返回string，number等</p>
<p>@max/@min : 获得数组中最大(或者最小)的一个元素，元素内部要支持能够相互比较。这个好像只能是数值类型，系统并没有类似compare的方法，只有isEqual，但是并不是排序用的。</p>
<p>@avg ： 将集合中对象转换成double类型，返回数组中指定的平均值的number对象</p>
<p>@sum ：将集合中每个对象都转换成double类型，然后计算总和，最后返回一个值为这个总和的NSNumber对象</p>
<p>@count：返回集合中对象总数的NSNumber对象</p>
<p>例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[products valueForKeyPath:@&#34;@count&#34;];&#10;[products valueForKeyPath:@&#34;@sum.price&#34;];&#10;[products valueForKeyPath:@&#34;@avg.price&#34;];&#10;[products valueForKeyPath:@&#34;@max.price&#34;];&#10;[products valueForKeyPath:@&#34;@min.launchedOn&#34;];</span><br></pre></td></tr></table></figure>
<h2 id="u5BF9_u8C61_u64CD_u4F5C_u7B26"><a href="#u5BF9_u8C61_u64CD_u4F5C_u7B26" class="headerlink" title="对象操作符"></a>对象操作符</h2><p>@unionOfObjects/@distincUnionOfObjects 返回一个由操作符右边的key path指定的对象属性组成的数组，distincUnionOfObjects会对数组去重。</p>
<p>例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[inventory valueForKeyPath:@&#34;@unionOfObjects.name&#34;];&#10;[inventory valueForKeyPath:@&#34;@distinctUnionOfObjects.name&#34;];</span><br></pre></td></tr></table></figure>
<p>数组和集合操作符</p>
<p>@distinctUnionOfArrays/@unionOfArrays 返回一个数组，其中包含这个这个数组中每个子数组对于这个操作符号右边指定的key path进行操作之后的值。</p>
<p>经常会使用 array unionOfArrays 来打平多维数组。</p>
<p>@distinctUnionOfSets 和@distinctUnionOfArrays类似，因为NSSet中是没有重复的值，所以只有distinct操作</p>
<p>利用这些操作，有时候可以避免无聊和重复的循环，代码也简洁了很多。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/25/ Runloop的实际使用/" itemprop="url">
                  Runloop的实际使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-01-25T16:38:24+08:00" content="2016-01-25">
              2016-01-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分類於</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/郑智文/" itemprop="url" rel="index">
                    <span itemprop="name">郑智文</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/01/25/ Runloop的实际使用/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/25/ Runloop的实际使用/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Runloop__u548C__u7EBF_u7A0B"><a href="#Runloop__u548C__u7EBF_u7A0B" class="headerlink" title="Runloop 和 线程"></a>Runloop 和 线程</h2><p>在<a href="http://wiki.sankuai.com/display/~zhengzhiwen/2015/10/27/CFRunloop" target="_blank" rel="external">CFRunloop</a>中已经说明了一个线程及其runloop的对应关系 ，现在以iOS中NSThread的实际使用来说明runloop在线程中的意义。</p>
<p>在iOS中直接使用NSThread有一下几种方式，但是归根到底，当一个线程需要长时间的去跟踪一个任务的时候，这几种方式做的事情是一样的，只不过接口名称和参数不一样，感觉是为了使用起来更加方便。因为这些接口内部都需要依赖runloop去实现事件的监听，这个可以通过调用堆栈证实。</p>
<p><strong>- (void)performSelectorInBackground:(SEL)aSelector withObject:(id)arg</strong></p>
<p><strong>- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait</strong></p>
<p>以上两个方法都是NSObject的方法，可以直接通过一个对象来创建一个线程。第二个方法具有更多的灵活性，它可以让你自己指定线程，第一个方法是自己默认创建一个线程。第二个方法的最后一个参数是指定是否等待aSelector执行完毕。</p>
<p><strong>+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(id)argument;</strong></p>
<p>该方法是NSThread的类方法，跟第一个方法是类似的功能。</p>
<p>下面通过在子线程发起一个网络请求，去发现一些问题，然后通过runloop去解释原因，并推测API背后的实现方式。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;&#10; &#10;    [super viewDidLoad];&#10; &#10;    [self performSelectorInBackground:@selector(multiThread) withObject:nil];&#10;&#125;&#10;- (void)multiThread&#10; &#10;&#123;&#10;    if (![NSThread isMainThread]) &#123;&#10;        self.request = [[NSMutableURLRequest alloc]&#10; &#10;                                        initWithURL:[NSURL URLWithString:@&#34;http://www.baidu.com&#34;]&#10; &#10;                                        cachePolicy:NSURLCacheStorageNotAllowed&#10; &#10;                                        timeoutInterval:10];&#10; &#10;        [self.request setHTTPMethod: @&#34;GET&#34;];&#10; &#10;        self.connection =[[NSURLConnection alloc] initWithRequest:self.request&#10; &#10;                                                         delegate:self&#10; &#10;                                                 startImmediately:YES];&#10;    &#125;&#10;&#125;&#10;- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response&#123;&#10; &#10;    NSLog(@&#34;network callback&#34;);&#10; &#10;&#125;</span><br></pre></td></tr></table></figure>
<p>运行之后，可以发现在子线程中发起的网络请求，回调没有被调用。根据<a href="http://wiki.sankuai.com/display/~zhengzhiwen/2015/10/27/CFRunloop" target="_blank" rel="external">CFRunloop</a>介绍的知识可以大致猜测可能跟runloop有关系，也就是子线程的runloop中没有注册网络回调的消息，所以该子线程自己相关的runloop没有收到回调。实际上     - (instancetype)initWithRequest:(NSURLRequest *)request delegate:(id)delegate startImmediately:(BOOL) 这个方法的第三个参数的bool值表示是否在创建完NSURLConnection对象之后立刻发起请求，一般情况下是YES，什么时候会传NO呢。</p>
<p>事实上，对于以上这种方式创建的线程，默认是没有生成该线程对应的runloop的。也就是说这种情况下，需要自己去创建对应线程的runloop，并且让他run起来，去不断监听各种往runloop里注册的消息。但是对于主线程而言，其对应的runloop会由系统建立，并且自己run起来。由于平时工作在主线程下，这些工作大部分情况下不需要人为参与，所以一到子线程就会有各种问题。子线程中起timer没有生效也是相同的原因。所以以上函数第三个参数的意思就是，如果是当前线程已经runloop跑起来的情况下，传YES。除此之外，需要自己创建runloop去run，再将网络请求消息注册到runloop中。</p>
<p>现在根据以上分析修改代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.request = [[NSMutableURLRequest alloc]&#10; &#10;                                initWithURL:[NSURL URLWithString:@&#34;http://www.baidu.com&#34;]&#10; &#10;                                cachePolicy:NSURLCacheStorageNotAllowed&#10; &#10;                                timeoutInterval:10];&#10; &#10;[self.request setHTTPMethod: @&#34;GET&#34;];&#10; &#10;self.connection =[[NSURLConnection alloc] initWithRequest:self.request&#10; &#10;                                                 delegate:self&#10; &#10;                                         startImmediately:NO];&#10; &#10;NSRunLoop *runLoop = [NSRunLoop currentRunLoop];&#10; &#10;[runLoop run];&#10; &#10;[self.connection scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];&#10; &#10;[self.connection start];</span><br></pre></td></tr></table></figure>
<p>运行之后发现回调仍然没有被调用，其实在这里卡了很久。后来一次偶然的调试中发现，代码运行到 [runLoop run]; 就没有然后了。后面的代码一直就没有被执行，现在修改代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.request = [[NSMutableURLRequest alloc]&#10; &#10;                                initWithURL:[NSURL URLWithString:@&#34;http://www.baidu.com&#34;]&#10; &#10;                                cachePolicy:NSURLCacheStorageNotAllowed&#10; &#10;                                timeoutInterval:10];&#10; &#10;[self.request setHTTPMethod: @&#34;GET&#34;];&#10; &#10;self.connection =[[NSURLConnection alloc] initWithRequest:self.request&#10; &#10;                                                 delegate:self&#10; &#10;                                         startImmediately:NO];&#10; &#10;NSRunLoop *runLoop = [NSRunLoop currentRunLoop];&#10; &#10;[self.connection scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];&#10; &#10;[self.connection start];&#10; &#10;[runLoop run];</span><br></pre></td></tr></table></figure>
<p>然后就发现网络回调被调用了。</p>
<p>之后分析了一下调用堆栈：</p>
<p>第一个：在multiThread里面是这样的：</p>
<p><img src="http://7xqgnx.com1.z0.glb.clouddn.com/Runloop1.png" alt="multiThread.png"></p>
<p>第二个：网络回调里面是这样的：</p>
<p><a href="http://7xqgnx.com1.z0.glb.clouddn.com/Runloop2.png" target="_blank" rel="external">http://7xqgnx.com1.z0.glb.clouddn.com/Runloop2.png</a></p>
<p>通过堆栈可以得知，这两个函数都是由线程6调用的，也就是创建的子线程，但是堆栈中的内容很不一样。很显然第二个是从runloop 调出的，并且是Sources0这个消息调出的。而第一个是线程运行时候的初始化方法。所以当调用runloop run的时候，其实是线程进入自己的runloop去监听时间了，从此以后，所有的代码都会从runloop CALLOUT出来。所以这种情况下，需要把先把消息注册到runloop中，让runloop跑起来是最后需要做的事情。</p>
<p>以下是开源库AFNetworking网络请求的实现：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)start &#123;&#10; &#10;    [self.lock lock];&#10; &#10;    if ([self isCancelled]) &#123;&#10;        [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];&#10; &#10;    &#125; else if ([self isReady]) &#123;&#10;        self.state = AFOperationExecutingState;&#10;        [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];&#10; &#10;    &#125;&#10;    [self.lock unlock];&#10;&#125;&#10;+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123;&#10; &#10;    @autoreleasepool &#123;&#10;        [[NSThread currentThread] setName:@&#34;AFNetworking&#34;];&#10;        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];&#10;        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];&#10;        [runLoop run];&#10;    &#125;&#10;&#125;&#10; &#10;+ (NSThread *)networkRequestThread &#123;&#10; &#10;    static NSThread *_networkRequestThread = nil;&#10;    static dispatch_once_t oncePredicate;&#10; &#10;    dispatch_once(&#38;oncePredicate, ^&#123;&#10;        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];&#10;        [_networkRequestThread start];&#10;    &#125;);&#10;    return _networkRequestThread;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>AFNetworking使用的是<strong>- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait</strong>这个方法，但是为什么它没有使用<strong>- (void)performSelectorInBackground:(SEL)aSelector withObject:(id)arg</strong>这个方法呢？</p>
<p>通过断点，发现了AFNetwokring网络请求中一些函数的调用顺序：</p>
<p>1.networkRequestThread</p>
<p>2.networkRequestThreadEntryPoint</p>
<p>3.operationDidStart</p>
<p>为什么operationDidStart会在networkRequestThreadEntryPoint之后调用？</p>
<p>在networkRequestThreadEntryPoint里主要是生成网络线程的runloop并且让它跑起来，里面的  [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];这主要是为了在没有任何网络请求的时候让网络线程保持监听状态，否则网络线程的loop会直接返回，之后再调用网络线程请求就没有意义了。再结合调用堆栈，发现operationDidStart是在runloop callout出来的，而networkRequestThreadEntryPoint是网络线程的入口方法。这跟之前的例子是一样的。所以，我猜测<strong>- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait</strong></p>
<p>这个方法背后是由主线程将aSelector作为消息注册到runloop中时间发生在networkRequestThreadEntryPoint方法调用之前，所以在networkRequestThreadEntryPoint方法中调用,NSRunLoop currentRunLoop的时候其实runloop本身应该已经被创建了。原因是因为在这个地方断点 ，打印runloop对象可以发现里面已经注册了source0的消息，如下截图：</p>
<p><a href="http://7xqgnx.com1.z0.glb.clouddn.com/Runloop3.png" target="_blank" rel="external">http://7xqgnx.com1.z0.glb.clouddn.com/Runloop3.png</a></p>
<p>也就是说父线程在- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait 函数中将aSelector注册成source0，这是该函数背后的大致实现。通过查阅apple官方文档，基本属实，如下所示：</p>
<p><a href="http://7xqgnx.com1.z0.glb.clouddn.com/Runloop4.png" target="_blank" rel="external">http://7xqgnx.com1.z0.glb.clouddn.com/Runloop4.png</a></p>
<p>通过上面的分析，可以得出使用<strong>performSelector</strong>方法可以将子线程runloop的初始化实现在子线程的初始化方法里实现，如果使用<strong>performSelectorInBackground</strong></p>
<p>方法，那么子线程runloop的初始化和业务逻辑就会混到一起，并且每一次都会重新初始化。AFNetworking通过一个静态全局的子线程去管理所有的网络请求，其对应的runloop也只需要初始化一次。</p>
<p>通过以上分析，可以知道如果需要让一个子线程去持续的监听时间，就需要启动它的runloop并且忘其中注册source，timer，oberserver三者之一的消息类型。在默认情况下子线程的runloop是不会自己创建和启动的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="郑智文" />
          <p class="site-author-name" itemprop="name">郑智文</p>
          <p class="site-description motion-element" itemprop="description">车到山前必有路</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">19</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分類</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">標籤</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">郑智文</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"zhengzhiwen"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
