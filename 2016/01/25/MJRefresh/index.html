<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="博客"><title>MJRefresh | 一只独来独往的水鸟</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">MJRefresh</h1><a id="logo" href="/.">一只独来独往的水鸟</a><p class="description">iOS</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">MJRefresh</h1><div class="post-meta">Jan 25, 2016<span> | </span><span class="category"><a href="/categories/Tech/">Tech</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h2 id="基本原理："><a href="#基本原理：" class="headerlink" title="基本原理："></a>基本原理：</h2><p>通过header view和 foot view 添加对scrollview contentOffset属性 kvo 实现动态刷新。在runtime对scrollview添加header的时候，在view的willMoveToSuperView生命周期方法中进行注册。</p>
<h2 id="需要记忆理解的地方："><a href="#需要记忆理解的地方：" class="headerlink" title="需要记忆理解的地方："></a>需要记忆理解的地方：</h2><p>1.scrollview往上滑动的时候，contentOffsize的y是正数。scrollview往下滑动的时候，contentOffsize的y是负数。</p>
<p>2.header和footer的位置和大小是在view的layoutSubviews生命周期方法里设置的。</p>
<p>3.通过设置header或者footer的状态的时候控制其行为</p>
<p>小技巧：</p>
<p>1.在子类中调用了父类的方法，如果要求子类在其实现中必须调用父类的方法，可以在方法声明的时候添加 NS_REQUIRES_SUPER 宏，编译器在编译过程可进行检查。</p>
<a id="more"></a> 
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>1.MJRefreshNormalHeader</p>
<p>在初始化的时候,会调用init方法，在Init方法里，系统默认调用了initWithFrame方法，frame传的CGRectZero.在MJRefreshNormalHeader的父类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithFrame:(CGRect)frame</span><br><span class="line">&#123;</span><br><span class="line">    if (self = [super initWithFrame:frame]) &#123;</span><br><span class="line"> </span><br><span class="line">        // 准备工作</span><br><span class="line"> </span><br><span class="line">        [self prepare];</span><br><span class="line"> </span><br><span class="line">        // 默认是普通状态</span><br><span class="line"> </span><br><span class="line">        self.state = MJRefreshStateIdle;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>prepare方法设置了header的宽高和x的位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)prepare</span><br><span class="line">&#123;</span><br><span class="line">    [super prepare];  </span><br><span class="line"> </span><br><span class="line">    // 设置key</span><br><span class="line"> </span><br><span class="line">    self.lastUpdatedTimeKey = MJRefreshHeaderLastUpdatedTimeKey;</span><br><span class="line"> </span><br><span class="line">    // 设置高度</span><br><span class="line"> </span><br><span class="line">    self.mj_h = MJRefreshHeaderHeight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置state属性方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">- (void)setState:(MJRefreshState)state</span><br><span class="line">&#123;</span><br><span class="line">//这个宏主要是来以下的逻辑只有是在状态发生变化的时候才执行，避免重复的逻辑。</span><br><span class="line">    MJRefreshCheckState</span><br><span class="line">    // 根据状态做事情</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//从其他状态变成初始静止的状态</span><br><span class="line">    if (state == MJRefreshStateIdle) &#123;</span><br><span class="line"> </span><br><span class="line">     //这里相当于仅用于处理从刷新中的状态转化成静止状态</span><br><span class="line">        if (oldState != MJRefreshStateRefreshing) return;</span><br><span class="line">        // 保存刷新时间</span><br><span class="line"> </span><br><span class="line">        [[NSUserDefaults standardUserDefaults] setObject:[NSDate date] forKey:</span><br><span class="line">        self.lastUpdatedTimeKey];</span><br><span class="line"> </span><br><span class="line">        [[NSUserDefaults standardUserDefaults] synchronize];</span><br><span class="line"> </span><br><span class="line">        // 恢复inset和offset</span><br><span class="line"> </span><br><span class="line">        [UIView animateWithDuration:MJRefreshSlowAnimationDuration animations:^</span><br><span class="line">        &#123;</span><br><span class="line"> </span><br><span class="line">            self.scrollView.mj_insetT += self.insetTDelta;</span><br><span class="line"> </span><br><span class="line">            // 自动调整透明度</span><br><span class="line"> </span><br><span class="line">            if (self.isAutomaticallyChangeAlpha) self.alpha = 0.0;</span><br><span class="line"> </span><br><span class="line">        &#125; completion:^(BOOL finished) &#123;</span><br><span class="line">//这个属性主要是用来控制随着下拉的距离来反应到header的透明度</span><br><span class="line">            self.pullingPercent = 0.0;</span><br><span class="line"> </span><br><span class="line">        &#125;];</span><br><span class="line"> </span><br><span class="line">    &#125; else if (state == MJRefreshStateRefreshing) &#123;</span><br><span class="line"> </span><br><span class="line">        [UIView animateWithDuration:MJRefreshFastAnimationDuration animations:^</span><br><span class="line">        &#123;</span><br><span class="line"> </span><br><span class="line">            // 增加滚动区域</span><br><span class="line"> </span><br><span class="line">            CGFloat top = self.scrollViewOriginalInset.top + self.mj_h;</span><br><span class="line"> </span><br><span class="line">            self.scrollView.mj_insetT = top;</span><br><span class="line"> </span><br><span class="line">             </span><br><span class="line">            // 设置滚动位置</span><br><span class="line"> </span><br><span class="line">            self.scrollView.mj_offsetY = - top;</span><br><span class="line"> </span><br><span class="line">        &#125; completion:^(BOOL finished) &#123;</span><br><span class="line">//业务逻辑层的刷新数据</span><br><span class="line">            [self executeRefreshingCallback];</span><br><span class="line"> </span><br><span class="line">        &#125;];</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据拖拽进度设置透明度:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)setPullingPercent:(CGFloat)pullingPercent</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line">    _pullingPercent = pullingPercent;</span><br><span class="line"> </span><br><span class="line">    if (self.isRefreshing) return;</span><br><span class="line"> </span><br><span class="line">    if (self.isAutomaticallyChangeAlpha) &#123;</span><br><span class="line"> </span><br><span class="line">        self.alpha = pullingPercent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在UIScrollVIEW+MJRefresh中的setMj_header方法，给UIScrollView动态的添加了一个header，并将它加到了ScrollView上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)setMj_header:(MJRefreshHeader *)mj_header</span><br><span class="line">&#123;</span><br><span class="line">    if (mj_header != self.mj_header) &#123;</span><br><span class="line"> </span><br><span class="line">        // 删除旧的，添加新的</span><br><span class="line"> </span><br><span class="line">        [self.mj_header removeFromSuperview];</span><br><span class="line"> </span><br><span class="line">        [self insertSubview:mj_header atIndex:0];</span><br><span class="line">        // 存储新的</span><br><span class="line"> </span><br><span class="line">        [self willChangeValueForKey:@&quot;mj_header&quot;]; // KVO</span><br><span class="line"> </span><br><span class="line">        objc_setAssociatedObject(self, &amp;MJRefreshHeaderKey,</span><br><span class="line"> </span><br><span class="line">                                 mj_header, OBJC_ASSOCIATION_ASSIGN);</span><br><span class="line"> </span><br><span class="line">        [self didChangeValueForKey:@&quot;mj_header&quot;]; // KVO</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将header加到ScrollView上的时候，系统会调用willMoveToSuperview方法，将header从ScrollView删除的时候也会调用这个方法，区别是删除的时候参数传的nil，添加的时候参数为当前scrollView.在这个方法中设置了header的x位置以及header的宽度，并且添加了对scrollview的监听</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (void)willMoveToSuperview:(UIView *)newSuperview</span><br><span class="line">&#123;</span><br><span class="line">    [super willMoveToSuperview:newSuperview];</span><br><span class="line">    // 如果不是UIScrollView，不做任何事情</span><br><span class="line">    if (newSuperview &amp;&amp; ![newSuperview isKindOfClass:[UIScrollView class]]) </span><br><span class="line">    return;</span><br><span class="line"> </span><br><span class="line">    // 旧的父控件移除监听</span><br><span class="line">    [self removeObservers];</span><br><span class="line">    if (newSuperview) &#123; // 新的父控件</span><br><span class="line">        // 设置宽度</span><br><span class="line">        self.mj_w = newSuperview.mj_w;</span><br><span class="line"> </span><br><span class="line">        // 设置位置</span><br><span class="line">        self.mj_x = 0;</span><br><span class="line">        // 记录UIScrollView</span><br><span class="line">        _scrollView = (UIScrollView *)newSuperview;</span><br><span class="line"> </span><br><span class="line">        // 设置永远支持垂直弹簧效果</span><br><span class="line">        _scrollView.alwaysBounceVertical = YES;</span><br><span class="line"> </span><br><span class="line">        // 记录UIScrollView最开始的contentInset</span><br><span class="line">        _scrollViewOriginalInset = _scrollView.contentInset;</span><br><span class="line"> </span><br><span class="line">        // 添加监听</span><br><span class="line">        [self addObservers];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加监听的方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)addObservers</span><br><span class="line">&#123;</span><br><span class="line">    NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | </span><br><span class="line">    NSKeyValueObservingOptionOld;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//监测滑动距离，判断是否到达需要刷新的程度</span><br><span class="line">    [self.scrollView addObserver:self forKeyPath:MJRefreshKeyPathContentOffset </span><br><span class="line">    options:options context:nil];</span><br><span class="line">//检测contentSize变化，比如上拉加载更多，动态改变footer的位置</span><br><span class="line">    [self.scrollView addObserver:self forKeyPath:MJRefreshKeyPathContentSize </span><br><span class="line">    options:options context:nil];</span><br><span class="line">//检测平移的手势</span><br><span class="line">    self.pan = self.scrollView.panGestureRecognizer;</span><br><span class="line">    [self.pan addObserver:self forKeyPath:MJRefreshKeyPathPanState options:</span><br><span class="line">    options context:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，系统会开始调用layoutSubViews方法：在MJRefreshComponent中重写了这个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">- (void)layoutSubviews</span><br><span class="line">&#123;</span><br><span class="line">    [super layoutSubviews];</span><br><span class="line">    [self placeSubviews];</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//placeSubviews方法是在各个MJRefreshComponent的子类中实现的，</span><br><span class="line">//继承链:MJRefreshNormalHeader -&gt; MJRefreshStateHeader -&gt; MJRefreshHeader -&gt; MJRefreshComponent</span><br><span class="line">  </span><br><span class="line">//以下是MJRefreshHeader中的实现,设置了header的y的位置</span><br><span class="line">- (void)placeSubviews</span><br><span class="line">&#123;</span><br><span class="line">    [super placeSubviews];</span><br><span class="line">    // 设置y值(当自己的高度发生改变了，肯定要重新调整Y值，</span><br><span class="line">    //所以放到placeSubviews方法中设置y值)</span><br><span class="line">    self.mj_y = - self.mj_h - self.ignoredScrollViewContentInsetTop;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//以下是MJRefreshStateHeader中的实现,添加刷新状体和更新时间</span><br><span class="line">- (void)placeSubviews</span><br><span class="line">&#123;</span><br><span class="line">    [super placeSubviews];</span><br><span class="line">    if (self.stateLabel.hidden) return;</span><br><span class="line"> </span><br><span class="line">    BOOL noConstrainsOnStatusLabel = self.stateLabel.constraints.count == 0;</span><br><span class="line"> </span><br><span class="line">    if (self.lastUpdatedTimeLabel.hidden) &#123;</span><br><span class="line"> </span><br><span class="line">        // 状态</span><br><span class="line"> </span><br><span class="line">        if (noConstrainsOnStatusLabel) self.stateLabel.frame = self.bounds;</span><br><span class="line"> </span><br><span class="line">    &#125; else &#123;</span><br><span class="line"> </span><br><span class="line">        CGFloat stateLabelH = self.mj_h * 0.5;</span><br><span class="line"> </span><br><span class="line">        // 状态</span><br><span class="line"> </span><br><span class="line">        if (noConstrainsOnStatusLabel) &#123;</span><br><span class="line"> </span><br><span class="line">            self.stateLabel.mj_x = 0;</span><br><span class="line"> </span><br><span class="line">            self.stateLabel.mj_y = 0;</span><br><span class="line"> </span><br><span class="line">            self.stateLabel.mj_w = self.mj_w;</span><br><span class="line"> </span><br><span class="line">            self.stateLabel.mj_h = stateLabelH;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        // 更新时间</span><br><span class="line">        if (self.lastUpdatedTimeLabel.constraints.count == 0) &#123;</span><br><span class="line"> </span><br><span class="line">            self.lastUpdatedTimeLabel.mj_x = 0;</span><br><span class="line"> </span><br><span class="line">            self.lastUpdatedTimeLabel.mj_y = stateLabelH;</span><br><span class="line"> </span><br><span class="line">            self.lastUpdatedTimeLabel.mj_w = self.mj_w;</span><br><span class="line"> </span><br><span class="line">            self.lastUpdatedTimeLabel.mj_h = self.mj_h - self.lastUpdatedTimeLabel.mj_y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//以下是MJRefreshNormalHeader中的实现，添加剪头和loadingview</span><br><span class="line">- (void)placeSubviews</span><br><span class="line">&#123;</span><br><span class="line">    [super placeSubviews];</span><br><span class="line">    // 箭头的中心点</span><br><span class="line"> </span><br><span class="line">    CGFloat arrowCenterX = self.mj_w * 0.5;</span><br><span class="line"> </span><br><span class="line">    if (!self.stateLabel.hidden) &#123;</span><br><span class="line">        arrowCenterX -= 100;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    CGFloat arrowCenterY = self.mj_h * 0.5;</span><br><span class="line"> </span><br><span class="line">    CGPoint arrowCenter = CGPointMake(arrowCenterX, arrowCenterY);</span><br><span class="line"> </span><br><span class="line">    // 箭头</span><br><span class="line">    if (self.arrowView.constraints.count == 0) &#123;</span><br><span class="line">        self.arrowView.mj_size = self.arrowView.image.size;</span><br><span class="line">        self.arrowView.center = arrowCenter;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 圈圈</span><br><span class="line">    if (self.loadingView.constraints.count == 0) &#123;</span><br><span class="line">        self.loadingView.center = arrowCenter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>header中监控下拉距离的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">- (void)scrollViewContentOffsetDidChange:(NSDictionary *)change</span><br><span class="line">&#123;</span><br><span class="line">    [super scrollViewContentOffsetDidChange:change];</span><br><span class="line"> </span><br><span class="line">    // 在刷新的refreshing状态</span><br><span class="line"> </span><br><span class="line">    if (self.state == MJRefreshStateRefreshing) &#123;</span><br><span class="line">        if (self.window == nil) return;</span><br><span class="line">        // sectionheader停留解决</span><br><span class="line">        CGFloat insetT = - self.scrollView.mj_offsetY &gt; _scrollViewOriginalInset.top ? - self.scrollView.mj_offsetY : </span><br><span class="line">        _scrollViewOriginalInset.top;</span><br><span class="line">        insetT = insetT &gt; self.mj_h + _scrollViewOriginalInset.top ? self.mj_h</span><br><span class="line">         + _scrollViewOriginalInset.top : insetT;</span><br><span class="line">        self.scrollView.mj_insetT = insetT;</span><br><span class="line">        self.insetTDelta = _scrollViewOriginalInset.top - insetT;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 跳转到下一个控制器时，contentInset可能会变</span><br><span class="line">     _scrollViewOriginalInset = self.scrollView.contentInset;</span><br><span class="line"> </span><br><span class="line">    // 当前的contentOffset</span><br><span class="line">    CGFloat offsetY = self.scrollView.mj_offsetY;</span><br><span class="line"> </span><br><span class="line">    // 头部控件刚好出现的offsetY</span><br><span class="line">    CGFloat happenOffsetY = - self.scrollViewOriginalInset.top;</span><br><span class="line">    // 如果是向上滚动到看不见头部控件，直接返回</span><br><span class="line">    if (offsetY &gt; happenOffsetY) return;</span><br><span class="line"> </span><br><span class="line">    // 普通 和 即将刷新 的临界点, self.mj_h是当前header的高度</span><br><span class="line">    CGFloat normal2pullingOffsetY = happenOffsetY - self.mj_h;</span><br><span class="line">    CGFloat pullingPercent = (happenOffsetY - offsetY) / self.mj_h;</span><br><span class="line"> </span><br><span class="line">    if (self.scrollView.isDragging) &#123; // 如果正在拖拽</span><br><span class="line">        self.pullingPercent = pullingPercent;</span><br><span class="line">//header正好完全露出来，开始转为刷新状态</span><br><span class="line">        if (self.state == MJRefreshStateIdle &amp;&amp; offsetY &lt; normal2pullingOffsetY</span><br><span class="line">            ) &#123;</span><br><span class="line">            // 转为即将刷新状态</span><br><span class="line">            self.state = MJRefreshStatePulling;</span><br><span class="line">        &#125; else if (self.state == MJRefreshStatePulling &amp;&amp; offsetY &gt;= </span><br><span class="line">            normal2pullingOffsetY) &#123;</span><br><span class="line">            // 转为普通状态</span><br><span class="line">            self.state = MJRefreshStateIdle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (self.state == MJRefreshStatePulling) &#123;// 即将刷新 &amp;&amp; 手松开</span><br><span class="line">        // 开始刷新</span><br><span class="line">        [self beginRefreshing];</span><br><span class="line">    &#125; else if (pullingPercent &lt; 1) &#123;</span><br><span class="line">        self.pullingPercent = pullingPercent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>footer同header一样都继承自MJFfreshComponent，都自动检测scrollview的行为，各自实现具体的被通知的逻辑</p>
<p>MJRefreshAutoFooter的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">- (void)scrollViewContentOffsetDidChange:(NSDictionary *)change</span><br><span class="line">&#123;</span><br><span class="line">    [super scrollViewContentOffsetDidChange:change];</span><br><span class="line">    if (self.state != MJRefreshStateIdle || !self.automaticallyRefresh || self.</span><br><span class="line">        mj_y == 0) return;</span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">    if (_scrollView.mj_insetT + _scrollView.mj_contentH &gt; _scrollView.mj_h) &#123; </span><br><span class="line">    // 内容超过一个屏幕</span><br><span class="line"> </span><br><span class="line">        // 这里的_scrollView.mj_contentH替换掉self.mj_y更为合理</span><br><span class="line"> </span><br><span class="line">        if (_scrollView.mj_offsetY &gt;= _scrollView.mj_contentH - _scrollView.</span><br><span class="line">            mj_h + self.mj_h * self.triggerAutomaticallyRefreshPercent + </span><br><span class="line">            _scrollView.mj_insetB - self.mj_h) &#123;</span><br><span class="line"> </span><br><span class="line">            // 防止手松开时连续调用</span><br><span class="line"> </span><br><span class="line">            CGPoint old = [change[@&quot;old&quot;] CGPointValue];</span><br><span class="line"> </span><br><span class="line">            CGPoint new = [change[@&quot;new&quot;] CGPointValue];</span><br><span class="line"> </span><br><span class="line">            if (new.y &lt;= old.y) return;</span><br><span class="line"> </span><br><span class="line">            // 当底部刷新控件完全出现时，才刷新</span><br><span class="line"> </span><br><span class="line">            [self beginRefreshing];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)scrollViewPanStateDidChange:(NSDictionary *)change</span><br><span class="line">&#123;</span><br><span class="line">    [super scrollViewPanStateDidChange:change];</span><br><span class="line"> </span><br><span class="line">    if (self.state != MJRefreshStateIdle) return;</span><br><span class="line"> </span><br><span class="line">    if (_scrollView.panGestureRecognizer.state == UIGestureRecognizerStateEnded</span><br><span class="line">    ) &#123;// 手松开</span><br><span class="line">        if (_scrollView.mj_insetT + _scrollView.mj_contentH &lt;= _scrollView.mj_h</span><br><span class="line">        ) &#123;  // 不够一个屏幕</span><br><span class="line">            if (_scrollView.mj_offsetY &gt;= - _scrollView.mj_insetT) &#123; // 向上拽</span><br><span class="line">                [self beginRefreshing];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123; // 超出一个屏幕</span><br><span class="line">            if (_scrollView.mj_offsetY &gt;= _scrollView.mj_contentH + _scrollView</span><br><span class="line">                .mj_insetB - _scrollView.mj_h) &#123;</span><br><span class="line">                [self beginRefreshing];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2016/01/25/MJRefresh/" data-id="cjkhxzall000ym8ensbnm9vqe" class="article-share-link">分享</a><div class="tags"><a href="/tags/源码分析/">源码分析</a></div><div class="post-nav"><a href="/2016/01/25/Runloop相关探索/" class="pre">Runloop相关探索</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Tech/">Tech</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">Tools</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/源码分析/" style="font-size: 15px;">源码分析</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/Node/" style="font-size: 15px;">Node</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/01/29/布局结束监测工具/">布局结束监听工具</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/11/Node小结/">Node小结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/02/iOS性能监控/">iOS性能监控</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/25/Method Swizzle的危机/">Method Swizzle的危机</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/25/GitHook/">Git Hook</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/19/Method Swizzle中的对象模型/">Method Swizzle中的对象模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/19/iOS定位库-INTULocationRequest/">iOS定位库-INTULocationRequest</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/13/AFNetWorking—NSURLSession/">AFNetWorking—NSURLSession</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/13/AFNetworking-NSURLConnection/">AFNetworking-NSURLConnection</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/13/AFNetworking-ResponseSerializer/">AFNetworking-ResponseSerializer</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">一只独来独往的水鸟.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>