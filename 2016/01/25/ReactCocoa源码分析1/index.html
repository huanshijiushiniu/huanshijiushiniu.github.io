<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="博客"><title>ReactCocoa源码分析1 | 一只独来独往的水鸟</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">ReactCocoa源码分析1</h1><a id="logo" href="/.">一只独来独往的水鸟</a><p class="description">iOS</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">ReactCocoa源码分析1</h1><div class="post-meta">Jan 25, 2016<span> | </span><span class="category"><a href="/categories/Tech/">Tech</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h2 id="u95EE_u98981"><a href="#u95EE_u98981" class="headerlink" title="问题1"></a>问题1</h2><p>在看代码的时候，发现代码中使用到了</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidload&#10;&#123;&#10;    [super viewDidload];&#10;    [self bindData];&#10;&#125;&#10;  &#10;- (void)bindData&#10;&#123;&#10;    [[RACObserve(self, propertyA) ignore:nil] &#10;                                 subscribeNext:^(NSArray *dataA) &#123;&#10;        NSLog(@&#34;use dataA&#34;);&#10;    &#125;];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>但是在这个类的propertyA是在init之后去设置的，在viewDidload之前。也就是在使用RAC订阅属性变化信号之前，但是use dataA打印出来了。猜测RACObserve宏生成信号在调用subscribeNext中，直接就调用了dataA的block的逻辑。但是感觉比较奇怪，不应该是propertyA变化的时候才会调用dataA的block的逻辑吗。</p>
<p>现在具体看一下，一个信号的创建和订阅的源码：</p>
<a id="more"></a> 
<h3 id="u4FE1_u53F7_u521B_u5EFA_uFF1A"><a href="#u4FE1_u53F7_u521B_u5EFA_uFF1A" class="headerlink" title="信号创建："></a>信号创建：</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)createSignal:(RACDisposable * (^)(id&#60;RACSubscriber&#62; subscriber))&#10;didSubscribe &#123;&#10; &#10;    return [RACDynamicSignal createSignal:didSubscribe];&#10; &#10;&#125;&#10;+ (RACSignal *)createSignal:(RACDisposable * (^)(id&#60;RACSubscriber&#62; subscriber))&#10;didSubscribe &#123;&#10; &#10;    RACDynamicSignal *signal = [[self alloc] init];&#10; &#10;    signal-&#62;_didSubscribe = [didSubscribe copy];&#10; &#10;    return [signal setNameWithFormat:@&#34;+createSignal:&#34;];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在创建一个信号的时候，会传进来一个叫didSubscribe的block，该信号会把它存下来。</p>
<h3 id="u4FE1_u53F7_u8BA2_u9605"><a href="#u4FE1_u53F7_u8BA2_u9605" class="headerlink" title="信号订阅"></a>信号订阅</h3><p>RACSignal的subscribeNext方法:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock &#123;&#10;    NSCParameterAssert(nextBlock != NULL);&#10;    RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:NULL completed:NULL];&#10;    return [self subscribe:o];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在singal的subscribeNext中，生成了一个subscriber。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)subscriberWithNext:(void (^)(id x))next error:(void (^)(NSError&#10; *error))error completed:(void (^)(void))completed &#123;&#10; &#10;    RACSubscriber *subscriber = [[self alloc] init];&#10; &#10; &#10;    subscriber-&#62;_next = [next copy];&#10; &#10;    subscriber-&#62;_error = [error copy];&#10; &#10;    subscriber-&#62;_completed = [completed copy];&#10; &#10;    return subscriber;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>subscriber保存了nextBlock，errorBlock，completedBlock等数据信息</p>
<p>接着看signal的subscribe方法，改方法的参数是subscribeNext方法中生成的subscriber对象</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribe:(id&#60;RACSubscriber&#62;)subscriber &#123;&#10; &#10;    NSCParameterAssert(subscriber != nil);&#10; &#10;    RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];&#10; &#10;    subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable];&#10; &#10; &#10;    if (self.didSubscribe != NULL) &#123;&#10; &#10;        RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123;&#10; &#10;            RACDisposable *innerDisposable = self.didSubscribe(subscriber);&#10; &#10;            [disposable addDisposable:innerDisposable];&#10; &#10;        &#125;];&#10; &#10; &#10;        [disposable addDisposable:schedulingDisposable];&#10; &#10;    &#125;&#10; &#10;    return disposable;&#10; &#10;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)schedule:(void (^)(void))block &#123;&#10;    NSCParameterAssert(block != NULL);&#10; &#10;    if (RACScheduler.currentScheduler == nil) return [self.backgroundScheduler schedule:block];&#10; &#10;    block();&#10; &#10;    return nil;&#10; &#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在signal的subscribe方法中，调用了RACScheduler.subscriptionScheduler schedule 方法，直接就将传入的block调用了，最终调用了signal的didSubscribe block，将subscriber传入。</p>
<p>再看一下RACObserve在生成一个signal的时候，传入的didSubscribe block逻辑的怎样的，以下是RACObserve相关源码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define RACObserve(TARGET, KEYPATH) \&#10; &#10;    (&#123; \&#10; &#10;        _Pragma(&#34;clang diagnostic push&#34;) \&#10; &#10;        _Pragma(&#34;clang diagnostic ignored \&#34;-Wreceiver-is-weak\&#34;&#34;) \&#10; &#10;        __weak id target_ = (TARGET); \&#10; &#10;        [target_ rac_valuesForKeyPath:@keypath(TARGET, KEYPATH) observer:self];&#10;         \&#10; &#10;        _Pragma(&#34;clang diagnostic pop&#34;) \&#10; &#10;    &#125;)</span><br></pre></td></tr></table></figure>
<p>在NSObject的RACPropertySubscribing分类中定义rac_valuesForKeyPath:observer:self:方法</p>
<p>继续：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)rac_valuesForKeyPath:(NSString *)keyPath observer:(__weak &#10;    NSObject *)observer &#123;&#10; &#10;    return [[[self&#10; &#10;        rac_valuesAndChangesForKeyPath:keyPath options:NSKeyValueObservingOptionInitial observer:observer]&#10; &#10;        map:^(RACTuple *value) &#123;&#10; &#10;            // -map: because it doesn&#39;t require the block trampoline that -reduceEach: uses&#10; &#10;            return value[0];&#10; &#10;        &#125;]&#10; &#10;        setNameWithFormat:@&#34;RACObserve(%@, %@)&#34;, self.rac_description, keyPath];&#10; &#10;&#125;</span><br></pre></td></tr></table></figure>
<p>继续：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)rac_valuesAndChangesForKeyPath:(NSString *)keyPath options:(&#10;    NSKeyValueObservingOptions)options observer:(__weak NSObject *)&#10;    weakObserver &#123;&#10; &#10;    NSObject *strongObserver = weakObserver;&#10; &#10;    keyPath = [keyPath copy];&#10; &#10;    NSRecursiveLock *objectLock = [[NSRecursiveLock alloc] init];&#10; &#10;    objectLock.name = @&#34;&#10;    org.reactivecocoa.ReactiveCocoa.NSObjectRACPropertySubscribing&#34;;&#10; &#10;    __weak NSObject *weakSelf = self;&#10; &#10;    RACSignal *deallocSignal = [[RACSignal&#10; &#10;        zip:@[&#10; &#10;            self.rac_willDeallocSignal,&#10; &#10;            strongObserver.rac_willDeallocSignal ?: [RACSignal never]&#10; &#10;        ]]&#10; &#10;        doCompleted:^&#123;&#10; &#10;            // Forces deallocation to wait if the object variables are currently&#10; &#10;            // being read on another thread.&#10; &#10;            [objectLock lock];&#10; &#10;            @onExit &#123;&#10; &#10;                [objectLock unlock];&#10; &#10;            &#125;;&#10; &#10;        &#125;];&#10; &#10;//&#37325;&#28857;&#20851;&#27880;&#36825;&#37324;&#65292;createSignal&#20043;&#21518;&#30340;&#21442;&#25968;&#23601;&#26159;&#35813;&#20449;&#21495;&#30340;didSubscribe block&#36923;&#36753;&#20102;&#12290;&#10;    return [[[RACSignal&#10; &#10;        createSignal:^ RACDisposable * (id&#60;RACSubscriber&#62; subscriber) &#123;&#10; &#10;            // Hold onto the lock the whole time we&#39;re setting up the KVO&#10; &#10;            // observation, because any resurrection that might be caused by our&#10; &#10;            // retaining below must be balanced out by the time -dealloc returns&#10; &#10;            // (if another thread is waiting on the lock above).&#10; &#10;            [objectLock lock];&#10; &#10;            @onExit &#123;&#10; &#10;                [objectLock unlock];&#10; &#10;            &#125;;&#10; &#10;            __strong NSObject *observer __attribute__((objc_precise_lifetime)) &#10;            = weakObserver;&#10; &#10;            __strong NSObject *self __attribute__((objc_precise_lifetime)) = &#10;            weakSelf;&#10; &#10;            if (self == nil) &#123;&#10; &#10;                [subscriber sendCompleted];&#10; &#10;                return nil;&#10; &#10;            &#125;&#10; &#10; &#10;            return [self rac_observeKeyPath:keyPath options:options observer:&#10;            observer block:^(id value, NSDictionary *change, BOOL &#10;                causedByDealloc, BOOL affectedOnlyLastComponent) &#123;&#10; &#10;                [subscriber sendNext:RACTuplePack(value, change)];&#10; &#10;            &#125;];&#10; &#10;        &#125;]&#10; &#10;        takeUntil:deallocSignal]&#10; &#10;        setNameWithFormat:@&#34;%@ -rac_valueAndChangesForKeyPath: %@ options: %lu &#10;        observer: %@&#34;, self.rac_description, keyPath, (unsigned long)options, &#10;        strongObserver.rac_description];&#10; &#10;&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在RACObserver宏定义的signal的didSubscriber block中又调用了rac_observeKeyPath:keyPath options: observer: block</p>
<p>继续(太长了只贴重点)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)rac_observeKeyPath:(NSString *)keyPath options:(&#10;    NSKeyValueObservingOptions)options observer:(__weak NSObject *)&#10;    weakObserver block:(void (^)(id, NSDictionary *, BOOL, BOOL))block &#123;&#10; &#10;    NSCParameterAssert(block != nil);&#10; &#10;    NSCParameterAssert(keyPath.rac_keyPathComponents.count &#62; 0);&#10; &#10;    //&#30465;&#30053;&#25968;&#21313;&#34892;&#10;    // Call the block with the initial value if needed.&#10; &#10;    if ((options &#38; NSKeyValueObservingOptionInitial) != 0) &#123;&#10; &#10;        id initialValue = [self valueForKeyPath:keyPath];&#10; &#10;        NSDictionary *initialChange = @&#123;&#10; &#10;            NSKeyValueChangeKindKey: @(NSKeyValueChangeSetting),&#10; &#10;            NSKeyValueChangeNewKey: initialValue ?: NSNull.null,&#10; &#10;        &#125;;&#10; &#10;        block(initialValue, initialChange, NO, keyPathHasOneComponent);&#10; &#10;    &#125;&#10;     &#10;    //&#30465;&#30053;&#25968;&#21313;&#34892;&#10; &#10;&#125;</span><br></pre></td></tr></table></figure>
<p>说明一下，options是NSKeyValueObservingOptions属于NS_OPTIONS</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, NSKeyValueObservingOptions) &#123;&#10; &#10;    NSKeyValueObservingOptionNew = 0x01,&#10; &#10;    NSKeyValueObservingOptionOld = 0x02,&#10; &#10;    NSKeyValueObservingOptionInitial NS_ENUM_AVAILABLE(10_5, 2_0) = 0x04,&#10; &#10;    NSKeyValueObservingOptionPrior NS_ENUM_AVAILABLE(10_5, 2_0) = 0x08&#10;&#125;;</span><br></pre></td></tr></table></figure>
<p>在以上方法中，它判断了，传入的options是否是NSKeyValueObservingOptionInitial类型，而在调用rac_observeKeyPath: options: observer: block:的时候，option就是传的NSKeyValueObservingOptionInitial，所以会直接调用传进来的block，在rac_valuesAndChangesForKeyPath: options: observer:中调用rac_observeKeyPath: options: observer: block:的时候传入block里面的逻辑是这样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[subscriber sendNext:RACTuplePack(value, change)];</span><br></pre></td></tr></table></figure>
<p>综上所述，RACObserver生成的signal在调用subscribeNext方法订阅该信号的时候，会直接调用一次订阅信号之后next block的逻辑，所以即便是属性变化之后订阅属性变化信号，它也会默认先调用一次next block的逻辑。</p>
<p>正常kvo检测转化成信号的逻辑：</p>
<p>在RACObserver初始化的过程中，</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)rac_observeKeyPath:(NSString *)keyPath options:(&#10;    NSKeyValueObservingOptions)options observer:(__weak NSObject *)&#10;    weakObserver block:(void (^)(id, NSDictionary *, BOOL, BOOL))block &#123;&#10; &#10;    NSCParameterAssert(block != nil);&#10; &#10;    NSCParameterAssert(keyPath.rac_keyPathComponents.count &#62; 0);&#10; &#10;    //&#30465;&#30053;&#25968;&#21313;&#34892;&#10; &#10;    NSKeyValueObservingOptions trampolineOptions = (options | &#10;        NSKeyValueObservingOptionPrior) &#38; ~NSKeyValueObservingOptionInitial;&#10; &#10;    RACKVOTrampoline *trampoline = [[RACKVOTrampoline alloc] initWithTarget:&#10;    self observer:strongObserver keyPath:keyPathHead options:trampolineOptions &#10;    block:^(id trampolineTarget, id trampolineObserver, NSDictionary *change) &#123;&#10; &#10;        // If this is a prior notification, clean up all the callbacks added to the&#10; &#10;        // previous value and call the callback block. Everything else is deferred&#10; &#10;        // until after we get the notification after the change.&#10; &#10;        if ([change[NSKeyValueChangeNotificationIsPriorKey] boolValue]) &#123;&#10; &#10;            [firstComponentDisposable() dispose];&#10; &#10;            if ((options &#38; NSKeyValueObservingOptionPrior) != 0) &#123;&#10; &#10;                block([trampolineTarget valueForKeyPath:keyPath], change, NO, &#10;                    keyPathHasOneComponent);&#10; &#10;            &#125;&#10;            return;&#10; &#10;        &#125;&#10; &#10;        // From here the notification is not prior.&#10; &#10;        NSObject *value = [trampolineTarget valueForKey:keyPathHead];&#10; &#10; &#10;        // If the value has changed but is nil, there is no need to add callbacks to&#10; &#10;        // it, just call the callback block.&#10; &#10;        if (value == nil) &#123;&#10;            block(nil, change, NO, keyPathHasOneComponent);&#10; &#10;            return;&#10;        &#125;&#10; &#10;        // From here the notification is not prior and the value is not nil.&#10; &#10; &#10;        // Create a new firstComponentDisposable while getting rid of the old one at&#10; &#10;        // the same time, in case this is being called concurrently.&#10; &#10;        RACDisposable *oldFirstComponentDisposable = [&#10;        firstComponentSerialDisposable swapInDisposable:[RACCompoundDisposable &#10;        compoundDisposable]];&#10; &#10;        [oldFirstComponentDisposable dispose];&#10; &#10;        addDeallocObserverToPropertyValue(value);&#10; &#10; &#10;        // If there are no further key path components, there is no need to add the&#10; &#10;        // other callbacks, just call the callback block with the value itself.&#10; &#10;        if (keyPathHasOneComponent) &#123;&#10; &#10;            block(value, change, NO, keyPathHasOneComponent);&#10; &#10;            return;&#10; &#10;        &#125;&#10; &#10;        // The value has changed, is not nil, and there are more key path components&#10; &#10;        // to consider. Add the callbacks to the value for the remaining key path&#10; &#10;        // components and call the callback block with the current value of the full&#10; &#10;        // key path.&#10; &#10;        addObserverToValue(value);&#10; &#10;        block([value valueForKeyPath:keyPathTail], change, NO, keyPathHasOneComponent);&#10; &#10;    &#125;];&#10; &#10;    // Stop the KVO observation when this one is disposed of.&#10; &#10;    [disposable addDisposable:trampoline];&#10;  &#10;    //&#30465;&#30053;&#25968;&#21313;&#34892;&#10; &#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在该方法中生成了一个RACKVOTrampoline中间对象，看它的源码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)initWithTarget:(__weak NSObject *)target observer:(__weak NSObject *)&#10;observer keyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)&#10;options block:(RACKVOBlock)block &#123;&#10; &#10;    NSCParameterAssert(keyPath != nil);&#10; &#10;    NSCParameterAssert(block != nil);&#10; &#10;    NSObject *strongTarget = target;&#10; &#10;    if (strongTarget == nil) return nil;&#10; &#10;    self = [super init];&#10; &#10;    if (self == nil) return nil;&#10;    _keyPath = [keyPath copy];&#10; &#10;    _block = [block copy];&#10; &#10;    _weakTarget = target;&#10; &#10;    _unsafeTarget = strongTarget;&#10; &#10;    _observer = observer;&#10; &#10;    [RACKVOProxy.sharedProxy addObserver:self forContext:(__bridge void *)self];&#10; &#10;    [strongTarget addObserver:RACKVOProxy.sharedProxy forKeyPath:self.keyPath &#10;    options:options context:(__bridge void *)self];&#10; &#10;    [strongTarget.rac_deallocDisposable addDisposable:self];&#10; &#10;    [self.observer.rac_deallocDisposable addDisposable:self];&#10;    return self;&#10;&#125;&#10; &#10;- (void)dealloc &#123;&#10; &#10;    [self dispose];&#10; &#10;&#125;&#10; &#10;#pragma mark Observation&#10; &#10;- (void)dispose &#123;&#10; &#10;    NSObject *target;&#10; &#10;    NSObject *observer;&#10; &#10;    @synchronized (self) &#123;&#10; &#10;        _block = nil;&#10; &#10; &#10;        // The target should still exist at this point, because we still need to&#10; &#10;        // tear down its KVO observation. Therefore, we can use the unsafe&#10; &#10;        // reference (and need to, because the weak one will have been zeroed by&#10; &#10;        // now).&#10; &#10;        target = self.unsafeTarget;&#10; &#10;        observer = self.observer;&#10; &#10; &#10; &#10; &#10;        _unsafeTarget = nil;&#10; &#10;        _observer = nil;&#10; &#10;    &#125;&#10; &#10;    [target.rac_deallocDisposable removeDisposable:self];&#10; &#10;    [observer.rac_deallocDisposable removeDisposable:self];&#10; &#10;    [target removeObserver:RACKVOProxy.sharedProxy forKeyPath:self.keyPath &#10;    context:(__bridge void *)self];&#10; &#10;    [RACKVOProxy.sharedProxy removeObserver:self forContext:(__bridge void *)self];&#10;&#125;&#10; &#10; &#10;//&#31995;&#32479;&#30340;&#20195;&#29702;&#26041;&#27861;&#65292;&#20854;&#23454;&#26159;&#30001;RACKVOProxy.sharedProxy&#23545;&#35937;&#36716;&#21457;&#30340;&#65292;RACKVOProxy.sharedProxy&#25165;&#26159;&#30495;&#27491;&#22788;&#29702;&#31995;&#32479;&#28040;&#24687;&#30340;&#23545;&#35937;&#12290;&#10;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(&#10;    NSDictionary *)change context:(void *)context &#123;&#10; &#10;    if (context != (__bridge void *)self) &#123;&#10; &#10;        [super observeValueForKeyPath:keyPath ofObject:object change:change &#10;        context:context];&#10; &#10;        return;&#10; &#10;    &#125;&#10; &#10;    RACKVOBlock block;&#10; &#10;    id observer;&#10; &#10;    id target;&#10; &#10;    @synchronized (self) &#123;&#10; &#10;        block = self.block;&#10; &#10;        observer = self.observer;&#10; &#10;        target = self.weakTarget;&#10; &#10;    &#125;&#10; &#10;    if (block == nil || target == nil) return;&#10; &#10;    block(target, observer, change);&#10; &#10;&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到RACKVOTrampoline对象替代原来使用KVO的对象，作为系统的代理，实现了代理方法。实际上，真正调用系统KVO注册的方法的时候，是往一个叫RACKVOProxy.sharedProxy的全局单例对象注册的。RACKVOTrampoline是具体处理KVO消息的对象，在RACKVOPorxy.shareProxy对象中注册了所有使用RAC KVO的系统消息，再由它转发给具体的RACKVOTrampoline进行处理，而在RACKVOTrampoline处理的时候，调用了RACKVOtrampoline初始化的时候传进来的block。之后在RACKVOTrampoline参数block调用过程中就会调用sendNext方法了，往外面发信号数据。</p>
<p>以下是RACKVOProxy.sharedProxy</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface RACKVOProxy()&#10; &#10;@property (strong, nonatomic, readonly) NSMapTable *trampolines;&#10; &#10;@property (strong, nonatomic, readonly) dispatch_queue_t queue;&#10; &#10; &#10;@end&#10; &#10;@implementation RACKVOProxy&#10; &#10; &#10;+ (instancetype)sharedProxy &#123;&#10; &#10;    static RACKVOProxy *proxy;&#10; &#10;    static dispatch_once_t onceToken;&#10; &#10; &#10; &#10; &#10;    dispatch_once(&#38;onceToken, ^&#123;&#10; &#10;        proxy = [[self alloc] init];&#10; &#10;    &#125;);&#10; &#10; &#10; &#10; &#10;    return proxy;&#10; &#10;&#125;&#10; &#10;- (instancetype)init &#123;&#10; &#10;    self = [super init];&#10; &#10;    if (self == nil) return nil;&#10; &#10; &#10; &#10; &#10;    _queue = dispatch_queue_create(&#34;org.reactivecocoa.ReactiveCocoa.RACKVOProxy&#10;    &#34;, DISPATCH_QUEUE_SERIAL);&#10; &#10;    _trampolines = [NSMapTable strongToWeakObjectsMapTable];&#10; &#10; &#10; &#10; &#10;    return self;&#10; &#10;&#125;&#10; &#10;- (void)addObserver:(__weak NSObject *)observer forContext:(void *)context &#123;&#10; &#10;    NSValue *valueContext = [NSValue valueWithPointer:context];&#10; &#10; &#10; &#10; &#10;    dispatch_sync(self.queue, ^&#123;&#10; &#10;        [self.trampolines setObject:observer forKey:valueContext];&#10; &#10;    &#125;);&#10; &#10;&#125;&#10; &#10;- (void)removeObserver:(NSObject *)observer forContext:(void *)context &#123;&#10; &#10;    NSValue *valueContext = [NSValue valueWithPointer:context];&#10; &#10; &#10; &#10; &#10;    dispatch_sync(self.queue, ^&#123;&#10; &#10;        [self.trampolines removeObjectForKey:valueContext];&#10; &#10;    &#125;);&#10; &#10;&#125;&#10; &#10;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(&#10;    NSDictionary *)change context:(void *)context &#123;&#10; &#10;    NSValue *valueContext = [NSValue valueWithPointer:context];&#10; &#10;    __block NSObject *trueObserver;&#10; &#10; &#10; &#10; &#10;    dispatch_sync(self.queue, ^&#123;&#10; &#10;        trueObserver = [self.trampolines objectForKey:valueContext];&#10; &#10;    &#125;);&#10; &#10; &#10; &#10;    if (trueObserver != nil) &#123;&#10; &#10;        [trueObserver observeValueForKeyPath:keyPath ofObject:object change:&#10;        change context:context];&#10; &#10;    &#125;&#10; &#10;&#125;</span><br></pre></td></tr></table></figure>
<p>RACKVOProxy.sharedProxy管理了整个RAC 中KVO的处理系统KVO消息的中间对象和系统KVO消息的转发。</p>
<p>综合上面的代码可以看出，正是由于各种中间对象替用户实现了代理方法起了代理对象的作用，用户才能把代码写的更加紧凑清晰。</p>
<h2 id="u95EE_u98982"><a href="#u95EE_u98982" class="headerlink" title="问题2"></a>问题2</h2><p>看以下代码，假设combineLatest之后得到的信号是A</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RACSignal combineLatest:@[[RACObserve(self, propertyA) ignore:nil], [&#10;RACObserve(self, propertyB) ignore:nil]]] subscribeNext:^(RACTuple *tuple) &#123;&#10; &#10; &#10;&#125;];</span><br></pre></td></tr></table></figure>
<p>1.使用combineLatest的时候，第一次订阅会不会触发subscribeNext后面的block</p>
<p>2.combineLatest中的信号，是同时调用了sendNext之后会触发A调用sendNext，还是只需要其中有一个信号调用了sendNext会触发A调用sendNext</p>
<p>看一下combineLatest源码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)combineLatest:(id&#60;NSFastEnumeration&#62;)signals &#123;&#10; &#10;    return [[self join:signals block:^(RACSignal *left, RACSignal *right) &#123;&#10; &#10;        return [left combineLatestWith:right];&#10; &#10;    &#125;] setNameWithFormat:@&#34;+combineLatest: %@&#34;, signals];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>继续 join: block:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)join:(id&#60;NSFastEnumeration&#62;)streams block:(RACStream * (^)(id, &#10;    id))block &#123;&#10; &#10; &#10;//&#31532;&#19968;&#27573;&#10;    RACStream *current = nil;&#10;    // Creates streams of successively larger tuples by combining the input&#10; &#10;    // streams one-by-one.&#10; &#10;    for (RACStream *stream in streams) &#123;&#10; &#10;        // For the first stream, just wrap its values in a RACTuple. That way,&#10; &#10;        // if only one stream is given, the result is still a stream of tuples.&#10; &#10;        if (current == nil) &#123;&#10; &#10;            current = [stream map:^(id x) &#123;&#10; &#10;                return RACTuplePack(x);&#10; &#10;            &#125;];&#10;            continue;&#10;        &#125;&#10; &#10;        current = block(current, stream);&#10; &#10;    &#125;&#10;    if (current == nil) return [self empty];&#10;//&#31532;&#20108;&#27573;&#10;    return [current map:^(RACTuple *xs) &#123;&#10; &#10;        // Right now, each value is contained in its own tuple, sorta like:&#10; &#10;        //&#10; &#10;        // (((1), 2), 3)&#10; &#10;        //&#10; &#10;        // We need to unwrap all the layers and create a tuple out of the result.&#10; &#10;        NSMutableArray *values = [[NSMutableArray alloc] init];&#10; &#10;        while (xs != nil) &#123;&#10;            [values insertObject:xs.last ?: RACTupleNil.tupleNil atIndex:0];&#10; &#10;            xs = (xs.count &#62; 1 ? xs.first : nil);&#10;        &#125;&#10; &#10;        return [RACTuple tupleWithObjectsFromArray:values];&#10;    &#125;];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这部分代码分2段，第一段是将两个信号合并的逻辑，具体的合并逻辑是由外面传进来的block确定的。第二段是通过map将信号的值重新做了处理，第一段得到的信号属于signal of signals的类型，第二段将它打平。</p>
<p>再看一下combineLatestWith:方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)combineLatestWith:(RACSignal *)signal &#123;&#10;    NSCParameterAssert(signal != nil);&#10; &#10;    return [[RACSignal createSignal:^(id&#60;RACSubscriber&#62; subscriber) &#123;&#10; &#10;        RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];&#10; &#10;        __block id lastSelfValue = nil;&#10; &#10;        __block BOOL selfCompleted = NO;&#10; &#10;        __block id lastOtherValue = nil;&#10; &#10;        __block BOOL otherCompleted = NO;&#10; &#10;        void (^sendNext)(void) = ^&#123;&#10; &#10;            @synchronized (disposable) &#123;&#10; &#10;                if (lastSelfValue == nil || lastOtherValue == nil) return;&#10; &#10;                [subscriber sendNext:RACTuplePack(lastSelfValue, lastOtherValue)];&#10; &#10;            &#125;&#10; &#10;        &#125;;&#10; &#10;        RACDisposable *selfDisposable = [self subscribeNext:^(id x) &#123;&#10; &#10;            @synchronized (disposable) &#123;&#10; &#10;                lastSelfValue = x ?: RACTupleNil.tupleNil;&#10; &#10;                sendNext();&#10; &#10;            &#125;&#10; &#10;        &#125; error:^(NSError *error) &#123;&#10; &#10;            [subscriber sendError:error];&#10; &#10;        &#125; completed:^&#123;&#10; &#10;            @synchronized (disposable) &#123;&#10; &#10;                selfCompleted = YES;&#10; &#10;                if (otherCompleted) [subscriber sendCompleted];&#10; &#10;            &#125;&#10; &#10;        &#125;];&#10; &#10;        [disposable addDisposable:selfDisposable];&#10; &#10;        RACDisposable *otherDisposable = [signal subscribeNext:^(id x) &#123;&#10; &#10;            @synchronized (disposable) &#123;&#10; &#10;                lastOtherValue = x ?: RACTupleNil.tupleNil;&#10; &#10;                sendNext();&#10; &#10;            &#125;&#10; &#10;        &#125; error:^(NSError *error) &#123;&#10; &#10;            [subscriber sendError:error];&#10; &#10;        &#125; completed:^&#123;&#10; &#10;            @synchronized (disposable) &#123;&#10; &#10;                otherCompleted = YES;&#10; &#10;                if (selfCompleted) [subscriber sendCompleted];&#10; &#10;            &#125;&#10; &#10;        &#125;];&#10; &#10;        [disposable addDisposable:otherDisposable];&#10;        return disposable;&#10; &#10;    &#125;] setNameWithFormat:@&#34;[%@] -combineLatestWith: %@&#34;, self.name, signal];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在以上代码中，调用了当前信号的subscribeNext方法，同时也调用了需要合并的信号的subscribeNext方法。subscribeNext方法block中调用了sendNext block，这个block是在combineLatestWith中定义，判断两个信号是否已经调用过sendNext，如果都同时掉用过sendNext就会触发combineLatest信号调用didSubscribe block，最终触发订阅combineLatest信号的传入的subscribeNext后的block。</p>
<p>综合上面的分析，类似于以下的使用方式</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RACSignal combineLatest:@[[RACObserve(self, propertyA) ignore:nil], [RACObserve(self, propertyB) ignore:nil]]] subscribeNext:^(RACTuple *tuple) &#123;&#10; &#10;&#125;];</span><br></pre></td></tr></table></figure>
<p>第一次订阅就会触发subscribeNext之后的block逻辑，并且是RACObserve这种类型的combineLatest才会，最上面已经分析了RACObserver生成的信号在第一次订阅调用的时候信号就会调用sendNext。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2016/01/25/ReactCocoa源码分析1/" data-id="cj528qvxd000pj7cv5w9ixn54" class="article-share-link">分享</a><div class="tags"><a href="/tags/源码分析/">源码分析</a></div><div class="post-nav"><a href="/2016/01/25/Runloop和多线程/" class="pre">Runloop和多线程</a><a href="/2016/01/25/MJRefresh/" class="next">MJRefresh</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Tech/">Tech</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/郑智文/">郑智文</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/源码分析/" style="font-size: 15px;">源码分析</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/07/13/Method Swizzle中的对象模型/">Method Swizzle中的对象模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/19/iOS定位库-INTULocationRequest/">iOS定位库-INTULocationRequest</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/13/AFNetWorking—NSURLSession/">AFNetWorking—NSURLSession</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/13/AFNetworking-NSURLConnection/">AFNetworking-NSURLConnection</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/13/AFNetworking-ResponseSerializer/">AFNetworking-ResponseSerializer</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/13/AFNetworking-RequestSerializer/">AFNetworking-RequestSerializer</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/26/CFRunLoop/">CFRunLoop</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/26/RunLoop介绍/">RunLoop介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/26/hexo-github搭建博客/">hexo+github搭建博客</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/25/Runloop和多线程/">Runloop和多线程</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">一只独来独往的水鸟.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>