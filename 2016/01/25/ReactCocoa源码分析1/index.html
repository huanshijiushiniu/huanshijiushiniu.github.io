<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="源码分析," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta name="description" content="问题1在看代码的时候，发现代码中使用到了
1- (void)viewDidload&amp;#10;&amp;#123;&amp;#10;    [super viewDidload];&amp;#10;    [self bindData];&amp;#10;&amp;#125;&amp;#10;  &amp;#10;- (void)bindData&amp;#10;&amp;#123;&amp;#10;    [[RACObserve(self, propertyA) ignor">
<meta property="og:type" content="article">
<meta property="og:title" content="ReactCocoa源码分析1">
<meta property="og:url" content="http://yoursite.com/2016/01/25/ReactCocoa源码分析1/index.html">
<meta property="og:site_name" content="郑智文">
<meta property="og:description" content="问题1在看代码的时候，发现代码中使用到了
1- (void)viewDidload&amp;#10;&amp;#123;&amp;#10;    [super viewDidload];&amp;#10;    [self bindData];&amp;#10;&amp;#125;&amp;#10;  &amp;#10;- (void)bindData&amp;#10;&amp;#123;&amp;#10;    [[RACObserve(self, propertyA) ignor">
<meta property="og:updated_time" content="2016-12-07T18:01:03.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ReactCocoa源码分析1">
<meta name="twitter:description" content="问题1在看代码的时候，发现代码中使用到了
1- (void)viewDidload&amp;#10;&amp;#123;&amp;#10;    [super viewDidload];&amp;#10;    [self bindData];&amp;#10;&amp;#125;&amp;#10;  &amp;#10;- (void)bindData&amp;#10;&amp;#123;&amp;#10;    [[RACObserve(self, propertyA) ignor">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/2016/01/25/ReactCocoa源码分析1/"/>


  <title> ReactCocoa源码分析1 | 郑智文 </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-CN">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">郑智文</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">iOS dev</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首頁
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            歸檔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            標籤
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                ReactCocoa源码分析1
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-01-25T16:38:24+08:00" content="2016-01-25">
              2016-01-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分類於</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/郑智文/" itemprop="url" rel="index">
                    <span itemprop="name">郑智文</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/01/25/ReactCocoa源码分析1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/25/ReactCocoa源码分析1/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="u95EE_u98981"><a href="#u95EE_u98981" class="headerlink" title="问题1"></a>问题1</h2><p>在看代码的时候，发现代码中使用到了</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidload&#10;&#123;&#10;    [super viewDidload];&#10;    [self bindData];&#10;&#125;&#10;  &#10;- (void)bindData&#10;&#123;&#10;    [[RACObserve(self, propertyA) ignore:nil] subscribeNext:^(NSArray *dataA) &#123;&#10;        NSLog(@&#34;use dataA&#34;);&#10;    &#125;];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>但是在这个类的propertyA是在init之后去设置的，在viewDidload之前。也就是在使用RAC订阅属性变化信号之前，但是use dataA打印出来了。猜测RACObserve宏生成信号在调用subscribeNext中，直接就调用了dataA的block的逻辑。但是感觉比较奇怪，不应该是propertyA变化的时候才会调用dataA的block的逻辑吗。</p>
<p>现在具体看一下，一个信号的创建和订阅的源码：</p>
<a id="more"></a> 
<h3 id="u4FE1_u53F7_u521B_u5EFA_uFF1A"><a href="#u4FE1_u53F7_u521B_u5EFA_uFF1A" class="headerlink" title="信号创建："></a>信号创建：</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)createSignal:(RACDisposable * (^)(id&#60;RACSubscriber&#62; subscriber))didSubscribe &#123;&#10; &#10;    return [RACDynamicSignal createSignal:didSubscribe];&#10; &#10;&#125;&#10;+ (RACSignal *)createSignal:(RACDisposable * (^)(id&#60;RACSubscriber&#62; subscriber))didSubscribe &#123;&#10; &#10;    RACDynamicSignal *signal = [[self alloc] init];&#10; &#10;    signal-&#62;_didSubscribe = [didSubscribe copy];&#10; &#10;    return [signal setNameWithFormat:@&#34;+createSignal:&#34;];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在创建一个信号的时候，会传进来一个叫didSubscribe的block，该信号会把它存下来。</p>
<h3 id="u4FE1_u53F7_u8BA2_u9605"><a href="#u4FE1_u53F7_u8BA2_u9605" class="headerlink" title="信号订阅"></a>信号订阅</h3><p>RACSignal的subscribeNext方法:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock &#123;&#10;    NSCParameterAssert(nextBlock != NULL);&#10;    RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:NULL completed:NULL];&#10;    return [self subscribe:o];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在singal的subscribeNext中，生成了一个subscriber。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)subscriberWithNext:(void (^)(id x))next error:(void (^)(NSError *error))error completed:(void (^)(void))completed &#123;&#10; &#10;    RACSubscriber *subscriber = [[self alloc] init];&#10; &#10; &#10;    subscriber-&#62;_next = [next copy];&#10; &#10;    subscriber-&#62;_error = [error copy];&#10; &#10;    subscriber-&#62;_completed = [completed copy];&#10; &#10;    return subscriber;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>subscriber保存了nextBlock，errorBlock，completedBlock等数据信息</p>
<p>接着看signal的subscribe方法，改方法的参数是subscribeNext方法中生成的subscriber对象</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribe:(id&#60;RACSubscriber&#62;)subscriber &#123;&#10; &#10;    NSCParameterAssert(subscriber != nil);&#10; &#10;    RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];&#10; &#10;    subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable];&#10; &#10; &#10;    if (self.didSubscribe != NULL) &#123;&#10; &#10;        RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123;&#10; &#10;            RACDisposable *innerDisposable = self.didSubscribe(subscriber);&#10; &#10;            [disposable addDisposable:innerDisposable];&#10; &#10;        &#125;];&#10; &#10; &#10;        [disposable addDisposable:schedulingDisposable];&#10; &#10;    &#125;&#10; &#10;    return disposable;&#10; &#10;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)schedule:(void (^)(void))block &#123;&#10;    NSCParameterAssert(block != NULL);&#10; &#10;    if (RACScheduler.currentScheduler == nil) return [self.backgroundScheduler schedule:block];&#10; &#10;    block();&#10; &#10;    return nil;&#10; &#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在signal的subscribe方法中，调用了RACScheduler.subscriptionScheduler schedule 方法，直接就将传入的block调用了，最终调用了signal的didSubscribe block，将subscriber传入。</p>
<p>再看一下RACObserve在生成一个signal的时候，传入的didSubscribe block逻辑的怎样的，以下是RACObserve相关源码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define RACObserve(TARGET, KEYPATH) \&#10; &#10;    (&#123; \&#10; &#10;        _Pragma(&#34;clang diagnostic push&#34;) \&#10; &#10;        _Pragma(&#34;clang diagnostic ignored \&#34;-Wreceiver-is-weak\&#34;&#34;) \&#10; &#10;        __weak id target_ = (TARGET); \&#10; &#10;        [target_ rac_valuesForKeyPath:@keypath(TARGET, KEYPATH) observer:self]; \&#10; &#10;        _Pragma(&#34;clang diagnostic pop&#34;) \&#10; &#10;    &#125;)</span><br></pre></td></tr></table></figure>
<p>在NSObject的RACPropertySubscribing分类中定义rac_valuesForKeyPath:observer:self:方法</p>
<p>继续：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)rac_valuesForKeyPath:(NSString *)keyPath observer:(__weak NSObject *)observer &#123;&#10; &#10;    return [[[self&#10; &#10;        rac_valuesAndChangesForKeyPath:keyPath options:NSKeyValueObservingOptionInitial observer:observer]&#10; &#10;        map:^(RACTuple *value) &#123;&#10; &#10;            // -map: because it doesn&#39;t require the block trampoline that -reduceEach: uses&#10; &#10;            return value[0];&#10; &#10;        &#125;]&#10; &#10;        setNameWithFormat:@&#34;RACObserve(%@, %@)&#34;, self.rac_description, keyPath];&#10; &#10;&#125;</span><br></pre></td></tr></table></figure>
<p>继续：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)rac_valuesAndChangesForKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options observer:(__weak NSObject *)weakObserver &#123;&#10; &#10;    NSObject *strongObserver = weakObserver;&#10; &#10;    keyPath = [keyPath copy];&#10; &#10;    NSRecursiveLock *objectLock = [[NSRecursiveLock alloc] init];&#10; &#10;    objectLock.name = @&#34;org.reactivecocoa.ReactiveCocoa.NSObjectRACPropertySubscribing&#34;;&#10; &#10;    __weak NSObject *weakSelf = self;&#10; &#10;    RACSignal *deallocSignal = [[RACSignal&#10; &#10;        zip:@[&#10; &#10;            self.rac_willDeallocSignal,&#10; &#10;            strongObserver.rac_willDeallocSignal ?: [RACSignal never]&#10; &#10;        ]]&#10; &#10;        doCompleted:^&#123;&#10; &#10;            // Forces deallocation to wait if the object variables are currently&#10; &#10;            // being read on another thread.&#10; &#10;            [objectLock lock];&#10; &#10;            @onExit &#123;&#10; &#10;                [objectLock unlock];&#10; &#10;            &#125;;&#10; &#10;        &#125;];&#10; &#10;//&#37325;&#28857;&#20851;&#27880;&#36825;&#37324;&#65292;createSignal&#20043;&#21518;&#30340;&#21442;&#25968;&#23601;&#26159;&#35813;&#20449;&#21495;&#30340;didSubscribe block&#36923;&#36753;&#20102;&#12290;&#10;    return [[[RACSignal&#10; &#10;        createSignal:^ RACDisposable * (id&#60;RACSubscriber&#62; subscriber) &#123;&#10; &#10;            // Hold onto the lock the whole time we&#39;re setting up the KVO&#10; &#10;            // observation, because any resurrection that might be caused by our&#10; &#10;            // retaining below must be balanced out by the time -dealloc returns&#10; &#10;            // (if another thread is waiting on the lock above).&#10; &#10;            [objectLock lock];&#10; &#10;            @onExit &#123;&#10; &#10;                [objectLock unlock];&#10; &#10;            &#125;;&#10; &#10;            __strong NSObject *observer __attribute__((objc_precise_lifetime)) = weakObserver;&#10; &#10;            __strong NSObject *self __attribute__((objc_precise_lifetime)) = weakSelf;&#10; &#10;            if (self == nil) &#123;&#10; &#10;                [subscriber sendCompleted];&#10; &#10;                return nil;&#10; &#10;            &#125;&#10; &#10; &#10;            return [self rac_observeKeyPath:keyPath options:options observer:observer block:^(id value, NSDictionary *change, BOOL causedByDealloc, BOOL affectedOnlyLastComponent) &#123;&#10; &#10;                [subscriber sendNext:RACTuplePack(value, change)];&#10; &#10;            &#125;];&#10; &#10;        &#125;]&#10; &#10;        takeUntil:deallocSignal]&#10; &#10;        setNameWithFormat:@&#34;%@ -rac_valueAndChangesForKeyPath: %@ options: %lu observer: %@&#34;, self.rac_description, keyPath, (unsigned long)options, strongObserver.rac_description];&#10; &#10;&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在RACObserver宏定义的signal的didSubscriber block中又调用了rac_observeKeyPath:keyPath options: observer: block</p>
<p>继续(太长了只贴重点)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)rac_observeKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options observer:(__weak NSObject *)weakObserver block:(void (^)(id, NSDictionary *, BOOL, BOOL))block &#123;&#10; &#10;    NSCParameterAssert(block != nil);&#10; &#10;    NSCParameterAssert(keyPath.rac_keyPathComponents.count &#62; 0);&#10; &#10;    //&#30465;&#30053;&#25968;&#21313;&#34892;&#10;    // Call the block with the initial value if needed.&#10; &#10;    if ((options &#38; NSKeyValueObservingOptionInitial) != 0) &#123;&#10; &#10;        id initialValue = [self valueForKeyPath:keyPath];&#10; &#10;        NSDictionary *initialChange = @&#123;&#10; &#10;            NSKeyValueChangeKindKey: @(NSKeyValueChangeSetting),&#10; &#10;            NSKeyValueChangeNewKey: initialValue ?: NSNull.null,&#10; &#10;        &#125;;&#10; &#10;        block(initialValue, initialChange, NO, keyPathHasOneComponent);&#10; &#10;    &#125;&#10;     &#10;    //&#30465;&#30053;&#25968;&#21313;&#34892;&#10; &#10;&#125;</span><br></pre></td></tr></table></figure>
<p>说明一下，options是NSKeyValueObservingOptions属于NS_OPTIONS</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, NSKeyValueObservingOptions) &#123;&#10; &#10;    NSKeyValueObservingOptionNew = 0x01,&#10; &#10;    NSKeyValueObservingOptionOld = 0x02,&#10; &#10;    NSKeyValueObservingOptionInitial NS_ENUM_AVAILABLE(10_5, 2_0) = 0x04,&#10; &#10;    NSKeyValueObservingOptionPrior NS_ENUM_AVAILABLE(10_5, 2_0) = 0x08&#10;&#125;;</span><br></pre></td></tr></table></figure>
<p>在以上方法中，它判断了，传入的options是否是NSKeyValueObservingOptionInitial类型，而在调用rac_observeKeyPath: options: observer: block:的时候，option就是传的NSKeyValueObservingOptionInitial，所以会直接调用传进来的block，在rac_valuesAndChangesForKeyPath: options: observer:中调用rac_observeKeyPath: options: observer: block:的时候传入block里面的逻辑是这样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[subscriber sendNext:RACTuplePack(value, change)];</span><br></pre></td></tr></table></figure>
<p>综上所述，RACObserver生成的signal在调用subscribeNext方法订阅该信号的时候，会直接调用一次订阅信号之后next block的逻辑，所以即便是属性变化之后订阅属性变化信号，它也会默认先调用一次next block的逻辑。</p>
<p>正常kvo检测转化成信号的逻辑：</p>
<p>在RACObserver初始化的过程中，</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)rac_observeKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options observer:(__weak NSObject *)weakObserver block:(void (^)(id, NSDictionary *, BOOL, BOOL))block &#123;&#10; &#10;    NSCParameterAssert(block != nil);&#10; &#10;    NSCParameterAssert(keyPath.rac_keyPathComponents.count &#62; 0);&#10; &#10;    //&#30465;&#30053;&#25968;&#21313;&#34892;&#10; &#10;    NSKeyValueObservingOptions trampolineOptions = (options | NSKeyValueObservingOptionPrior) &#38; ~NSKeyValueObservingOptionInitial;&#10; &#10;    RACKVOTrampoline *trampoline = [[RACKVOTrampoline alloc] initWithTarget:self observer:strongObserver keyPath:keyPathHead options:trampolineOptions block:^(id trampolineTarget, id trampolineObserver, NSDictionary *change) &#123;&#10; &#10;        // If this is a prior notification, clean up all the callbacks added to the&#10; &#10;        // previous value and call the callback block. Everything else is deferred&#10; &#10;        // until after we get the notification after the change.&#10; &#10;        if ([change[NSKeyValueChangeNotificationIsPriorKey] boolValue]) &#123;&#10; &#10;            [firstComponentDisposable() dispose];&#10; &#10;            if ((options &#38; NSKeyValueObservingOptionPrior) != 0) &#123;&#10; &#10;                block([trampolineTarget valueForKeyPath:keyPath], change, NO, keyPathHasOneComponent);&#10; &#10;            &#125;&#10;            return;&#10; &#10;        &#125;&#10; &#10;        // From here the notification is not prior.&#10; &#10;        NSObject *value = [trampolineTarget valueForKey:keyPathHead];&#10; &#10; &#10;        // If the value has changed but is nil, there is no need to add callbacks to&#10; &#10;        // it, just call the callback block.&#10; &#10;        if (value == nil) &#123;&#10;            block(nil, change, NO, keyPathHasOneComponent);&#10; &#10;            return;&#10;        &#125;&#10; &#10;        // From here the notification is not prior and the value is not nil.&#10; &#10; &#10;        // Create a new firstComponentDisposable while getting rid of the old one at&#10; &#10;        // the same time, in case this is being called concurrently.&#10; &#10;        RACDisposable *oldFirstComponentDisposable = [firstComponentSerialDisposable swapInDisposable:[RACCompoundDisposable compoundDisposable]];&#10; &#10;        [oldFirstComponentDisposable dispose];&#10; &#10;        addDeallocObserverToPropertyValue(value);&#10; &#10; &#10;        // If there are no further key path components, there is no need to add the&#10; &#10;        // other callbacks, just call the callback block with the value itself.&#10; &#10;        if (keyPathHasOneComponent) &#123;&#10; &#10;            block(value, change, NO, keyPathHasOneComponent);&#10; &#10;            return;&#10; &#10;        &#125;&#10; &#10;        // The value has changed, is not nil, and there are more key path components&#10; &#10;        // to consider. Add the callbacks to the value for the remaining key path&#10; &#10;        // components and call the callback block with the current value of the full&#10; &#10;        // key path.&#10; &#10;        addObserverToValue(value);&#10; &#10;        block([value valueForKeyPath:keyPathTail], change, NO, keyPathHasOneComponent);&#10; &#10;    &#125;];&#10; &#10;    // Stop the KVO observation when this one is disposed of.&#10; &#10;    [disposable addDisposable:trampoline];&#10;  &#10;    //&#30465;&#30053;&#25968;&#21313;&#34892;&#10; &#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在该方法中生成了一个RACKVOTrampoline中间对象，看它的源码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)initWithTarget:(__weak NSObject *)target observer:(__weak NSObject *)observer keyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options block:(RACKVOBlock)block &#123;&#10; &#10;    NSCParameterAssert(keyPath != nil);&#10; &#10;    NSCParameterAssert(block != nil);&#10; &#10;    NSObject *strongTarget = target;&#10; &#10;    if (strongTarget == nil) return nil;&#10; &#10;    self = [super init];&#10; &#10;    if (self == nil) return nil;&#10;    _keyPath = [keyPath copy];&#10; &#10;    _block = [block copy];&#10; &#10;    _weakTarget = target;&#10; &#10;    _unsafeTarget = strongTarget;&#10; &#10;    _observer = observer;&#10; &#10;    [RACKVOProxy.sharedProxy addObserver:self forContext:(__bridge void *)self];&#10; &#10;    [strongTarget addObserver:RACKVOProxy.sharedProxy forKeyPath:self.keyPath options:options context:(__bridge void *)self];&#10; &#10;    [strongTarget.rac_deallocDisposable addDisposable:self];&#10; &#10;    [self.observer.rac_deallocDisposable addDisposable:self];&#10;    return self;&#10;&#125;&#10; &#10;- (void)dealloc &#123;&#10; &#10;    [self dispose];&#10; &#10;&#125;&#10; &#10;#pragma mark Observation&#10; &#10;- (void)dispose &#123;&#10; &#10;    NSObject *target;&#10; &#10;    NSObject *observer;&#10; &#10;    @synchronized (self) &#123;&#10; &#10;        _block = nil;&#10; &#10; &#10;        // The target should still exist at this point, because we still need to&#10; &#10;        // tear down its KVO observation. Therefore, we can use the unsafe&#10; &#10;        // reference (and need to, because the weak one will have been zeroed by&#10; &#10;        // now).&#10; &#10;        target = self.unsafeTarget;&#10; &#10;        observer = self.observer;&#10; &#10; &#10; &#10; &#10;        _unsafeTarget = nil;&#10; &#10;        _observer = nil;&#10; &#10;    &#125;&#10; &#10;    [target.rac_deallocDisposable removeDisposable:self];&#10; &#10;    [observer.rac_deallocDisposable removeDisposable:self];&#10; &#10;    [target removeObserver:RACKVOProxy.sharedProxy forKeyPath:self.keyPath context:(__bridge void *)self];&#10; &#10;    [RACKVOProxy.sharedProxy removeObserver:self forContext:(__bridge void *)self];&#10;&#125;&#10; &#10; &#10;//&#31995;&#32479;&#30340;&#20195;&#29702;&#26041;&#27861;&#65292;&#20854;&#23454;&#26159;&#30001;RACKVOProxy.sharedProxy&#23545;&#35937;&#36716;&#21457;&#30340;&#65292;RACKVOProxy.sharedProxy&#25165;&#26159;&#30495;&#27491;&#22788;&#29702;&#31995;&#32479;&#28040;&#24687;&#30340;&#23545;&#35937;&#12290;&#10;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context &#123;&#10; &#10;    if (context != (__bridge void *)self) &#123;&#10; &#10;        [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];&#10; &#10;        return;&#10; &#10;    &#125;&#10; &#10;    RACKVOBlock block;&#10; &#10;    id observer;&#10; &#10;    id target;&#10; &#10;    @synchronized (self) &#123;&#10; &#10;        block = self.block;&#10; &#10;        observer = self.observer;&#10; &#10;        target = self.weakTarget;&#10; &#10;    &#125;&#10; &#10;    if (block == nil || target == nil) return;&#10; &#10;    block(target, observer, change);&#10; &#10;&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到RACKVOTrampoline对象替代原来使用KVO的对象，作为系统的代理，实现了代理方法。实际上，真正调用系统KVO注册的方法的时候，是往一个叫RACKVOProxy.sharedProxy的全局单例对象注册的。RACKVOTrampoline是具体处理KVO消息的对象，在RACKVOPorxy.shareProxy对象中注册了所有使用RAC KVO的系统消息，再由它转发给具体的RACKVOTrampoline进行处理，而在RACKVOTrampoline处理的时候，调用了RACKVOtrampoline初始化的时候传进来的block。之后在RACKVOTrampoline参数block调用过程中就会调用sendNext方法了，往外面发信号数据。</p>
<p>以下是RACKVOProxy.sharedProxy</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface RACKVOProxy()&#10; &#10;@property (strong, nonatomic, readonly) NSMapTable *trampolines;&#10; &#10;@property (strong, nonatomic, readonly) dispatch_queue_t queue;&#10; &#10; &#10;@end&#10; &#10;@implementation RACKVOProxy&#10; &#10; &#10;+ (instancetype)sharedProxy &#123;&#10; &#10;    static RACKVOProxy *proxy;&#10; &#10;    static dispatch_once_t onceToken;&#10; &#10; &#10; &#10; &#10;    dispatch_once(&#38;onceToken, ^&#123;&#10; &#10;        proxy = [[self alloc] init];&#10; &#10;    &#125;);&#10; &#10; &#10; &#10; &#10;    return proxy;&#10; &#10;&#125;&#10; &#10;- (instancetype)init &#123;&#10; &#10;    self = [super init];&#10; &#10;    if (self == nil) return nil;&#10; &#10; &#10; &#10; &#10;    _queue = dispatch_queue_create(&#34;org.reactivecocoa.ReactiveCocoa.RACKVOProxy&#34;, DISPATCH_QUEUE_SERIAL);&#10; &#10;    _trampolines = [NSMapTable strongToWeakObjectsMapTable];&#10; &#10; &#10; &#10; &#10;    return self;&#10; &#10;&#125;&#10; &#10;- (void)addObserver:(__weak NSObject *)observer forContext:(void *)context &#123;&#10; &#10;    NSValue *valueContext = [NSValue valueWithPointer:context];&#10; &#10; &#10; &#10; &#10;    dispatch_sync(self.queue, ^&#123;&#10; &#10;        [self.trampolines setObject:observer forKey:valueContext];&#10; &#10;    &#125;);&#10; &#10;&#125;&#10; &#10;- (void)removeObserver:(NSObject *)observer forContext:(void *)context &#123;&#10; &#10;    NSValue *valueContext = [NSValue valueWithPointer:context];&#10; &#10; &#10; &#10; &#10;    dispatch_sync(self.queue, ^&#123;&#10; &#10;        [self.trampolines removeObjectForKey:valueContext];&#10; &#10;    &#125;);&#10; &#10;&#125;&#10; &#10;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context &#123;&#10; &#10;    NSValue *valueContext = [NSValue valueWithPointer:context];&#10; &#10;    __block NSObject *trueObserver;&#10; &#10; &#10; &#10; &#10;    dispatch_sync(self.queue, ^&#123;&#10; &#10;        trueObserver = [self.trampolines objectForKey:valueContext];&#10; &#10;    &#125;);&#10; &#10; &#10; &#10;    if (trueObserver != nil) &#123;&#10; &#10;        [trueObserver observeValueForKeyPath:keyPath ofObject:object change:change context:context];&#10; &#10;    &#125;&#10; &#10;&#125;</span><br></pre></td></tr></table></figure>
<p>RACKVOProxy.sharedProxy管理了整个RAC 中KVO的处理系统KVO消息的中间对象和系统KVO消息的转发。</p>
<p>综合上面的代码可以看出，正是由于各种中间对象替用户实现了代理方法起了代理对象的作用，用户才能把代码写的更加紧凑清晰。</p>
<h2 id="u95EE_u98982"><a href="#u95EE_u98982" class="headerlink" title="问题2"></a>问题2</h2><p>看以下代码，假设combineLatest之后得到的信号是A</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RACSignal combineLatest:@[[RACObserve(self, propertyA) ignore:nil], [RACObserve(self, propertyB) ignore:nil]]] subscribeNext:^(RACTuple *tuple) &#123;&#10; &#10; &#10;&#125;];</span><br></pre></td></tr></table></figure>
<p>1.使用combineLatest的时候，第一次订阅会不会触发subscribeNext后面的block</p>
<p>2.combineLatest中的信号，是同时调用了sendNext之后会触发A调用sendNext，还是只需要其中有一个信号调用了sendNext会触发A调用sendNext</p>
<p>看一下combineLatest源码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)combineLatest:(id&#60;NSFastEnumeration&#62;)signals &#123;&#10; &#10;    return [[self join:signals block:^(RACSignal *left, RACSignal *right) &#123;&#10; &#10;        return [left combineLatestWith:right];&#10; &#10;    &#125;] setNameWithFormat:@&#34;+combineLatest: %@&#34;, signals];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>继续 join: block:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)join:(id&#60;NSFastEnumeration&#62;)streams block:(RACStream * (^)(id, id))block &#123;&#10; &#10; &#10;//&#31532;&#19968;&#27573;&#10;    RACStream *current = nil;&#10;    // Creates streams of successively larger tuples by combining the input&#10; &#10;    // streams one-by-one.&#10; &#10;    for (RACStream *stream in streams) &#123;&#10; &#10;        // For the first stream, just wrap its values in a RACTuple. That way,&#10; &#10;        // if only one stream is given, the result is still a stream of tuples.&#10; &#10;        if (current == nil) &#123;&#10; &#10;            current = [stream map:^(id x) &#123;&#10; &#10;                return RACTuplePack(x);&#10; &#10;            &#125;];&#10;            continue;&#10;        &#125;&#10; &#10;        current = block(current, stream);&#10; &#10;    &#125;&#10;    if (current == nil) return [self empty];&#10;//&#31532;&#20108;&#27573;&#10;    return [current map:^(RACTuple *xs) &#123;&#10; &#10;        // Right now, each value is contained in its own tuple, sorta like:&#10; &#10;        //&#10; &#10;        // (((1), 2), 3)&#10; &#10;        //&#10; &#10;        // We need to unwrap all the layers and create a tuple out of the result.&#10; &#10;        NSMutableArray *values = [[NSMutableArray alloc] init];&#10; &#10;        while (xs != nil) &#123;&#10;            [values insertObject:xs.last ?: RACTupleNil.tupleNil atIndex:0];&#10; &#10;            xs = (xs.count &#62; 1 ? xs.first : nil);&#10;        &#125;&#10; &#10;        return [RACTuple tupleWithObjectsFromArray:values];&#10;    &#125;];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这部分代码分2段，第一段是将两个信号合并的逻辑，具体的合并逻辑是由外面传进来的block确定的。第二段是通过map将信号的值重新做了处理，第一段得到的信号属于signal of signals的类型，第二段将它打平。</p>
<p>再看一下combineLatestWith:方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)combineLatestWith:(RACSignal *)signal &#123;&#10;    NSCParameterAssert(signal != nil);&#10; &#10;    return [[RACSignal createSignal:^(id&#60;RACSubscriber&#62; subscriber) &#123;&#10; &#10;        RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];&#10; &#10;        __block id lastSelfValue = nil;&#10; &#10;        __block BOOL selfCompleted = NO;&#10; &#10;        __block id lastOtherValue = nil;&#10; &#10;        __block BOOL otherCompleted = NO;&#10; &#10;        void (^sendNext)(void) = ^&#123;&#10; &#10;            @synchronized (disposable) &#123;&#10; &#10;                if (lastSelfValue == nil || lastOtherValue == nil) return;&#10; &#10;                [subscriber sendNext:RACTuplePack(lastSelfValue, lastOtherValue)];&#10; &#10;            &#125;&#10; &#10;        &#125;;&#10; &#10;        RACDisposable *selfDisposable = [self subscribeNext:^(id x) &#123;&#10; &#10;            @synchronized (disposable) &#123;&#10; &#10;                lastSelfValue = x ?: RACTupleNil.tupleNil;&#10; &#10;                sendNext();&#10; &#10;            &#125;&#10; &#10;        &#125; error:^(NSError *error) &#123;&#10; &#10;            [subscriber sendError:error];&#10; &#10;        &#125; completed:^&#123;&#10; &#10;            @synchronized (disposable) &#123;&#10; &#10;                selfCompleted = YES;&#10; &#10;                if (otherCompleted) [subscriber sendCompleted];&#10; &#10;            &#125;&#10; &#10;        &#125;];&#10; &#10;        [disposable addDisposable:selfDisposable];&#10; &#10;        RACDisposable *otherDisposable = [signal subscribeNext:^(id x) &#123;&#10; &#10;            @synchronized (disposable) &#123;&#10; &#10;                lastOtherValue = x ?: RACTupleNil.tupleNil;&#10; &#10;                sendNext();&#10; &#10;            &#125;&#10; &#10;        &#125; error:^(NSError *error) &#123;&#10; &#10;            [subscriber sendError:error];&#10; &#10;        &#125; completed:^&#123;&#10; &#10;            @synchronized (disposable) &#123;&#10; &#10;                otherCompleted = YES;&#10; &#10;                if (selfCompleted) [subscriber sendCompleted];&#10; &#10;            &#125;&#10; &#10;        &#125;];&#10; &#10;        [disposable addDisposable:otherDisposable];&#10;        return disposable;&#10; &#10;    &#125;] setNameWithFormat:@&#34;[%@] -combineLatestWith: %@&#34;, self.name, signal];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>在以上代码中，调用了当前信号的subscribeNext方法，同时也调用了需要合并的信号的subscribeNext方法。subscribeNext方法block中调用了sendNext block，这个block是在combineLatestWith中定义，判断两个信号是否已经调用过sendNext，如果都同时掉用过sendNext就会触发combineLatest信号调用didSubscribe block，最终触发订阅combineLatest信号的传入的subscribeNext后的block。</p>
<p>综合上面的分析，类似于以下的使用方式</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RACSignal combineLatest:@[[RACObserve(self, propertyA) ignore:nil], [RACObserve(self, propertyB) ignore:nil]]] subscribeNext:^(RACTuple *tuple) &#123;&#10; &#10;&#125;];</span><br></pre></td></tr></table></figure>
<p>第一次订阅就会触发subscribeNext之后的block逻辑，并且是RACObserve这种类型的combineLatest才会，最上面已经分析了RACObserver生成的信号在第一次订阅调用的时候信号就会调用sendNext。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/源码分析/" rel="tag">#源码分析</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/01/25/MLLeaksFinder源码分析/" rel="next" title="MLLeaksFinder源码分析">
                <i class="fa fa-chevron-left"></i> MLLeaksFinder源码分析
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/01/25/ReactiveCocoa1/" rel="prev" title="ReactiveCocoa1">
                ReactiveCocoa1 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/01/25/ReactCocoa源码分析1/"
           data-title="ReactCocoa源码分析1" data-url="http://yoursite.com/2016/01/25/ReactCocoa源码分析1/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目錄
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            本站概覽
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://7xqgnx.com1.z0.glb.clouddn.com/Red.jpg"
               alt="郑智文" />
          <p class="site-author-name" itemprop="name">郑智文</p>
          <p class="site-description motion-element" itemprop="description">车到山前必有路</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">19</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分類</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">標籤</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#u95EE_u98981"><span class="nav-number">1.</span> <span class="nav-text">问题1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u4FE1_u53F7_u521B_u5EFA_uFF1A"><span class="nav-number">1.1.</span> <span class="nav-text">信号创建：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4FE1_u53F7_u8BA2_u9605"><span class="nav-number">1.2.</span> <span class="nav-text">信号订阅</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#u95EE_u98982"><span class="nav-number">2.</span> <span class="nav-text">问题2</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">郑智文</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"zhengzhiwen"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
