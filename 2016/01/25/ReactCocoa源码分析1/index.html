<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="博客"><title>ReactCocoa源码分析1 | 一只独来独往的水鸟</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">ReactCocoa源码分析1</h1><a id="logo" href="/.">一只独来独往的水鸟</a><p class="description">iOS</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">ReactCocoa源码分析1</h1><div class="post-meta">Jan 25, 2016<span> | </span><span class="category"><a href="/categories/Tech/">Tech</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h2 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h2><p>在看代码的时候，发现代码中使用到了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidload</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidload];</span><br><span class="line">    [self bindData];</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">- (void)bindData</span><br><span class="line">&#123;</span><br><span class="line">    [[RACObserve(self, propertyA) ignore:nil] </span><br><span class="line">                                 subscribeNext:^(NSArray *dataA) &#123;</span><br><span class="line">        NSLog(@&quot;use dataA&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在这个类的propertyA是在init之后去设置的，在viewDidload之前。也就是在使用RAC订阅属性变化信号之前，但是use dataA打印出来了。猜测RACObserve宏生成信号在调用subscribeNext中，直接就调用了dataA的block的逻辑。但是感觉比较奇怪，不应该是propertyA变化的时候才会调用dataA的block的逻辑吗。</p>
<p>现在具体看一下，一个信号的创建和订阅的源码：</p>
<a id="more"></a> 
<h3 id="信号创建："><a href="#信号创建：" class="headerlink" title="信号创建："></a>信号创建：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))</span><br><span class="line">didSubscribe &#123;</span><br><span class="line"> </span><br><span class="line">    return [RACDynamicSignal createSignal:didSubscribe];</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">+ (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))</span><br><span class="line">didSubscribe &#123;</span><br><span class="line"> </span><br><span class="line">    RACDynamicSignal *signal = [[self alloc] init];</span><br><span class="line"> </span><br><span class="line">    signal-&gt;_didSubscribe = [didSubscribe copy];</span><br><span class="line"> </span><br><span class="line">    return [signal setNameWithFormat:@&quot;+createSignal:&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在创建一个信号的时候，会传进来一个叫didSubscribe的block，该信号会把它存下来。</p>
<h3 id="信号订阅"><a href="#信号订阅" class="headerlink" title="信号订阅"></a>信号订阅</h3><p>RACSignal的subscribeNext方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock &#123;</span><br><span class="line">    NSCParameterAssert(nextBlock != NULL);</span><br><span class="line">    RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:NULL completed:NULL];</span><br><span class="line">    return [self subscribe:o];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在singal的subscribeNext中，生成了一个subscriber。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)subscriberWithNext:(void (^)(id x))next error:(void (^)(NSError</span><br><span class="line"> *error))error completed:(void (^)(void))completed &#123;</span><br><span class="line"> </span><br><span class="line">    RACSubscriber *subscriber = [[self alloc] init];</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    subscriber-&gt;_next = [next copy];</span><br><span class="line"> </span><br><span class="line">    subscriber-&gt;_error = [error copy];</span><br><span class="line"> </span><br><span class="line">    subscriber-&gt;_completed = [completed copy];</span><br><span class="line"> </span><br><span class="line">    return subscriber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>subscriber保存了nextBlock，errorBlock，completedBlock等数据信息</p>
<p>接着看signal的subscribe方法，改方法的参数是subscribeNext方法中生成的subscriber对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line"> </span><br><span class="line">    NSCParameterAssert(subscriber != nil);</span><br><span class="line"> </span><br><span class="line">    RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"> </span><br><span class="line">    subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable];</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    if (self.didSubscribe != NULL) &#123;</span><br><span class="line"> </span><br><span class="line">        RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123;</span><br><span class="line"> </span><br><span class="line">            RACDisposable *innerDisposable = self.didSubscribe(subscriber);</span><br><span class="line"> </span><br><span class="line">            [disposable addDisposable:innerDisposable];</span><br><span class="line"> </span><br><span class="line">        &#125;];</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        [disposable addDisposable:schedulingDisposable];</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return disposable;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)schedule:(void (^)(void))block &#123;</span><br><span class="line">    NSCParameterAssert(block != NULL);</span><br><span class="line"> </span><br><span class="line">    if (RACScheduler.currentScheduler == nil) return [self.backgroundScheduler schedule:block];</span><br><span class="line"> </span><br><span class="line">    block();</span><br><span class="line"> </span><br><span class="line">    return nil;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在signal的subscribe方法中，调用了RACScheduler.subscriptionScheduler schedule 方法，直接就将传入的block调用了，最终调用了signal的didSubscribe block，将subscriber传入。</p>
<p>再看一下RACObserve在生成一个signal的时候，传入的didSubscribe block逻辑的怎样的，以下是RACObserve相关源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#define RACObserve(TARGET, KEYPATH) \</span><br><span class="line"> </span><br><span class="line">    (&#123; \</span><br><span class="line"> </span><br><span class="line">        _Pragma(&quot;clang diagnostic push&quot;) \</span><br><span class="line"> </span><br><span class="line">        _Pragma(&quot;clang diagnostic ignored \&quot;-Wreceiver-is-weak\&quot;&quot;) \</span><br><span class="line"> </span><br><span class="line">        __weak id target_ = (TARGET); \</span><br><span class="line"> </span><br><span class="line">        [target_ rac_valuesForKeyPath:@keypath(TARGET, KEYPATH) observer:self];</span><br><span class="line">         \</span><br><span class="line"> </span><br><span class="line">        _Pragma(&quot;clang diagnostic pop&quot;) \</span><br><span class="line"> </span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>在NSObject的RACPropertySubscribing分类中定义rac_valuesForKeyPath:observer:self:方法</p>
<p>继续：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)rac_valuesForKeyPath:(NSString *)keyPath observer:(__weak </span><br><span class="line">    NSObject *)observer &#123;</span><br><span class="line"> </span><br><span class="line">    return [[[self</span><br><span class="line"> </span><br><span class="line">        rac_valuesAndChangesForKeyPath:keyPath options:NSKeyValueObservingOptionInitial observer:observer]</span><br><span class="line"> </span><br><span class="line">        map:^(RACTuple *value) &#123;</span><br><span class="line"> </span><br><span class="line">            // -map: because it doesn&apos;t require the block trampoline that -reduceEach: uses</span><br><span class="line"> </span><br><span class="line">            return value[0];</span><br><span class="line"> </span><br><span class="line">        &#125;]</span><br><span class="line"> </span><br><span class="line">        setNameWithFormat:@&quot;RACObserve(%@, %@)&quot;, self.rac_description, keyPath];</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)rac_valuesAndChangesForKeyPath:(NSString *)keyPath options:(</span><br><span class="line">    NSKeyValueObservingOptions)options observer:(__weak NSObject *)</span><br><span class="line">    weakObserver &#123;</span><br><span class="line"> </span><br><span class="line">    NSObject *strongObserver = weakObserver;</span><br><span class="line"> </span><br><span class="line">    keyPath = [keyPath copy];</span><br><span class="line"> </span><br><span class="line">    NSRecursiveLock *objectLock = [[NSRecursiveLock alloc] init];</span><br><span class="line"> </span><br><span class="line">    objectLock.name = @&quot;</span><br><span class="line">    org.reactivecocoa.ReactiveCocoa.NSObjectRACPropertySubscribing&quot;;</span><br><span class="line"> </span><br><span class="line">    __weak NSObject *weakSelf = self;</span><br><span class="line"> </span><br><span class="line">    RACSignal *deallocSignal = [[RACSignal</span><br><span class="line"> </span><br><span class="line">        zip:@[</span><br><span class="line"> </span><br><span class="line">            self.rac_willDeallocSignal,</span><br><span class="line"> </span><br><span class="line">            strongObserver.rac_willDeallocSignal ?: [RACSignal never]</span><br><span class="line"> </span><br><span class="line">        ]]</span><br><span class="line"> </span><br><span class="line">        doCompleted:^&#123;</span><br><span class="line"> </span><br><span class="line">            // Forces deallocation to wait if the object variables are currently</span><br><span class="line"> </span><br><span class="line">            // being read on another thread.</span><br><span class="line"> </span><br><span class="line">            [objectLock lock];</span><br><span class="line"> </span><br><span class="line">            @onExit &#123;</span><br><span class="line"> </span><br><span class="line">                [objectLock unlock];</span><br><span class="line"> </span><br><span class="line">            &#125;;</span><br><span class="line"> </span><br><span class="line">        &#125;];</span><br><span class="line"> </span><br><span class="line">//重点关注这里，createSignal之后的参数就是该信号的didSubscribe block逻辑了。</span><br><span class="line">    return [[[RACSignal</span><br><span class="line"> </span><br><span class="line">        createSignal:^ RACDisposable * (id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line"> </span><br><span class="line">            // Hold onto the lock the whole time we&apos;re setting up the KVO</span><br><span class="line"> </span><br><span class="line">            // observation, because any resurrection that might be caused by our</span><br><span class="line"> </span><br><span class="line">            // retaining below must be balanced out by the time -dealloc returns</span><br><span class="line"> </span><br><span class="line">            // (if another thread is waiting on the lock above).</span><br><span class="line"> </span><br><span class="line">            [objectLock lock];</span><br><span class="line"> </span><br><span class="line">            @onExit &#123;</span><br><span class="line"> </span><br><span class="line">                [objectLock unlock];</span><br><span class="line"> </span><br><span class="line">            &#125;;</span><br><span class="line"> </span><br><span class="line">            __strong NSObject *observer __attribute__((objc_precise_lifetime)) </span><br><span class="line">            = weakObserver;</span><br><span class="line"> </span><br><span class="line">            __strong NSObject *self __attribute__((objc_precise_lifetime)) = </span><br><span class="line">            weakSelf;</span><br><span class="line"> </span><br><span class="line">            if (self == nil) &#123;</span><br><span class="line"> </span><br><span class="line">                [subscriber sendCompleted];</span><br><span class="line"> </span><br><span class="line">                return nil;</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">            return [self rac_observeKeyPath:keyPath options:options observer:</span><br><span class="line">            observer block:^(id value, NSDictionary *change, BOOL </span><br><span class="line">                causedByDealloc, BOOL affectedOnlyLastComponent) &#123;</span><br><span class="line"> </span><br><span class="line">                [subscriber sendNext:RACTuplePack(value, change)];</span><br><span class="line"> </span><br><span class="line">            &#125;];</span><br><span class="line"> </span><br><span class="line">        &#125;]</span><br><span class="line"> </span><br><span class="line">        takeUntil:deallocSignal]</span><br><span class="line"> </span><br><span class="line">        setNameWithFormat:@&quot;%@ -rac_valueAndChangesForKeyPath: %@ options: %lu </span><br><span class="line">        observer: %@&quot;, self.rac_description, keyPath, (unsigned long)options, </span><br><span class="line">        strongObserver.rac_description];</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在RACObserver宏定义的signal的didSubscriber block中又调用了rac_observeKeyPath:keyPath options: observer: block</p>
<p>继续(太长了只贴重点)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)rac_observeKeyPath:(NSString *)keyPath options:(</span><br><span class="line">    NSKeyValueObservingOptions)options observer:(__weak NSObject *)</span><br><span class="line">    weakObserver block:(void (^)(id, NSDictionary *, BOOL, BOOL))block &#123;</span><br><span class="line"> </span><br><span class="line">    NSCParameterAssert(block != nil);</span><br><span class="line"> </span><br><span class="line">    NSCParameterAssert(keyPath.rac_keyPathComponents.count &gt; 0);</span><br><span class="line"> </span><br><span class="line">    //省略数十行</span><br><span class="line">    // Call the block with the initial value if needed.</span><br><span class="line"> </span><br><span class="line">    if ((options &amp; NSKeyValueObservingOptionInitial) != 0) &#123;</span><br><span class="line"> </span><br><span class="line">        id initialValue = [self valueForKeyPath:keyPath];</span><br><span class="line"> </span><br><span class="line">        NSDictionary *initialChange = @&#123;</span><br><span class="line"> </span><br><span class="line">            NSKeyValueChangeKindKey: @(NSKeyValueChangeSetting),</span><br><span class="line"> </span><br><span class="line">            NSKeyValueChangeNewKey: initialValue ?: NSNull.null,</span><br><span class="line"> </span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line">        block(initialValue, initialChange, NO, keyPathHasOneComponent);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    //省略数十行</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明一下，options是NSKeyValueObservingOptions属于NS_OPTIONS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, NSKeyValueObservingOptions) &#123;</span><br><span class="line"> </span><br><span class="line">    NSKeyValueObservingOptionNew = 0x01,</span><br><span class="line"> </span><br><span class="line">    NSKeyValueObservingOptionOld = 0x02,</span><br><span class="line"> </span><br><span class="line">    NSKeyValueObservingOptionInitial NS_ENUM_AVAILABLE(10_5, 2_0) = 0x04,</span><br><span class="line"> </span><br><span class="line">    NSKeyValueObservingOptionPrior NS_ENUM_AVAILABLE(10_5, 2_0) = 0x08</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在以上方法中，它判断了，传入的options是否是NSKeyValueObservingOptionInitial类型，而在调用rac_observeKeyPath: options: observer: block:的时候，option就是传的NSKeyValueObservingOptionInitial，所以会直接调用传进来的block，在rac_valuesAndChangesForKeyPath: options: observer:中调用rac_observeKeyPath: options: observer: block:的时候传入block里面的逻辑是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[subscriber sendNext:RACTuplePack(value, change)];</span><br></pre></td></tr></table></figure>
<p>综上所述，RACObserver生成的signal在调用subscribeNext方法订阅该信号的时候，会直接调用一次订阅信号之后next block的逻辑，所以即便是属性变化之后订阅属性变化信号，它也会默认先调用一次next block的逻辑。</p>
<p>正常kvo检测转化成信号的逻辑：</p>
<p>在RACObserver初始化的过程中，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)rac_observeKeyPath:(NSString *)keyPath options:(</span><br><span class="line">    NSKeyValueObservingOptions)options observer:(__weak NSObject *)</span><br><span class="line">    weakObserver block:(void (^)(id, NSDictionary *, BOOL, BOOL))block &#123;</span><br><span class="line"> </span><br><span class="line">    NSCParameterAssert(block != nil);</span><br><span class="line"> </span><br><span class="line">    NSCParameterAssert(keyPath.rac_keyPathComponents.count &gt; 0);</span><br><span class="line"> </span><br><span class="line">    //省略数十行</span><br><span class="line"> </span><br><span class="line">    NSKeyValueObservingOptions trampolineOptions = (options | </span><br><span class="line">        NSKeyValueObservingOptionPrior) &amp; ~NSKeyValueObservingOptionInitial;</span><br><span class="line"> </span><br><span class="line">    RACKVOTrampoline *trampoline = [[RACKVOTrampoline alloc] initWithTarget:</span><br><span class="line">    self observer:strongObserver keyPath:keyPathHead options:trampolineOptions </span><br><span class="line">    block:^(id trampolineTarget, id trampolineObserver, NSDictionary *change) &#123;</span><br><span class="line"> </span><br><span class="line">        // If this is a prior notification, clean up all the callbacks added to the</span><br><span class="line"> </span><br><span class="line">        // previous value and call the callback block. Everything else is deferred</span><br><span class="line"> </span><br><span class="line">        // until after we get the notification after the change.</span><br><span class="line"> </span><br><span class="line">        if ([change[NSKeyValueChangeNotificationIsPriorKey] boolValue]) &#123;</span><br><span class="line"> </span><br><span class="line">            [firstComponentDisposable() dispose];</span><br><span class="line"> </span><br><span class="line">            if ((options &amp; NSKeyValueObservingOptionPrior) != 0) &#123;</span><br><span class="line"> </span><br><span class="line">                block([trampolineTarget valueForKeyPath:keyPath], change, NO, </span><br><span class="line">                    keyPathHasOneComponent);</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        // From here the notification is not prior.</span><br><span class="line"> </span><br><span class="line">        NSObject *value = [trampolineTarget valueForKey:keyPathHead];</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        // If the value has changed but is nil, there is no need to add callbacks to</span><br><span class="line"> </span><br><span class="line">        // it, just call the callback block.</span><br><span class="line"> </span><br><span class="line">        if (value == nil) &#123;</span><br><span class="line">            block(nil, change, NO, keyPathHasOneComponent);</span><br><span class="line"> </span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        // From here the notification is not prior and the value is not nil.</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        // Create a new firstComponentDisposable while getting rid of the old one at</span><br><span class="line"> </span><br><span class="line">        // the same time, in case this is being called concurrently.</span><br><span class="line"> </span><br><span class="line">        RACDisposable *oldFirstComponentDisposable = [</span><br><span class="line">        firstComponentSerialDisposable swapInDisposable:[RACCompoundDisposable </span><br><span class="line">        compoundDisposable]];</span><br><span class="line"> </span><br><span class="line">        [oldFirstComponentDisposable dispose];</span><br><span class="line"> </span><br><span class="line">        addDeallocObserverToPropertyValue(value);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        // If there are no further key path components, there is no need to add the</span><br><span class="line"> </span><br><span class="line">        // other callbacks, just call the callback block with the value itself.</span><br><span class="line"> </span><br><span class="line">        if (keyPathHasOneComponent) &#123;</span><br><span class="line"> </span><br><span class="line">            block(value, change, NO, keyPathHasOneComponent);</span><br><span class="line"> </span><br><span class="line">            return;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        // The value has changed, is not nil, and there are more key path components</span><br><span class="line"> </span><br><span class="line">        // to consider. Add the callbacks to the value for the remaining key path</span><br><span class="line"> </span><br><span class="line">        // components and call the callback block with the current value of the full</span><br><span class="line"> </span><br><span class="line">        // key path.</span><br><span class="line"> </span><br><span class="line">        addObserverToValue(value);</span><br><span class="line"> </span><br><span class="line">        block([value valueForKeyPath:keyPathTail], change, NO, keyPathHasOneComponent);</span><br><span class="line"> </span><br><span class="line">    &#125;];</span><br><span class="line"> </span><br><span class="line">    // Stop the KVO observation when this one is disposed of.</span><br><span class="line"> </span><br><span class="line">    [disposable addDisposable:trampoline];</span><br><span class="line">  </span><br><span class="line">    //省略数十行</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该方法中生成了一个RACKVOTrampoline中间对象，看它的源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">- (id)initWithTarget:(__weak NSObject *)target observer:(__weak NSObject *)</span><br><span class="line">observer keyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)</span><br><span class="line">options block:(RACKVOBlock)block &#123;</span><br><span class="line"> </span><br><span class="line">    NSCParameterAssert(keyPath != nil);</span><br><span class="line"> </span><br><span class="line">    NSCParameterAssert(block != nil);</span><br><span class="line"> </span><br><span class="line">    NSObject *strongTarget = target;</span><br><span class="line"> </span><br><span class="line">    if (strongTarget == nil) return nil;</span><br><span class="line"> </span><br><span class="line">    self = [super init];</span><br><span class="line"> </span><br><span class="line">    if (self == nil) return nil;</span><br><span class="line">    _keyPath = [keyPath copy];</span><br><span class="line"> </span><br><span class="line">    _block = [block copy];</span><br><span class="line"> </span><br><span class="line">    _weakTarget = target;</span><br><span class="line"> </span><br><span class="line">    _unsafeTarget = strongTarget;</span><br><span class="line"> </span><br><span class="line">    _observer = observer;</span><br><span class="line"> </span><br><span class="line">    [RACKVOProxy.sharedProxy addObserver:self forContext:(__bridge void *)self];</span><br><span class="line"> </span><br><span class="line">    [strongTarget addObserver:RACKVOProxy.sharedProxy forKeyPath:self.keyPath </span><br><span class="line">    options:options context:(__bridge void *)self];</span><br><span class="line"> </span><br><span class="line">    [strongTarget.rac_deallocDisposable addDisposable:self];</span><br><span class="line"> </span><br><span class="line">    [self.observer.rac_deallocDisposable addDisposable:self];</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line"> </span><br><span class="line">    [self dispose];</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">#pragma mark Observation</span><br><span class="line"> </span><br><span class="line">- (void)dispose &#123;</span><br><span class="line"> </span><br><span class="line">    NSObject *target;</span><br><span class="line"> </span><br><span class="line">    NSObject *observer;</span><br><span class="line"> </span><br><span class="line">    @synchronized (self) &#123;</span><br><span class="line"> </span><br><span class="line">        _block = nil;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        // The target should still exist at this point, because we still need to</span><br><span class="line"> </span><br><span class="line">        // tear down its KVO observation. Therefore, we can use the unsafe</span><br><span class="line"> </span><br><span class="line">        // reference (and need to, because the weak one will have been zeroed by</span><br><span class="line"> </span><br><span class="line">        // now).</span><br><span class="line"> </span><br><span class="line">        target = self.unsafeTarget;</span><br><span class="line"> </span><br><span class="line">        observer = self.observer;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        _unsafeTarget = nil;</span><br><span class="line"> </span><br><span class="line">        _observer = nil;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    [target.rac_deallocDisposable removeDisposable:self];</span><br><span class="line"> </span><br><span class="line">    [observer.rac_deallocDisposable removeDisposable:self];</span><br><span class="line"> </span><br><span class="line">    [target removeObserver:RACKVOProxy.sharedProxy forKeyPath:self.keyPath </span><br><span class="line">    context:(__bridge void *)self];</span><br><span class="line"> </span><br><span class="line">    [RACKVOProxy.sharedProxy removeObserver:self forContext:(__bridge void *)self];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//系统的代理方法，其实是由RACKVOProxy.sharedProxy对象转发的，RACKVOProxy.sharedProxy才是真正处理系统消息的对象。</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(</span><br><span class="line">    NSDictionary *)change context:(void *)context &#123;</span><br><span class="line"> </span><br><span class="line">    if (context != (__bridge void *)self) &#123;</span><br><span class="line"> </span><br><span class="line">        [super observeValueForKeyPath:keyPath ofObject:object change:change </span><br><span class="line">        context:context];</span><br><span class="line"> </span><br><span class="line">        return;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    RACKVOBlock block;</span><br><span class="line"> </span><br><span class="line">    id observer;</span><br><span class="line"> </span><br><span class="line">    id target;</span><br><span class="line"> </span><br><span class="line">    @synchronized (self) &#123;</span><br><span class="line"> </span><br><span class="line">        block = self.block;</span><br><span class="line"> </span><br><span class="line">        observer = self.observer;</span><br><span class="line"> </span><br><span class="line">        target = self.weakTarget;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (block == nil || target == nil) return;</span><br><span class="line"> </span><br><span class="line">    block(target, observer, change);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到RACKVOTrampoline对象替代原来使用KVO的对象，作为系统的代理，实现了代理方法。实际上，真正调用系统KVO注册的方法的时候，是往一个叫RACKVOProxy.sharedProxy的全局单例对象注册的。RACKVOTrampoline是具体处理KVO消息的对象，在RACKVOPorxy.shareProxy对象中注册了所有使用RAC KVO的系统消息，再由它转发给具体的RACKVOTrampoline进行处理，而在RACKVOTrampoline处理的时候，调用了RACKVOtrampoline初始化的时候传进来的block。之后在RACKVOTrampoline参数block调用过程中就会调用sendNext方法了，往外面发信号数据。</p>
<p>以下是RACKVOProxy.sharedProxy</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">@interface RACKVOProxy()</span><br><span class="line"> </span><br><span class="line">@property (strong, nonatomic, readonly) NSMapTable *trampolines;</span><br><span class="line"> </span><br><span class="line">@property (strong, nonatomic, readonly) dispatch_queue_t queue;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">@end</span><br><span class="line"> </span><br><span class="line">@implementation RACKVOProxy</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">+ (instancetype)sharedProxy &#123;</span><br><span class="line"> </span><br><span class="line">    static RACKVOProxy *proxy;</span><br><span class="line"> </span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line"> </span><br><span class="line">        proxy = [[self alloc] init];</span><br><span class="line"> </span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    return proxy;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line"> </span><br><span class="line">    self = [super init];</span><br><span class="line"> </span><br><span class="line">    if (self == nil) return nil;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    _queue = dispatch_queue_create(&quot;org.reactivecocoa.ReactiveCocoa.RACKVOProxy</span><br><span class="line">    &quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"> </span><br><span class="line">    _trampolines = [NSMapTable strongToWeakObjectsMapTable];</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    return self;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)addObserver:(__weak NSObject *)observer forContext:(void *)context &#123;</span><br><span class="line"> </span><br><span class="line">    NSValue *valueContext = [NSValue valueWithPointer:context];</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    dispatch_sync(self.queue, ^&#123;</span><br><span class="line"> </span><br><span class="line">        [self.trampolines setObject:observer forKey:valueContext];</span><br><span class="line"> </span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)removeObserver:(NSObject *)observer forContext:(void *)context &#123;</span><br><span class="line"> </span><br><span class="line">    NSValue *valueContext = [NSValue valueWithPointer:context];</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    dispatch_sync(self.queue, ^&#123;</span><br><span class="line"> </span><br><span class="line">        [self.trampolines removeObjectForKey:valueContext];</span><br><span class="line"> </span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(</span><br><span class="line">    NSDictionary *)change context:(void *)context &#123;</span><br><span class="line"> </span><br><span class="line">    NSValue *valueContext = [NSValue valueWithPointer:context];</span><br><span class="line"> </span><br><span class="line">    __block NSObject *trueObserver;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    dispatch_sync(self.queue, ^&#123;</span><br><span class="line"> </span><br><span class="line">        trueObserver = [self.trampolines objectForKey:valueContext];</span><br><span class="line"> </span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    if (trueObserver != nil) &#123;</span><br><span class="line"> </span><br><span class="line">        [trueObserver observeValueForKeyPath:keyPath ofObject:object change:</span><br><span class="line">        change context:context];</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RACKVOProxy.sharedProxy管理了整个RAC 中KVO的处理系统KVO消息的中间对象和系统KVO消息的转发。</p>
<p>综合上面的代码可以看出，正是由于各种中间对象替用户实现了代理方法起了代理对象的作用，用户才能把代码写的更加紧凑清晰。</p>
<h2 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h2><p>看以下代码，假设combineLatest之后得到的信号是A</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[RACSignal combineLatest:@[[RACObserve(self, propertyA) ignore:nil], [</span><br><span class="line">RACObserve(self, propertyB) ignore:nil]]] subscribeNext:^(RACTuple *tuple) &#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>1.使用combineLatest的时候，第一次订阅会不会触发subscribeNext后面的block</p>
<p>2.combineLatest中的信号，是同时调用了sendNext之后会触发A调用sendNext，还是只需要其中有一个信号调用了sendNext会触发A调用sendNext</p>
<p>看一下combineLatest源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)combineLatest:(id&lt;NSFastEnumeration&gt;)signals &#123;</span><br><span class="line"> </span><br><span class="line">    return [[self join:signals block:^(RACSignal *left, RACSignal *right) &#123;</span><br><span class="line"> </span><br><span class="line">        return [left combineLatestWith:right];</span><br><span class="line"> </span><br><span class="line">    &#125;] setNameWithFormat:@&quot;+combineLatest: %@&quot;, signals];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续 join: block:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)join:(id&lt;NSFastEnumeration&gt;)streams block:(RACStream * (^)(id, </span><br><span class="line">    id))block &#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//第一段</span><br><span class="line">    RACStream *current = nil;</span><br><span class="line">    // Creates streams of successively larger tuples by combining the input</span><br><span class="line"> </span><br><span class="line">    // streams one-by-one.</span><br><span class="line"> </span><br><span class="line">    for (RACStream *stream in streams) &#123;</span><br><span class="line"> </span><br><span class="line">        // For the first stream, just wrap its values in a RACTuple. That way,</span><br><span class="line"> </span><br><span class="line">        // if only one stream is given, the result is still a stream of tuples.</span><br><span class="line"> </span><br><span class="line">        if (current == nil) &#123;</span><br><span class="line"> </span><br><span class="line">            current = [stream map:^(id x) &#123;</span><br><span class="line"> </span><br><span class="line">                return RACTuplePack(x);</span><br><span class="line"> </span><br><span class="line">            &#125;];</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        current = block(current, stream);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    if (current == nil) return [self empty];</span><br><span class="line">//第二段</span><br><span class="line">    return [current map:^(RACTuple *xs) &#123;</span><br><span class="line"> </span><br><span class="line">        // Right now, each value is contained in its own tuple, sorta like:</span><br><span class="line"> </span><br><span class="line">        //</span><br><span class="line"> </span><br><span class="line">        // (((1), 2), 3)</span><br><span class="line"> </span><br><span class="line">        //</span><br><span class="line"> </span><br><span class="line">        // We need to unwrap all the layers and create a tuple out of the result.</span><br><span class="line"> </span><br><span class="line">        NSMutableArray *values = [[NSMutableArray alloc] init];</span><br><span class="line"> </span><br><span class="line">        while (xs != nil) &#123;</span><br><span class="line">            [values insertObject:xs.last ?: RACTupleNil.tupleNil atIndex:0];</span><br><span class="line"> </span><br><span class="line">            xs = (xs.count &gt; 1 ? xs.first : nil);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        return [RACTuple tupleWithObjectsFromArray:values];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分代码分2段，第一段是将两个信号合并的逻辑，具体的合并逻辑是由外面传进来的block确定的。第二段是通过map将信号的值重新做了处理，第一段得到的信号属于signal of signals的类型，第二段将它打平。</p>
<p>再看一下combineLatestWith:方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)combineLatestWith:(RACSignal *)signal &#123;</span><br><span class="line">    NSCParameterAssert(signal != nil);</span><br><span class="line"> </span><br><span class="line">    return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line"> </span><br><span class="line">        RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"> </span><br><span class="line">        __block id lastSelfValue = nil;</span><br><span class="line"> </span><br><span class="line">        __block BOOL selfCompleted = NO;</span><br><span class="line"> </span><br><span class="line">        __block id lastOtherValue = nil;</span><br><span class="line"> </span><br><span class="line">        __block BOOL otherCompleted = NO;</span><br><span class="line"> </span><br><span class="line">        void (^sendNext)(void) = ^&#123;</span><br><span class="line"> </span><br><span class="line">            @synchronized (disposable) &#123;</span><br><span class="line"> </span><br><span class="line">                if (lastSelfValue == nil || lastOtherValue == nil) return;</span><br><span class="line"> </span><br><span class="line">                [subscriber sendNext:RACTuplePack(lastSelfValue, lastOtherValue)];</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line">        RACDisposable *selfDisposable = [self subscribeNext:^(id x) &#123;</span><br><span class="line"> </span><br><span class="line">            @synchronized (disposable) &#123;</span><br><span class="line"> </span><br><span class="line">                lastSelfValue = x ?: RACTupleNil.tupleNil;</span><br><span class="line"> </span><br><span class="line">                sendNext();</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125; error:^(NSError *error) &#123;</span><br><span class="line"> </span><br><span class="line">            [subscriber sendError:error];</span><br><span class="line"> </span><br><span class="line">        &#125; completed:^&#123;</span><br><span class="line"> </span><br><span class="line">            @synchronized (disposable) &#123;</span><br><span class="line"> </span><br><span class="line">                selfCompleted = YES;</span><br><span class="line"> </span><br><span class="line">                if (otherCompleted) [subscriber sendCompleted];</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;];</span><br><span class="line"> </span><br><span class="line">        [disposable addDisposable:selfDisposable];</span><br><span class="line"> </span><br><span class="line">        RACDisposable *otherDisposable = [signal subscribeNext:^(id x) &#123;</span><br><span class="line"> </span><br><span class="line">            @synchronized (disposable) &#123;</span><br><span class="line"> </span><br><span class="line">                lastOtherValue = x ?: RACTupleNil.tupleNil;</span><br><span class="line"> </span><br><span class="line">                sendNext();</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125; error:^(NSError *error) &#123;</span><br><span class="line"> </span><br><span class="line">            [subscriber sendError:error];</span><br><span class="line"> </span><br><span class="line">        &#125; completed:^&#123;</span><br><span class="line"> </span><br><span class="line">            @synchronized (disposable) &#123;</span><br><span class="line"> </span><br><span class="line">                otherCompleted = YES;</span><br><span class="line"> </span><br><span class="line">                if (selfCompleted) [subscriber sendCompleted];</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;];</span><br><span class="line"> </span><br><span class="line">        [disposable addDisposable:otherDisposable];</span><br><span class="line">        return disposable;</span><br><span class="line"> </span><br><span class="line">    &#125;] setNameWithFormat:@&quot;[%@] -combineLatestWith: %@&quot;, self.name, signal];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在以上代码中，调用了当前信号的subscribeNext方法，同时也调用了需要合并的信号的subscribeNext方法。subscribeNext方法block中调用了sendNext block，这个block是在combineLatestWith中定义，判断两个信号是否已经调用过sendNext，如果都同时掉用过sendNext就会触发combineLatest信号调用didSubscribe block，最终触发订阅combineLatest信号的传入的subscribeNext后的block。</p>
<p>综合上面的分析，类似于以下的使用方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[RACSignal combineLatest:@[[RACObserve(self, propertyA) ignore:nil], [RACObserve(self, propertyB) ignore:nil]]] subscribeNext:^(RACTuple *tuple) &#123;</span><br><span class="line"> </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>第一次订阅就会触发subscribeNext之后的block逻辑，并且是RACObserve这种类型的combineLatest才会，最上面已经分析了RACObserver生成的信号在第一次订阅调用的时候信号就会调用sendNext。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2016/01/25/ReactCocoa源码分析1/" data-id="cjkhxzalq001cm8enn218t04d" class="article-share-link">分享</a><div class="tags"><a href="/tags/源码分析/">源码分析</a></div><div class="post-nav"><a href="/2016/01/25/ReactiveCocoa2/" class="pre">ReactiveCocoa2</a><a href="/2016/01/25/MJExtension/" class="next">MJExtension</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Tech/">Tech</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">Tools</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/源码分析/" style="font-size: 15px;">源码分析</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/Node/" style="font-size: 15px;">Node</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/01/29/布局结束监测工具/">布局结束监听工具</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/11/Node小结/">Node小结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/02/iOS性能监控/">iOS性能监控</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/25/Method Swizzle的危机/">Method Swizzle的危机</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/25/GitHook/">Git Hook</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/19/Method Swizzle中的对象模型/">Method Swizzle中的对象模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/19/iOS定位库-INTULocationRequest/">iOS定位库-INTULocationRequest</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/13/AFNetWorking—NSURLSession/">AFNetWorking—NSURLSession</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/13/AFNetworking-NSURLConnection/">AFNetworking-NSURLConnection</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/13/AFNetworking-ResponseSerializer/">AFNetworking-ResponseSerializer</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">一只独来独往的水鸟.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>