<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="博客"><title>CFRunLoop | 一只独来独往的水鸟</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">CFRunLoop</h1><a id="logo" href="/.">一只独来独往的水鸟</a><p class="description">iOS</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">CFRunLoop</h1><div class="post-meta">Jan 26, 2016<span> | </span><span class="category"><a href="/categories/Tech/">Tech</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h3 id="u6570_u636E_u7ED3_u6784"><a href="#u6570_u636E_u7ED3_u6784" class="headerlink" title="数据结构"></a>数据结构</h3><p><strong>__CFRunLoopMode</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">struct</span> __CFRunLoopMode &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> _lock;  <span class="comment">/* must have the run loop locked before locking </span><br><span class="line">    this */</span></span><br><span class="line"><span class="comment">//mode名</span></span><br><span class="line">    CFStringRef _name;</span><br><span class="line">    Boolean _stopped;</span><br><span class="line">    <span class="keyword">char</span> _padding[<span class="number">3</span>];</span><br><span class="line"><span class="comment">//source0 源</span></span><br><span class="line">    CFMutableSetRef _sources0;</span><br><span class="line"><span class="comment">//source1 源</span></span><br><span class="line">    CFMutableSetRef _sources1;</span><br><span class="line"><span class="comment">//observer 源</span></span><br><span class="line">    CFMutableArrayRef _observers;</span><br><span class="line"><span class="comment">//timer 源</span></span><br><span class="line">    CFMutableArrayRef _timers;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//mach port 到 mode的映射,为了在runloop主逻辑中过滤runloop自己的port消息。</span></span><br><span class="line">    CFMutableDictionaryRef _portToV1SourceMap;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//记录了所有当前mode中需要监听的port，作为调用监听消息函数的参数。</span></span><br><span class="line">    __CFPortSet _portSet;</span><br><span class="line">    CFIndex _observerMask;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span></span><br><span class="line">    <span class="keyword">dispatch_source_t</span> _timerSource;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> _queue;</span><br><span class="line">    Boolean _timerFired; <span class="comment">// set to true by the source when a timer has fired</span></span><br><span class="line">    Boolean _dispatchTimerArmed;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> USE_MK_TIMER_TOO</span></span><br><span class="line"><span class="comment">//使用 mk timer， 用到的mach port，和source1类似，都依赖于mach port</span></span><br><span class="line">    <span class="keyword">mach_port_t</span> _timerPort;</span><br><span class="line">    Boolean _mkTimerArmed;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//timer触发的理想时间</span></span><br><span class="line">    <span class="keyword">uint64_t</span> _timerSoftDeadline; <span class="comment">/* TSR */</span></span><br><span class="line"><span class="comment">//timer触发的实际时间，理想时间加上tolerance（偏差）</span></span><br><span class="line">    <span class="keyword">uint64_t</span> _timerHardDeadline; <span class="comment">/* TSR */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>__CFRunLoop</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __CFRunLoop &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> _lock;          <span class="comment">/* locked for accessing mode list */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//用于手动将当前runloop线程唤醒，通过调用CFRunLoopWakeUp完成，</span></span><br><span class="line"><span class="comment">//CFRunLoopWakeUp会向_wakeUpPort发送一条消息</span></span><br><span class="line">    __CFPort _wakeUpPort;           <span class="comment">// used for CFRunLoopWakeUp </span></span><br><span class="line">    Boolean _unused;</span><br><span class="line">    <span class="keyword">volatile</span> _per_run_data *_perRunData; <span class="comment">// reset for runs of the run loop</span></span><br><span class="line">    <span class="keyword">pthread_t</span> _pthread;</span><br><span class="line">    <span class="keyword">uint32_t</span> _winthread;</span><br><span class="line"><span class="comment">//记录了当前runloop中所有的mode名</span></span><br><span class="line">    CFMutableSetRef _commonModes;</span><br><span class="line"><span class="comment">//记录了当前runloop中所有注册到commonMode中的源</span></span><br><span class="line">    CFMutableSetRef _commonModeItems;</span><br><span class="line">    CFRunLoopModeRef _currentMode;</span><br><span class="line">    CFMutableSetRef _modes;</span><br><span class="line"><span class="comment">//记录了添加到runloop中的block，它也可以像其他源一样被runloop处理，</span></span><br><span class="line"><span class="comment">//通过CFRunLoopPerformBlock可向runloop中添加block任务。</span></span><br><span class="line">    <span class="keyword">struct</span> _block_item *_blocks_head;</span><br><span class="line">    <span class="keyword">struct</span> _block_item *_blocks_tail;</span><br><span class="line">    CFTypeRef _counterpart;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>__CFRunLoops</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局字典，保存线程和对应runloop之间的关系</span></span><br><span class="line"><span class="keyword">static</span> CFMutableDictionaryRef __CFRunLoops = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<h2 id="u51FD_u6570_uFF1A"><a href="#u51FD_u6570_uFF1A" class="headerlink" title="函数："></a>函数：</h2><p><strong>__CFRunLoopRun</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int32_t</span> __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, </span><br><span class="line">    CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef </span><br><span class="line">    previousMode) &#123;</span><br><span class="line">    <span class="comment">//获取系统启动之后cpu嘀嗒数</span></span><br><span class="line">    <span class="keyword">uint64_t</span> startTSR = mach_absolute_time();</span><br><span class="line">    <span class="keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">        __CFRunLoopUnsetStopped(rl);</span><br><span class="line">    <span class="keyword">return</span> kCFRunLoopRunStopped;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;</span><br><span class="line">    rlm-&gt;_stopped = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> kCFRunLoopRunStopped;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//mach 端口, 线程之间通信的对象</span></span><br><span class="line">    <span class="keyword">mach_port_name_t</span> dispatchPort = MACH_PORT_NULL;</span><br><span class="line">    <span class="comment">//这里主要是为了判断当前线程是否为主线程        </span></span><br><span class="line">    Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((</span><br><span class="line">        HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; <span class="literal">NULL</span> == previousMode) || (!</span><br><span class="line">        HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; <span class="number">0</span> == _CFGetTSD(</span><br><span class="line">            __CFTSDKeyIsInGCDMainQ)));</span><br><span class="line">    <span class="keyword">if</span> (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl</span><br><span class="line">        -&gt;_commonModes, rlm-&gt;_name)) dispatchPort = </span><br><span class="line">        _dispatch_get_main_queue_port_4CF();</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//使用GCD实现runloop超时功能</span></span><br><span class="line">    <span class="keyword">dispatch_source_t</span> timeout_timer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">struct</span> __timeout_context *timeout_context = (<span class="keyword">struct</span> __timeout_context *)</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*timeout_context));</span><br><span class="line">    <span class="comment">//seconds是设置的runloop超时时间</span></span><br><span class="line">    <span class="keyword">if</span> (seconds &lt;= <span class="number">0.0</span>) &#123; <span class="comment">// instant timeout</span></span><br><span class="line">        seconds = <span class="number">0.0</span>;</span><br><span class="line">        timeout_context-&gt;termTSR = <span class="number">0U</span>LL;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(</span><br><span class="line">        DISPATCH_QUEUE_PRIORITY_HIGH, DISPATCH_QUEUE_OVERCOMMIT);</span><br><span class="line">    timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, </span><br><span class="line">        <span class="built_in">queue</span>);</span><br><span class="line">        dispatch_retain(timeout_timer);</span><br><span class="line">    timeout_context-&gt;ds = timeout_timer;</span><br><span class="line">    timeout_context-&gt;rl = (CFRunLoopRef)CFRetain(rl);</span><br><span class="line">    timeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds);</span><br><span class="line">    dispatch_set_context(timeout_timer, timeout_context); <span class="comment">// source gets </span></span><br><span class="line">    <span class="comment">//ownership of context</span></span><br><span class="line">    dispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout);</span><br><span class="line">        dispatch_source_set_cancel_handler_f(timeout_timer, </span><br><span class="line">            __CFRunLoopTimeoutCancel);</span><br><span class="line">        <span class="keyword">uint64_t</span> ns_at = (<span class="keyword">uint64_t</span>)((__CFTSRToTimeInterval(startTSR) + seconds)</span><br><span class="line">         * <span class="number">1000000000U</span>LL);</span><br><span class="line">        dispatch_source_set_timer(timeout_timer, dispatch_time(<span class="number">1</span>, ns_at), </span><br><span class="line">        DISPATCH_TIME_FOREVER, <span class="number">1000U</span>LL);</span><br><span class="line">        dispatch_resume(timeout_timer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// infinite timeout</span></span><br><span class="line">        seconds = <span class="number">9999999999.0</span>;</span><br><span class="line">        timeout_context-&gt;termTSR = UINT64_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    Boolean didDispatchPortLastTime = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int32_t</span> retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">uint8_t</span> msg_buffer[<span class="number">3</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">mach_msg_header_t</span> *msg = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">mach_port_t</span> livePort = MACH_PORT_NULL;</span><br><span class="line">    __CFPortSet waitSet = rlm-&gt;_portSet;</span><br><span class="line">        __CFRunLoopUnsetIgnoreWakeUps(rl);</span><br><span class="line">        <span class="comment">//rl-&gt;_perRunData-&gt;ignoreWakeUps = 0x0;</span></span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers</span><br><span class="line">        (rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) </span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line"><span class="comment">//Perform blocks queued by CFRunLoopPerformBlock;</span></span><br><span class="line">    __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, </span><br><span class="line">            stopAfterHandle);</span><br><span class="line">        <span class="comment">//如果rl中有source0消息</span></span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">            <span class="comment">//处理block  Perform blocks newly queued by CFRunLoopPerformBlock;</span></span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//poll标志着有没有处理source0的消息，如果没有则为false，反之为true</span></span><br><span class="line">        Boolean poll = sourceHandledThisLoop || (<span class="number">0U</span>LL == timeout_context-&gt;</span><br><span class="line">            termTSR);</span><br><span class="line">        <span class="comment">//第一次进来不走这个逻辑，didDispatchPortLastTime是true</span></span><br><span class="line">        <span class="keyword">if</span> (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123;</span><br><span class="line">            msg = (<span class="keyword">mach_msg_header_t</span> *)msg_buffer;</span><br><span class="line">            <span class="comment">//__CFRunLoopServiceMachPort用于接受指定端口(一个也可以是多个)</span></span><br><span class="line">            <span class="comment">//的消息,最后一个参数代表当端口无消息的时候是否休眠,0是立刻返回不休眠,</span></span><br><span class="line">            <span class="comment">//TIMEOUT_INFINITY代表休眠</span></span><br><span class="line">            <span class="comment">//处理通过GCD派发到主线程的任务,这些任务优先级最高会被最先处理</span></span><br><span class="line">            <span class="keyword">if</span> (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, <span class="keyword">sizeof</span>(</span><br><span class="line">                msg_buffer), &amp;livePort, <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">goto</span> handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        didDispatchPortLastTime = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//根据之前有没有处理过source0消息，来判断如果也没有source1消息的时候是否让线程进入睡眠，这里处</span></span><br><span class="line"><span class="comment">//理observer源，如果睡眠则通知Observer进入睡眠。</span></span><br><span class="line">    <span class="keyword">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) </span><br><span class="line">    __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">    __CFRunLoopSetSleeping(rl);</span><br><span class="line">    <span class="comment">// do not do any user callouts after this point (after notifying of </span></span><br><span class="line">        <span class="comment">//sleeping)</span></span><br><span class="line">        <span class="comment">// Must push the local-to-this-activation ports in on every loop</span></span><br><span class="line">        <span class="comment">// iteration, as this mode could be run re-entrantly and we don't</span></span><br><span class="line">        <span class="comment">// want these ports to get serviced.</span></span><br><span class="line">        __CFPortSetInsert(dispatchPort, waitSet);</span><br><span class="line">         </span><br><span class="line">    __CFRunLoopModeUnlock(rlm);</span><br><span class="line">    __CFRunLoopUnlock(rl);</span><br><span class="line">    <span class="keyword">if</span> (kCFUseCollectableAllocator) &#123;</span><br><span class="line">        objc_clear_stack(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">memset</span>(msg_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(msg_buffer));</span><br><span class="line">    &#125;</span><br><span class="line">    msg = (<span class="keyword">mach_msg_header_t</span> *)msg_buffer;</span><br><span class="line">    <span class="comment">//如果poll为null，且waitset中无port有消息,线程进入休眠</span></span><br><span class="line">    __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, </span><br><span class="line">    poll ? <span class="number">0</span> : TIMEOUT_INFINITY);</span><br><span class="line">     </span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    __CFRunLoopModeLock(rlm);</span><br><span class="line">    <span class="comment">// Must remove the local-to-this-activation ports in on every loop</span></span><br><span class="line">    <span class="comment">// iteration, as this mode could be run re-entrantly and we don't</span></span><br><span class="line">    <span class="comment">// want these ports to get serviced. Also, we don't want them left</span></span><br><span class="line">    <span class="comment">// in there if this function returns.</span></span><br><span class="line">    __CFPortSetRemove(dispatchPort, waitSet);</span><br><span class="line">     </span><br><span class="line">    __CFRunLoopSetIgnoreWakeUps(rl);</span><br><span class="line">        <span class="comment">// user callouts now OK again</span></span><br><span class="line">    __CFRunLoopUnsetSleeping(rl);</span><br><span class="line">    <span class="comment">//处理observer源，线程醒来</span></span><br><span class="line">    <span class="keyword">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting)) </span><br><span class="line">    __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line">        handle_msg:;</span><br><span class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</span><br><span class="line">        <span class="keyword">if</span> (MACH_PORT_NULL == livePort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_NOTHING();</span><br><span class="line">            <span class="comment">// handle nothing</span></span><br><span class="line"><span class="comment">//通过CFRunloopWake将当前线程唤醒</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (livePort == rl-&gt;_wakeUpPort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_WAKEUP();</span><br><span class="line">            <span class="comment">// do nothing on Mac OS</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//处理timer源</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;</span><br><span class="line">            _timerPort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</span><br><span class="line">            <span class="keyword">if</span> (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">                <span class="comment">// Re-arm the next timer</span></span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//通过GCD派发给主线程的任务</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (livePort == dispatchPort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_DISPATCH();</span><br><span class="line">            __CFRunLoopModeUnlock(rlm);</span><br><span class="line">            __CFRunLoopUnlock(rl);</span><br><span class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (<span class="keyword">void</span> *)<span class="number">6</span>, <span class="literal">NULL</span>);</span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (<span class="keyword">void</span> *)<span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">            __CFRunLoopLock(rl);</span><br><span class="line">            __CFRunLoopModeLock(rlm);</span><br><span class="line">            sourceHandledThisLoop = <span class="literal">true</span>;</span><br><span class="line">            didDispatchPortLastTime = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//通过macPort给当前线程派发消息,处理source1</span></span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_SOURCE();</span><br><span class="line">            <span class="comment">// Despite the name, this works for windows handles as well</span></span><br><span class="line">            <span class="comment">//过滤macPort消息，有一些消息不一定是runloop中注册的，这里只处理runloop中注册的</span></span><br><span class="line">            <span class="comment">//消息，在rlm-&gt;_portToV1SourceMap通过macPort找有没有对应的runloopMode</span></span><br><span class="line">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, </span><br><span class="line">                rlm, livePort);</span><br><span class="line">            <span class="keyword">if</span> (rls) &#123;</span><br><span class="line">                <span class="keyword">mach_msg_header_t</span> *reply = <span class="literal">NULL</span>;</span><br><span class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg,</span><br><span class="line">                 msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">NULL</span> != reply) &#123;</span><br><span class="line">                    <span class="comment">//当前线程处理完source1，给发消息的线程反馈消息, </span></span><br><span class="line">                    <span class="comment">//MACH_SEND_MSG表示给replay端口发送消息</span></span><br><span class="line">                    (<span class="keyword">void</span>)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, <span class="number">0</span>, </span><br><span class="line">                        MACH_PORT_NULL, <span class="number">0</span>, MACH_PORT_NULL);</span><br><span class="line">                    CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg &amp;&amp; msg != (<span class="keyword">mach_msg_header_t</span> *)msg_buffer) <span class="built_in">free</span>(msg);</span><br><span class="line">         </span><br><span class="line">    __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">    <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">        retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">        <span class="comment">//runloop超时时间到</span></span><br><span class="line">            retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">            __CFRunLoopUnsetStopped(rl);</span><br><span class="line">        retVal = kCFRunLoopRunStopped;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;</span><br><span class="line">        rlm-&gt;_stopped = <span class="literal">false</span>;</span><br><span class="line">        retVal = kCFRunLoopRunStopped;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">        retVal = kCFRunLoopRunFinished;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span> == retVal);</span><br><span class="line">    <span class="keyword">if</span> (timeout_timer) &#123;</span><br><span class="line">        dispatch_source_cancel(timeout_timer);</span><br><span class="line">        dispatch_release(timeout_timer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">free</span>(timeout_context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>CFRunLoopAddSource</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CFRunLoopAddSource</span><span class="params">(CFRunLoopRef rl, CFRunLoopSourceRef rls, </span><br><span class="line">    CFStringRef modeName)</span> </span>&#123;    <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="keyword">if</span> (__CFRunLoopIsDeallocating(rl)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!__CFIsValid(rls)) <span class="keyword">return</span>;</span><br><span class="line">    Boolean doVer0Callout = <span class="literal">false</span>;</span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    <span class="keyword">if</span> (modeName == kCFRunLoopCommonModes) &#123;</span><br><span class="line">        <span class="comment">//par1 : 处理commonModeItmes的逻辑</span></span><br><span class="line"><span class="comment">/*rl-&gt;_commonModes的作用是记录了当前runloop中标记为commonMode的mode，rl-&gt;_commonModeI</span><br><span class="line">tems记录了当前runloop中注册到commonMode中的源</span><br><span class="line">两者用来处理跟commonMode相关的逻辑，比如当一个mode被标记为commonMode的时候，会将rl-&gt;_common</span><br><span class="line">ModeItems中的源添加到新的mode当中去，在当前mode下这些源的消息就会被</span><br><span class="line">监听并处理。例如一个timer被注册到commonMode中，那么在所有被标记为commonMode的mode中都会处理该timer的消息。</span><br><span class="line">*/</span></span><br><span class="line">    CFSetRef <span class="built_in">set</span> = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault</span><br><span class="line">        , rl-&gt;_commonModes) : <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == rl-&gt;_commonModeItems) &#123;</span><br><span class="line">        rl-&gt;_commonModeItems = CFSetCreateMutable(kCFAllocatorSystemDefault, <span class="number">0</span>, &amp;kCFTypeSetCallBacks);</span><br><span class="line">    &#125;</span><br><span class="line">    CFSetAddValue(rl-&gt;_commonModeItems, rls);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != <span class="built_in">set</span>) &#123;</span><br><span class="line">        CFTypeRef context[<span class="number">2</span>] = &#123;rl, rls&#125;;</span><br><span class="line">        <span class="comment">/* add new item to all common-modes */</span></span><br><span class="line">        <span class="comment">//对每一个mode，调用part2的逻辑</span></span><br><span class="line">        CFSetApplyFunction(<span class="built_in">set</span>, (__CFRunLoopAddItemToCommonModes), (<span class="keyword">void</span> *)context);</span><br><span class="line">        CFRelease(<span class="built_in">set</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//part2 : 处理某个具体的mode中addSource的逻辑</span></span><br><span class="line">    CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != rlm &amp;&amp; <span class="literal">NULL</span> == rlm-&gt;_sources0) &#123;</span><br><span class="line">        rlm-&gt;_sources0 = CFSetCreateMutable(kCFAllocatorSystemDefault, <span class="number">0</span>, &amp;</span><br><span class="line">            kCFTypeSetCallBacks);</span><br><span class="line">        rlm-&gt;_sources1 = CFSetCreateMutable(kCFAllocatorSystemDefault, <span class="number">0</span>, &amp;</span><br><span class="line">            kCFTypeSetCallBacks);</span><br><span class="line">        rlm-&gt;_portToV1SourceMap = CFDictionaryCreateMutable(</span><br><span class="line">            kCFAllocatorSystemDefault, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != rlm &amp;&amp; !CFSetContainsValue(rlm-&gt;_sources0, rls) &amp;&amp; !</span><br><span class="line">    CFSetContainsValue(rlm-&gt;_sources1, rls)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == rls-&gt;_context.version0.version) &#123;</span><br><span class="line">            CFSetAddValue(rlm-&gt;_sources0, rls);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">1</span> == rls-&gt;_context.version0.version) &#123;</span><br><span class="line">            CFSetAddValue(rlm-&gt;_sources1, rls);</span><br><span class="line">        __CFPort src_port = rls-&gt;_context.version1.getPort(rls-&gt;_context.</span><br><span class="line">            version1.info);</span><br><span class="line">        <span class="keyword">if</span> (CFPORT_NULL != src_port) &#123;</span><br><span class="line">        <span class="comment">//rlm-&gt;_portToV1SourceMap是port到source1的映射，</span></span><br><span class="line">        <span class="comment">//为了在runloop主逻辑中过滤runloop自己的port消息。</span></span><br><span class="line">            CFDictionarySetValue(rlm-&gt;_portToV1SourceMap, (<span class="keyword">const</span> <span class="keyword">void</span> *)(</span><br><span class="line">                <span class="keyword">uintptr_t</span>)src_port, rls);</span><br><span class="line">        <span class="comment">//rml-&gt;_portSet记录了所有当前mode中需要监听的port，作为调用监听消息函数的参数。</span></span><br><span class="line">            __CFPortSetInsert(src_port, rlm-&gt;_portSet);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        __CFRunLoopSourceLock(rls);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == rls-&gt;_runLoops) &#123;</span><br><span class="line">            rls-&gt;_runLoops = CFBagCreateMutable(kCFAllocatorSystemDefault, <span class="number">0</span>, &amp;</span><br><span class="line">            kCFTypeBagCallBacks); <span class="comment">// sources retain run loops!</span></span><br><span class="line">        &#125;</span><br><span class="line">        CFBagAddValue(rls-&gt;_runLoops, rl);</span><br><span class="line">        __CFRunLoopSourceUnlock(rls);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == rls-&gt;_context.version0.version) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">NULL</span> != rls-&gt;_context.version0.schedule) &#123;</span><br><span class="line">                doVer0Callout = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != rlm) &#123;</span><br><span class="line">        __CFRunLoopModeUnlock(rlm);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __CFRunLoopUnlock(rl);</span><br><span class="line">    <span class="keyword">if</span> (doVer0Callout) &#123;</span><br><span class="line">        <span class="comment">// although it looses some protection for the source, we have no </span></span><br><span class="line">        <span class="comment">//choice but</span></span><br><span class="line">        <span class="comment">// to do this after unlocking the run loop and mode locks, to avoid </span></span><br><span class="line">        <span class="comment">//deadlocks</span></span><br><span class="line">        <span class="comment">// where the source wants to take a lock which is already held in </span></span><br><span class="line">        <span class="comment">//another</span></span><br><span class="line">        <span class="comment">// thread which is itself waiting for a run loop/mode lock</span></span><br><span class="line">    rls-&gt;_context.version0.schedule(rls-&gt;_context.version0.info, rl, modeName);   <span class="comment">/* CALLOUT */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>CFRunLoopRemoveSource</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">void CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef rls, </span><br><span class="line">    CFStringRef modeName) &#123; /* DOES CALLOUT */</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    Boolean doVer0Callout = false, doRLSRelease = false;</span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    if (modeName == kCFRunLoopCommonModes) &#123;</span><br><span class="line">        if (NULL != rl-&gt;_commonModeItems &amp;&amp; CFSetContainsValue(rl-&gt;</span><br><span class="line">            _commonModeItems, rls)) &#123;</span><br><span class="line">            CFSetRef set = rl-&gt;_commonModes ? CFSetCreateCopy(</span><br><span class="line">                kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL;</span><br><span class="line">            CFSetRemoveValue(rl-&gt;_commonModeItems, rls);</span><br><span class="line">            if (NULL != set) &#123;</span><br><span class="line">            CFTypeRef context[2] = &#123;rl, rls&#125;;</span><br><span class="line">            /* remove new item from all common-modes */</span><br><span class="line">            CFSetApplyFunction(set, (__CFRunLoopRemoveItemFromCommonModes), (</span><br><span class="line">                void *)context);</span><br><span class="line">            CFRelease(set);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, false);</span><br><span class="line">    if (NULL != rlm &amp;&amp; ((NULL != rlm-&gt;_sources0 &amp;&amp; CFSetContainsValue(rlm-&gt;</span><br><span class="line">        _sources0, rls)) || (NULL != rlm-&gt;_sources1 &amp;&amp; CFSetContainsValue(rlm-&gt;</span><br><span class="line">            _sources1, rls)))) &#123;</span><br><span class="line">        //source0或者source1中的一种</span><br><span class="line">        CFRetain(rls);</span><br><span class="line">        if (1 == rls-&gt;_context.version0.version) &#123;</span><br><span class="line">        __CFPort src_port = rls-&gt;_context.version1.getPort(rls-&gt;_context.</span><br><span class="line">            version1.info);</span><br><span class="line">                if (CFPORT_NULL != src_port) &#123;</span><br><span class="line">            CFDictionaryRemoveValue(rlm-&gt;_portToV1SourceMap, (const void *)(</span><br><span class="line">                uintptr_t)src_port);</span><br><span class="line">                    __CFPortSetRemove(src_port, rlm-&gt;_portSet);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        CFSetRemoveValue(rlm-&gt;_sources0, rls);</span><br><span class="line">        CFSetRemoveValue(rlm-&gt;_sources1, rls);</span><br><span class="line">            __CFRunLoopSourceLock(rls);</span><br><span class="line">            if (NULL != rls-&gt;_runLoops) &#123;</span><br><span class="line">                CFBagRemoveValue(rls-&gt;_runLoops, rl);</span><br><span class="line">            &#125;</span><br><span class="line">            __CFRunLoopSourceUnlock(rls);</span><br><span class="line">        if (0 == rls-&gt;_context.version0.version) &#123;</span><br><span class="line">            if (NULL != rls-&gt;_context.version0.cancel) &#123;</span><br><span class="line">                doVer0Callout = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        doRLSRelease = true;</span><br><span class="line">    &#125;</span><br><span class="line">        if (NULL != rlm) &#123;</span><br><span class="line">        __CFRunLoopModeUnlock(rlm);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __CFRunLoopUnlock(rl);</span><br><span class="line">    if (doVer0Callout) &#123;</span><br><span class="line">        // although it looses some protection for the source, we have no choice but</span><br><span class="line">        // to do this after unlocking the run loop and mode locks, to avoid deadlocks</span><br><span class="line">        // where the source wants to take a lock which is already held in another</span><br><span class="line">        // thread which is itself waiting for a run loop/mode lock</span><br><span class="line">        rls-&gt;_context.version0.cancel(rls-&gt;_context.version0.info, rl, modeName); /* CALLOUT */</span><br><span class="line">    &#125;</span><br><span class="line">    if (doRLSRelease) CFRelease(rls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>CFRunLoopAddTimer</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CFRunLoopAddTimer</span><span class="params">(CFRunLoopRef rl, CFRunLoopTimerRef rlt, CFStringRef </span><br><span class="line">    modeName)</span> </span>&#123;   </span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="keyword">if</span> (__CFRunLoopIsDeallocating(rl)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!__CFIsValid(rlt) || (<span class="literal">NULL</span> != rlt-&gt;_runLoop &amp;&amp; rlt-&gt;_runLoop != rl)) </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    <span class="keyword">if</span> (modeName == kCFRunLoopCommonModes) &#123;</span><br><span class="line">    CFSetRef <span class="built_in">set</span> = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault</span><br><span class="line">        , rl-&gt;_commonModes) : <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == rl-&gt;_commonModeItems) &#123;</span><br><span class="line">        rl-&gt;_commonModeItems = CFSetCreateMutable(kCFAllocatorSystemDefault, <span class="number">0</span>,</span><br><span class="line">         &amp;kCFTypeSetCallBacks);</span><br><span class="line">    &#125;</span><br><span class="line">    CFSetAddValue(rl-&gt;_commonModeItems, rlt);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != <span class="built_in">set</span>) &#123;</span><br><span class="line">        CFTypeRef context[<span class="number">2</span>] = &#123;rl, rlt&#125;;</span><br><span class="line">        <span class="comment">/* add new item to all common-modes */</span></span><br><span class="line">        CFSetApplyFunction(<span class="built_in">set</span>, (__CFRunLoopAddItemToCommonModes), (<span class="keyword">void</span> *)</span><br><span class="line">        context);</span><br><span class="line">        CFRelease(<span class="built_in">set</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != rlm) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">NULL</span> == rlm-&gt;_timers) &#123;</span><br><span class="line">                CFArrayCallBacks cb = kCFTypeArrayCallBacks;</span><br><span class="line">                cb.equal = <span class="literal">NULL</span>;</span><br><span class="line">                rlm-&gt;_timers = CFArrayCreateMutable(kCFAllocatorSystemDefault, </span><br><span class="line">                    <span class="number">0</span>, &amp;cb);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != rlm &amp;&amp; !CFSetContainsValue(rlt-&gt;_rlModes, rlm-&gt;_name)) &#123;</span><br><span class="line">            __CFRunLoopTimerLock(rlt);</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">NULL</span> == rlt-&gt;_runLoop) &#123;</span><br><span class="line">        rlt-&gt;_runLoop = rl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rl != rlt-&gt;_runLoop) &#123;</span><br><span class="line">                __CFRunLoopTimerUnlock(rlt);</span><br><span class="line">            __CFRunLoopModeUnlock(rlm);</span><br><span class="line">                __CFRunLoopUnlock(rl);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        CFSetAddValue(rlt-&gt;_rlModes, rlm-&gt;_name);</span><br><span class="line">            __CFRunLoopTimerUnlock(rlt);</span><br><span class="line">            __CFRunLoopTimerFireTSRLock();</span><br><span class="line">            <span class="comment">//__CFRepositionTimerInMode是添加或者删除timer,</span></span><br><span class="line">            <span class="comment">//这里是往rlm-&gt;_timers添加timer</span></span><br><span class="line">            __CFRepositionTimerInMode(rlm, rlt, <span class="literal">false</span>);</span><br><span class="line">            __CFRunLoopTimerFireTSRUnlock();</span><br><span class="line">            <span class="keyword">if</span> (!_CFExecutableLinkedOnOrAfter(CFSystemVersionLion)) &#123;</span><br><span class="line">                <span class="comment">// Normally we don't do this on behalf of clients, but for</span></span><br><span class="line">                <span class="comment">// backwards compatibility due to the change in timer handling...</span></span><br><span class="line">                <span class="keyword">if</span> (rl != CFRunLoopGetCurrent()) CFRunLoopWakeUp(rl);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != rlm) &#123;</span><br><span class="line">        __CFRunLoopModeUnlock(rlm);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __CFRunLoopUnlock(rl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>__CFRunLoopFindMode</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">static CFRunLoopModeRef __CFRunLoopFindMode(CFRunLoopRef rl, CFStringRef </span><br><span class="line">    modeName, Boolean create) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    CFRunLoopModeRef rlm;</span><br><span class="line">    struct __CFRunLoopMode srlm;</span><br><span class="line">    memset(&amp;srlm, 0, sizeof(srlm));</span><br><span class="line">    _CFRuntimeSetInstanceTypeIDAndIsa(&amp;srlm, __kCFRunLoopModeTypeID);</span><br><span class="line">    srlm._name = modeName;</span><br><span class="line">    rlm = (CFRunLoopModeRef)CFSetGetValue(rl-&gt;_modes, &amp;srlm);</span><br><span class="line">    if (NULL != rlm) &#123;</span><br><span class="line">    __CFRunLoopModeLock(rlm);</span><br><span class="line">    return rlm;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!create) &#123;</span><br><span class="line">    return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    rlm = (CFRunLoopModeRef)_CFRuntimeCreateInstance(kCFAllocatorSystemDefault,</span><br><span class="line">     __kCFRunLoopModeTypeID, sizeof(struct __CFRunLoopMode) - sizeof(</span><br><span class="line">        CFRuntimeBase), NULL);</span><br><span class="line">    if (NULL == rlm) &#123;</span><br><span class="line">    return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    __CFRunLoopLockInit(&amp;rlm-&gt;_lock);</span><br><span class="line">    rlm-&gt;_name = CFStringCreateCopy(kCFAllocatorSystemDefault, modeName);</span><br><span class="line">    rlm-&gt;_stopped = false;</span><br><span class="line">    rlm-&gt;_portToV1SourceMap = NULL;</span><br><span class="line">    rlm-&gt;_sources0 = NULL;</span><br><span class="line">    rlm-&gt;_sources1 = NULL;</span><br><span class="line">    rlm-&gt;_observers = NULL;</span><br><span class="line">    rlm-&gt;_timers = NULL;</span><br><span class="line">    rlm-&gt;_observerMask = 0;</span><br><span class="line">    rlm-&gt;_portSet = __CFPortSetAllocate();</span><br><span class="line">    rlm-&gt;_timerSoftDeadline = UINT64_MAX;</span><br><span class="line">    rlm-&gt;_timerHardDeadline = UINT64_MAX;</span><br><span class="line">     </span><br><span class="line">    kern_return_t ret = KERN_SUCCESS;</span><br><span class="line">    //1</span><br><span class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span><br><span class="line">    rlm-&gt;_timerFired = false;</span><br><span class="line">    rlm-&gt;_queue = _dispatch_runloop_root_queue_create_4CF("Run Loop Mode Queue"</span><br><span class="line">    , 0);</span><br><span class="line">    mach_port_t queuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;</span><br><span class="line">        _queue);</span><br><span class="line">    if (queuePort == MACH_PORT_NULL) CRASH("*** Unable to create run loop mode </span><br><span class="line">    queue port. (%d) ***", -1);</span><br><span class="line">    rlm-&gt;_timerSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0</span><br><span class="line">        , rlm-&gt;_queue);</span><br><span class="line">     </span><br><span class="line">    __block Boolean *timerFiredPointer = &amp;(rlm-&gt;_timerFired);</span><br><span class="line">    dispatch_source_set_event_handler(rlm-&gt;_timerSource, ^&#123;</span><br><span class="line">        *timerFiredPointer = true;</span><br><span class="line">    &#125;);</span><br><span class="line">     </span><br><span class="line">    // Set timer to far out there. The unique leeway makes this timer easy to spot in debug output.</span><br><span class="line">    _dispatch_source_set_runloop_timer_4CF(rlm-&gt;_timerSource, </span><br><span class="line">        DISPATCH_TIME_FOREVER, DISPATCH_TIME_FOREVER, 321);</span><br><span class="line">    dispatch_resume(rlm-&gt;_timerSource);</span><br><span class="line">     </span><br><span class="line">    ret = __CFPortSetInsert(queuePort, rlm-&gt;_portSet);</span><br><span class="line">    if (KERN_SUCCESS != ret) CRASH("*** Unable to insert timer port into port </span><br><span class="line">    set. (%d) ***", ret);</span><br><span class="line">     </span><br><span class="line">#endif</span><br><span class="line">    //1</span><br><span class="line">#if USE_MK_TIMER_TOO</span><br><span class="line">    rlm-&gt;_timerPort = mk_timer_create();</span><br><span class="line">    ret = __CFPortSetInsert(rlm-&gt;_timerPort, rlm-&gt;_portSet);</span><br><span class="line">    if (KERN_SUCCESS != ret) CRASH("*** Unable to insert timer port into port </span><br><span class="line">    set. (%d) ***", ret);</span><br><span class="line">#endif</span><br><span class="line">     </span><br><span class="line">    ret = __CFPortSetInsert(rl-&gt;_wakeUpPort, rlm-&gt;_portSet);</span><br><span class="line">    if (KERN_SUCCESS != ret) CRASH("*** Unable to insert wake up port into </span><br><span class="line">    port set. (%d) ***", ret);</span><br><span class="line">     </span><br><span class="line">    CFSetAddValue(rl-&gt;_modes, rlm);</span><br><span class="line">    CFRelease(rlm);</span><br><span class="line">    __CFRunLoopModeLock(rlm);   /* return mode locked */</span><br><span class="line">    return rlm;</span><br><span class="line">&#125;  ``return` `rlm;``&#125;`</span><br></pre></td></tr></table></figure>
<p><strong>__CFRepositionTimerInMode</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRepositionTimerInMode(CFRunLoopModeRef rlm, CFRunLoopTimerRef </span><br><span class="line">    rlt, Boolean isInArray) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!rlt) <span class="keyword">return</span>;</span><br><span class="line">     </span><br><span class="line">    CFMutableArrayRef timerArray = rlm-&gt;_timers;</span><br><span class="line">    <span class="keyword">if</span> (!timerArray) <span class="keyword">return</span>;</span><br><span class="line">    Boolean found = <span class="literal">false</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// If we know in advance that the timer is not in the array (just being added now) then we can skip this search</span></span><br><span class="line">    <span class="keyword">if</span> (isInArray) &#123;</span><br><span class="line">        CFIndex idx = CFArrayGetFirstIndexOfValue(timerArray, CFRangeMake(<span class="number">0</span>, </span><br><span class="line">            CFArrayGetCount(timerArray)), rlt);</span><br><span class="line">        <span class="keyword">if</span> (kCFNotFound != idx) &#123;</span><br><span class="line">            CFRetain(rlt);</span><br><span class="line">            CFArrayRemoveValueAtIndex(timerArray, idx);</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!found &amp;&amp; isInArray) <span class="keyword">return</span>;</span><br><span class="line">    CFIndex newIdx = __CFRunLoopInsertionIndexInTimerArray(timerArray, rlt);</span><br><span class="line">   <span class="comment">//timer开始计时</span></span><br><span class="line">    CFArrayInsertValueAtIndex(timerArray, newIdx, rlt);</span><br><span class="line">    __CFArmNextTimerInMode(rlm, rlt-&gt;_runLoop);</span><br><span class="line">    <span class="keyword">if</span> (isInArray) CFRelease(rlt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>__CFArmNextTimerInMode</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFArmNextTimerInMode(CFRunLoopModeRef rlm, CFRunLoopRef rl) &#123;   </span><br><span class="line">    <span class="keyword">uint64_t</span> nextHardDeadline = UINT64_MAX;</span><br><span class="line">    <span class="keyword">uint64_t</span> nextSoftDeadline = UINT64_MAX;</span><br><span class="line">    <span class="keyword">if</span> (rlm-&gt;_timers) &#123;</span><br><span class="line">        <span class="comment">// Look at the list of timers. We will calculate two TSR values; the </span></span><br><span class="line"><span class="comment">//next soft and next hard deadline.</span></span><br><span class="line">        <span class="comment">// The next soft deadline is the first time we can fire any timer. </span></span><br><span class="line"><span class="comment">//This is the fire date of the first timer in our sorted list of timers.</span></span><br><span class="line">        <span class="comment">// The next hard deadline is the last time at which we can fire the </span></span><br><span class="line"><span class="comment">//timer before we've moved out of the allowable tolerance of the timers in our list.</span></span><br><span class="line">        <span class="keyword">for</span> (CFIndex idx = <span class="number">0</span>, cnt = CFArrayGetCount(rlm-&gt;_timers); idx &lt; cnt; </span><br><span class="line">idx++) &#123;</span><br><span class="line">            CFRunLoopTimerRef t = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(rlm</span><br><span class="line">    -&gt;_timers , idx);</span><br><span class="line">            <span class="comment">// discount timers currently firing</span></span><br><span class="line">            <span class="keyword">if</span> (__CFRunLoopTimerIsFiring(t)) <span class="keyword">continue</span>;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">int32_t</span> err = CHECKINT_NO_ERROR;</span><br><span class="line">            <span class="keyword">uint64_t</span> oneTimerSoftDeadline = t-&gt;_fireTSR;</span><br><span class="line">            <span class="keyword">uint64_t</span> oneTimerHardDeadline = check_uint64_add(t-&gt;_fireTSR, </span><br><span class="line">    __CFTimeIntervalToTSR(t-&gt;_tolerance), &amp;err);</span><br><span class="line">            <span class="keyword">if</span> (err != CHECKINT_NO_ERROR) oneTimerHardDeadline = UINT64_MAX;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">// We can stop searching if the soft deadline for this timer exceeds the current hard deadline. Otherwise, later timers with lower tolerance could still have earlier hard deadlines.</span></span><br><span class="line">            <span class="keyword">if</span> (oneTimerSoftDeadline &gt; nextHardDeadline) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span> (oneTimerSoftDeadline &lt; nextSoftDeadline) &#123;</span><br><span class="line">                nextSoftDeadline = oneTimerSoftDeadline;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span> (oneTimerHardDeadline &lt; nextHardDeadline) &#123;</span><br><span class="line">                nextHardDeadline = oneTimerHardDeadline;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span> (nextSoftDeadline &lt; UINT64_MAX &amp;&amp; (nextHardDeadline != rlm-&gt;</span><br><span class="line">    _timerHardDeadline || nextSoftDeadline != rlm-&gt;_timerSoftDeadline)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (CFRUNLOOP_NEXT_TIMER_ARMED_ENABLED()) &#123;</span><br><span class="line">                CFRUNLOOP_NEXT_TIMER_ARMED((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nextSoftDeadline - </span><br><span class="line">    mach_absolute_time()));</span><br><span class="line">            &#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span></span><br><span class="line">            <span class="comment">// We're going to hand off the range of allowable timer fire date </span></span><br><span class="line"><span class="comment">//to dispatch and let it fire when appropriate for the system.</span></span><br><span class="line">            <span class="keyword">uint64_t</span> leeway = __CFTSRToNanoseconds(nextHardDeadline - </span><br><span class="line">    nextSoftDeadline);</span><br><span class="line">            <span class="keyword">dispatch_time_t</span> deadline = __CFTSRToDispatchTime(nextSoftDeadline);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> USE_MK_TIMER_TOO</span></span><br><span class="line"><span class="comment">//leeway表示timer的偏差，如果_tolerance(&gt;=0)为0，则leeway等于0</span></span><br><span class="line">            <span class="keyword">if</span> (leeway &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//GCD timer</span></span><br><span class="line">                <span class="comment">// Only use the dispatch timer if we have any leeway</span></span><br><span class="line">                <span class="comment">// &lt;rdar://problem/14447675&gt;</span></span><br><span class="line">                 </span><br><span class="line">                <span class="comment">// Cancel the mk timer</span></span><br><span class="line">                <span class="keyword">if</span> (rlm-&gt;_mkTimerArmed &amp;&amp; rlm-&gt;_timerPort) &#123;</span><br><span class="line">                    AbsoluteTime dummy;</span><br><span class="line">                    mk_timer_cancel(rlm-&gt;_timerPort, &amp;dummy);</span><br><span class="line">                    rlm-&gt;_mkTimerArmed = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">// Arm the dispatch timer</span></span><br><span class="line">                _dispatch_source_set_runloop_timer_4CF(rlm-&gt;_timerSource, </span><br><span class="line">    deadline, DISPATCH_TIME_FOREVER, leeway);</span><br><span class="line">                rlm-&gt;_dispatchTimerArmed = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//mk timer，实际中是这种情况</span></span><br><span class="line">                <span class="comment">// Cancel the dispatch timer</span></span><br><span class="line">                <span class="keyword">if</span> (rlm-&gt;_dispatchTimerArmed) &#123;</span><br><span class="line">                    <span class="comment">// Cancel the dispatch timer</span></span><br><span class="line">                    _dispatch_source_set_runloop_timer_4CF(rlm-&gt;_timerSource, </span><br><span class="line">    DISPATCH_TIME_FOREVER, DISPATCH_TIME_FOREVER, <span class="number">888</span>);</span><br><span class="line">                    rlm-&gt;_dispatchTimerArmed = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">// Arm the mk timer</span></span><br><span class="line">                <span class="keyword">if</span> (rlm-&gt;_timerPort) &#123;</span><br><span class="line"><span class="comment">//timer开始运行</span></span><br><span class="line">                    mk_timer_arm(rlm-&gt;_timerPort, __CFUInt64ToAbsoluteTime(</span><br><span class="line">    nextSoftDeadline));</span><br><span class="line">                    rlm-&gt;_mkTimerArmed = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">            _dispatch_source_set_runloop_timer_4CF(rlm-&gt;_timerSource, deadline,</span><br><span class="line"> DISPATCH_TIME_FOREVER, leeway);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="keyword">if</span> (rlm-&gt;_timerPort) &#123;</span><br><span class="line">                mk_timer_arm(rlm-&gt;_timerPort, __CFUInt64ToAbsoluteTime(</span><br><span class="line">    nextSoftDeadline));</span><br><span class="line">            &#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextSoftDeadline == UINT64_MAX) &#123;</span><br><span class="line">            <span class="comment">// Disarm the timers - there is no timer scheduled</span></span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span> (rlm-&gt;_mkTimerArmed &amp;&amp; rlm-&gt;_timerPort) &#123;</span><br><span class="line">                AbsoluteTime dummy;</span><br><span class="line">                mk_timer_cancel(rlm-&gt;_timerPort, &amp;dummy);</span><br><span class="line">                rlm-&gt;_mkTimerArmed = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span></span><br><span class="line">            <span class="keyword">if</span> (rlm-&gt;_dispatchTimerArmed) &#123;</span><br><span class="line">                _dispatch_source_set_runloop_timer_4CF(rlm-&gt;_timerSource, </span><br><span class="line">    DISPATCH_TIME_FOREVER, DISPATCH_TIME_FOREVER, <span class="number">333</span>);</span><br><span class="line">                rlm-&gt;_dispatchTimerArmed = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rlm-&gt;_timerHardDeadline = nextHardDeadline;</span><br><span class="line">    rlm-&gt;_timerSoftDeadline = nextSoftDeadline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>_CFRunLoopGet0</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(<span class="keyword">pthread_t</span> t) &#123;</span><br><span class="line">    <span class="comment">//判断t是否是传的空，如果是当成主线程处理</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_equal(t, kNilPthreadT)) &#123;</span><br><span class="line">        t = pthread_main_thread_np();</span><br><span class="line">    &#125;</span><br><span class="line">    __CFSpinLock(&amp;loopsLock);</span><br><span class="line"><span class="comment">//__CFRunLoops是全局存储线程和runloop关系的字典</span></span><br><span class="line">    <span class="keyword">if</span> (!__CFRunLoops) &#123;</span><br><span class="line"><span class="comment">//__CFRunLoop第一次初始化</span></span><br><span class="line">        __CFSpinUnlock(&amp;loopsLock);</span><br><span class="line"><span class="comment">//初始化__CFRunLoop</span></span><br><span class="line">    CFMutableDictionaryRef dict = CFDictionaryCreateMutable(</span><br><span class="line">        kCFAllocatorSystemDefault, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line"><span class="comment">//生成主线程对应runloop</span></span><br><span class="line">    CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</span><br><span class="line"><span class="comment">//存储到__CFRunLoop字典中</span></span><br><span class="line">    CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</span><br><span class="line">    <span class="keyword">if</span> (!OSAtomicCompareAndSwapPtrBarrier(<span class="literal">NULL</span>, dict, (<span class="keyword">void</span> * <span class="keyword">volatile</span> *)&amp;</span><br><span class="line">    __CFRunLoops)) &#123;</span><br><span class="line">        CFRelease(dict);</span><br><span class="line">    &#125;</span><br><span class="line">    CFRelease(mainLoop);</span><br><span class="line">        __CFSpinLock(&amp;loopsLock);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//找到线程t对应的runloop</span></span><br><span class="line">    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, </span><br><span class="line">        pthreadPointer(t));</span><br><span class="line">    __CFSpinUnlock(&amp;loopsLock);</span><br><span class="line">    <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line"><span class="comment">//没有找到，创建一个</span></span><br><span class="line">    CFRunLoopRef newLoop = __CFRunLoopCreate(t);</span><br><span class="line">        __CFSpinLock(&amp;loopsLock);</span><br><span class="line"><span class="comment">//??????</span></span><br><span class="line">    loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">    <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line"><span class="comment">//保存到全局字典中</span></span><br><span class="line">        CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);</span><br><span class="line">        loop = newLoop;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// don't release run loops inside the loopsLock, because </span></span><br><span class="line">        <span class="comment">//CFRunLoopDeallocate may end up taking it --&gt; --&gt;</span></span><br><span class="line">        __CFSpinUnlock(&amp;loopsLock);</span><br><span class="line">    CFRelease(newLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pthread_equal(t, pthread_self())) &#123;</span><br><span class="line">        _CFSetTSD(__CFTSDKeyRunLoop, (<span class="keyword">void</span> *)loop, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</span><br><span class="line">            _CFSetTSD(__CFTSDKeyRunLoopCntr, (<span class="keyword">void</span> *)(</span><br><span class="line">                PTHREAD_DESTRUCTOR_ITERATIONS-<span class="number">1</span>), (<span class="keyword">void</span> (*)(<span class="keyword">void</span> *))</span><br><span class="line">                __CFFinalizeRunLoop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2016/01/26/CFRunLoop/" data-id="cj528qvxr0014j7cv33hi2qyn" class="article-share-link">分享</a><div class="tags"><a href="/tags/源码分析/">源码分析</a></div><div class="post-nav"><a href="/2016/10/13/AFNetworking-RequestSerializer/" class="pre">AFNetworking-RequestSerializer</a><a href="/2016/01/26/RunLoop介绍/" class="next">RunLoop介绍</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Tech/">Tech</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/郑智文/">郑智文</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/源码分析/" style="font-size: 15px;">源码分析</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/07/13/Method Swizzle中的对象模型/">Method Swizzle中的对象模型</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/19/iOS定位库-INTULocationRequest/">iOS定位库-INTULocationRequest</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/13/AFNetWorking—NSURLSession/">AFNetWorking—NSURLSession</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/13/AFNetworking-NSURLConnection/">AFNetworking-NSURLConnection</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/13/AFNetworking-ResponseSerializer/">AFNetworking-ResponseSerializer</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/13/AFNetworking-RequestSerializer/">AFNetworking-RequestSerializer</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/26/CFRunLoop/">CFRunLoop</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/26/RunLoop介绍/">RunLoop介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/26/hexo-github/">hexo+github</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/26/hexo-github搭建博客/">hexo+github搭建博客</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">一只独来独往的水鸟.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>